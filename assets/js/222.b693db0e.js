(window.webpackJsonp=window.webpackJsonp||[]).push([[222],{714:function(v,_,t){"use strict";t.r(_);var r=t(2),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[v._v("#")]),v._v(" 目录")]),v._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"#1-java-%E5%9F%BA%E7%A1%80%E4%B8%8E%E9%9B%86%E5%90%88"}},[v._v("Java 基础与集合")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#2-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"}},[v._v("并发与多线程")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#3-jvm-%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"}},[v._v("JVM 与性能优化")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#4-spring-%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1"}},[v._v("Spring 与微服务")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#5-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98"}},[v._v("数据库与缓存")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#6-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91"}},[v._v("分布式与高并发")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#7-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%9E%B6%E6%9E%84"}},[v._v("设计模式与架构")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#8-%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"}},[v._v("项目实战与问题排查")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#9-%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8"}},[v._v("网络与安全")])]),v._v(" "),t("li",[t("a",{attrs:{href:"#10-%E5%BC%80%E6%94%BE%E6%80%A7%E4%B8%8E%E7%BB%BC%E5%90%88%E5%9C%BA%E6%99%AF%E9%A2%98"}},[v._v("开放性与综合场景题")])])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_1-java-基础与集合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-java-基础与集合"}},[v._v("#")]),v._v(" 1. Java 基础与集合")]),v._v(" "),t("h3",{attrs:{id:"q1-如果你要实现一个高并发下的计数器-选-atomicinteger-还是-synchronized-为什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-如果你要实现一个高并发下的计数器-选-atomicinteger-还是-synchronized-为什么"}},[v._v("#")]),v._v(" Q1：如果你要实现一个高并发下的计数器，选 "),t("code",[v._v("AtomicInteger")]),v._v(" 还是 "),t("code",[v._v("synchronized")]),v._v("，为什么？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答（面试话术）：")])]),v._v(" "),t("blockquote",[t("p",[v._v("我会优先考虑 "),t("code",[v._v("AtomicInteger")]),v._v(" 或更适合高并发场景的 "),t("code",[v._v("LongAdder/LongAccumulator")]),v._v("，因为它们都是基于无锁 CAS（Compare-And-Swap）或分段累加实现，性能在高并发下明显优于 "),t("code",[v._v("synchronized")]),v._v("。"),t("code",[v._v("synchronized")]),v._v(" 会导致线程阻塞和上下文切换，吞吐量下降。若计数逻辑是“简单的 ++ 操作”，用 "),t("code",[v._v("LongAdder")]),v._v(" 能显著降低竞争。如果是复合操作（比如先读取再根据值做多步操作），则需要额外同步或用 "),t("code",[v._v("AtomicReference")]),v._v("/锁来保证原子性。\n"),t("strong",[v._v("考察点：")]),v._v(" 了解无锁与锁的区别、知道 LongAdder 适用场景、能辨识复合操作的原子性问题。\n"),t("strong",[v._v("常见追问：")]),v._v(" 为什么 "),t("code",[v._v("LongAdder")]),v._v(" 更快？（答：分段累加，减少 CAS 冲突）复合操作如何保证一致性？（答：使用锁或设计无冲突算法）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-hashmap-在多线程下会出现什么问题-线程安全如何选型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-hashmap-在多线程下会出现什么问题-线程安全如何选型"}},[v._v("#")]),v._v(" Q2：HashMap 在多线程下会出现什么问题？线程安全如何选型？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[t("code",[v._v("HashMap")]),v._v(" 在多线程写场景下会出现数据不一致、丢失更新，甚至在极端情况下链表/树结构并发修改导致环形链表，线程自旋导致 CPU 占用。线程安全的替代方案优先选 "),t("code",[v._v("ConcurrentHashMap")]),v._v("（高并发读写友好），轻量场景可用 "),t("code",[v._v("Collections.synchronizedMap")]),v._v("。在需要有序或并发排序的场景，也可以考虑 "),t("code",[v._v("ConcurrentSkipListMap")]),v._v("。选择时要考虑并发度、性能、是否需要原子复合操作（computeIfAbsent 等）。\n"),t("strong",[v._v("考察点：")]),v._v(" 并发容器差异与适用场景。\n"),t("strong",[v._v("常见追问：")]),v._v(" "),t("code",[v._v("ConcurrentHashMap")]),v._v(" 的实现原理？（答：分段/节点级别 CAS + synchronized 在冲突时）如何保证复合操作一致性？（答：使用 compute 系列方法或外部锁）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-如何在集合中快速去重并保持插入顺序"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-如何在集合中快速去重并保持插入顺序"}},[v._v("#")]),v._v(" Q3：如何在集合中快速去重并保持插入顺序？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("直接使用 "),t("code",[v._v("LinkedHashSet")]),v._v("，它在内部维护 hash + 双向链表，既保证了元素唯一性也保持插入顺序。如果需要保留重复但计数信息，则用 "),t("code",[v._v("LinkedHashMap")]),v._v(" 或在流式操作中 "),t("code",[v._v("Collectors.toMap")]),v._v(" + LinkedHashMap。\n"),t("strong",[v._v("考察点：")]),v._v(" 熟悉集合选择、时间复杂度、内存代价。\n"),t("strong",[v._v("常见追问：")]),v._v(" 流（Stream）怎么实现去重保持顺序？（答："),t("code",[v._v(".distinct()")]),v._v(" 保持遇到的顺序）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-统计超大日志-几百gb-中出现次数最多的-ip-你怎么做"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-统计超大日志-几百gb-中出现次数最多的-ip-你怎么做"}},[v._v("#")]),v._v(" Q4：统计超大日志（几百GB）中出现次数最多的 IP，你怎么做？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("我会采用分布式或外部分片方案：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("MapReduce/Spark")]),v._v("：最直接，按 IP 分组聚合，适合已有集群。")]),v._v(" "),t("li",[t("strong",[v._v("单机分片")]),v._v("：按 IP 的 hash 值把日志分成 N 个小文件（每个小于可处理内存），分别统计每个文件中每个 IP 的计数（内存内 HashMap），然后把各分片的统计结果汇总（合并计数）。\n关键点是“先分散再局部统计再合并”，避免一次性把整个文件加载到内存。还可用外部排序或 HyperLogLog（近似计数）根据需求做空间-精度权衡。\n"),t("strong",[v._v("考察点：")]),v._v(" 分布式数据处理、外部排序、流式/分片思路。\n"),t("strong",[v._v("常见追问：")]),v._v(" 如何选择分片数？（答：根据单机内存与单分片最大大小估算，保证分片可在内存中统计）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-arraylist-与-linkedlist-区别-如何选型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-arraylist-与-linkedlist-区别-如何选型"}},[v._v("#")]),v._v(" Q5：ArrayList 与 LinkedList 区别，如何选型？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[t("code",[v._v("ArrayList")]),v._v(" 底层是数组，随机访问快 (O(1))，尾部追加快，插入/删除中间元素需要移动元素 (O(n))；"),t("code",[v._v("LinkedList")]),v._v(" 是双向链表，插入/删除任意已定位节点 O(1)，但随机访问慢 O(n)，并且链表节点对象开销更大。实际工程里大部分场景使用 "),t("code",[v._v("ArrayList")]),v._v("，除非确实有大量中间插入/删除且不关心随机访问性能。\n"),t("strong",[v._v("考察点：")]),v._v(" 时间/空间复杂度、内存开销、实际偏好。\n"),t("strong",[v._v("常见追问：")]),v._v(" Iterator.remove 对 ArrayList/LinkedList 的影响？（答：ArrayList 需要移动元素，LinkedList 是修改指针）")])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_2-并发与多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-并发与多线程"}},[v._v("#")]),v._v(" 2. 并发与多线程")]),v._v(" "),t("h3",{attrs:{id:"q1-如何设计一个高性能的生产者-消费者模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-如何设计一个高性能的生产者-消费者模型"}},[v._v("#")]),v._v(" Q1：如何设计一个高性能的生产者-消费者模型？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("推荐使用 JDK 提供的 "),t("code",[v._v("BlockingQueue")]),v._v("（例如 "),t("code",[v._v("LinkedBlockingQueue")]),v._v(" 或 "),t("code",[v._v("ArrayBlockingQueue")]),v._v("）配合线程池（"),t("code",[v._v("ExecutorService")]),v._v("）来解耦生产者与消费者。生产者 "),t("code",[v._v("put()")]),v._v("，消费者 "),t("code",[v._v("take()")]),v._v("，队列自动阻塞处理并发、背压和流量削峰。若追求更高性能（低延迟、高吞吐），可以考虑 "),t("code",[v._v("Disruptor")]),v._v("（无锁环形缓冲区）或将生产者/消费者分成多队列分片以减少竞争。关键措施还包括：限定队列大小、合理的拒绝策略、监控队列长度与处理延迟、使用批处理来提高吞吐（消费者一次批量处理多条）。\n"),t("strong",[v._v("考察点：")]),v._v(" 实际架构能力、背压与限流思想、工具使用。\n"),t("strong",[v._v("常见追问：")]),v._v(" 为什么不自己用 wait/notify？（答：复杂、容易出错，JDK 已成熟实现）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-如何避免线程池任务堆积-突发暴增怎么办"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-如何避免线程池任务堆积-突发暴增怎么办"}},[v._v("#")]),v._v(" Q2：如何避免线程池任务堆积？突发暴增怎么办？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("几种实操策略：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("设计限流")]),v._v("：在入口处用令牌桶/漏桶进行限流，拒绝过多请求或打回到上游。")]),v._v(" "),t("li",[t("strong",[v._v("合理线程池与队列配置")]),v._v("：核心线程数、最大线程数、队列容量按业务吞吐设计，使用合理的 "),t("code",[v._v("RejectedExecutionHandler")]),v._v("（如 CallerRunsPolicy）来倒逼调用方执行或降级。")]),v._v(" "),t("li",[t("strong",[v._v("削峰填谷")]),v._v("：将请求异步化进入消息队列（Kafka/RabbitMQ），消费者按速率处理。")]),v._v(" "),t("li",[t("strong",[v._v("动态扩容")]),v._v("：结合监控（队列长度、延迟）做自动扩缩容。\n"),t("strong",[v._v("考察点：")]),v._v(" 流控思路、工程化解决方案、对拒绝策略的理解。\n"),t("strong",[v._v("常见追问：")]),v._v(" CallerRunsPolicy 的风险？（答：调用线程也会做任务，可能影响上游响应）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-10-个线程打印-1-100-如何保证数字不乱"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-10-个线程打印-1-100-如何保证数字不乱"}},[v._v("#")]),v._v(" Q3：10 个线程打印 1-100，如何保证数字不乱？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("如果目标是“数字按顺序打印 1..100”，可以用 "),t("code",[v._v("ReentrantLock + Condition")]),v._v(" 或多 Condition 的方式控制线程唤醒顺序，或者使用 "),t("code",[v._v("Semaphore")]),v._v("/"),t("code",[v._v("Phaser")]),v._v(" 来协调；也可以用一个共享 "),t("code",[v._v("AtomicInteger")]),v._v("，每个线程循环读取并 "),t("code",[v._v("incrementAndGet()")]),v._v("，在读取到属于自己的数字时打印。若不要求固定哪一线程打印，只要不重复与丢失，使用 "),t("code",[v._v("AtomicInteger")]),v._v(" 作递增计数器足够。\n"),t("strong",[v._v("考察点：")]),v._v(" 线程协作 API 熟练度、思路清晰度。\n"),t("strong",[v._v("常见追问：")]),v._v(" 用 wait/notify 实现的关键点？（答：持有同一 monitor，循环判断条件并用 notifyAll/notify 唤醒）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-如何在并发环境下实现阻塞队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-如何在并发环境下实现阻塞队列"}},[v._v("#")]),v._v(" Q4：如何在并发环境下实现阻塞队列？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("原理上用数组/链表做队列，并用 "),t("code",[v._v("ReentrantLock")]),v._v(" + 两个 "),t("code",[v._v("Condition")]),v._v("（notEmpty、notFull）实现：当队列满时生产者 await，队列空时消费者 await；入队后 signal notEmpty；出队后 signal notFull。JDK 的 "),t("code",[v._v("ArrayBlockingQueue")]),v._v(" 就是这样的实现。要注意公平性和避免死锁。\n"),t("strong",[v._v("考察点：")]),v._v(" 并发原语理解、生产者-消费者模式实现细节。\n"),t("strong",[v._v("常见追问：")]),v._v(" 使用 "),t("code",[v._v("synchronized + wait/notify")]),v._v(" 的注意点？（答：必须在循环中判断条件，避免 spurious wakeup）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-threadlocal-的适用与内存泄漏风险"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-threadlocal-的适用与内存泄漏风险"}},[v._v("#")]),v._v(" Q5：ThreadLocal 的适用与内存泄漏风险？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[t("code",[v._v("ThreadLocal")]),v._v(" 用于保存与线程生命周期绑定的数据（例如事务上下文、用户信息、数据库连接短期缓存等），避免显式传参。在使用线程池时特别要注意调用 "),t("code",[v._v("remove()")]),v._v("："),t("code",[v._v("ThreadLocalMap")]),v._v(" 的 key 是弱引用，但是 value 为强引用，如果 key 被回收而 value 未清理，长久运行的线程（线程池线程）会导致内存无法释放，表现为“内存泄漏”。因此要在 finally 中 "),t("code",[v._v("threadLocal.remove()")]),v._v("，或在业务结束时清理。\n"),t("strong",[v._v("考察点：")]),v._v(" 对 ThreadLocal 实现细节的认知与工程化使用习惯。\n"),t("strong",[v._v("常见追问：")]),v._v(" 为什么在非线程池场景也要 remove？（答：良好习惯，避免不可预见的引用）")])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_3-jvm-与性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-jvm-与性能优化"}},[v._v("#")]),v._v(" 3. JVM 与性能优化")]),v._v(" "),t("h3",{attrs:{id:"q1-线上服务频繁-full-gc-如何排查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-线上服务频繁-full-gc-如何排查"}},[v._v("#")]),v._v(" Q1：线上服务频繁 Full GC，如何排查？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("排查思路：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("确认现象")]),v._v("：查看监控（GC 次数、Full GC 停顿时间、堆占用）。")]),v._v(" "),t("li",[t("strong",[v._v("获取 GC 日志")]),v._v("：通过 GC 日志分析是 Minor GC 还是 Full GC，查看晋升失败或大对象频繁分配。")]),v._v(" "),t("li",[t("strong",[v._v("线程与堆快照")]),v._v("：在异常期做 "),t("code",[v._v("jmap -heap")]),v._v(" / "),t("code",[v._v("jmap -dump")]),v._v("，或用 Arthas / VisualVM 拉 heapdump，分析是否有内存泄漏（大量不可回收对象）。")]),v._v(" "),t("li",[t("strong",[v._v("检查代码热点")]),v._v("：用 profiler（async-profiler、YourKit）查看大对象分配来源。")]),v._v(" "),t("li",[t("strong",[v._v("调整或替换 GC 策略")]),v._v("：例如从 CMS 转 G1，调整堆大小与新生代/老年代比例。\n总之要先区分“内存泄漏”与“真实内存不足”，再决定是修代码还是调参数/换 GC。\n"),t("strong",[v._v("考察点：")]),v._v(" 监控->日志->堆转储->分析的系统化排查能力。\n"),t("strong",[v._v("常见追问：")]),v._v(" 常用工具有哪些？（答：jstat/jmap/jstack/jcmd/VisualVM/Arthas/async-profiler/MAT）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-接口响应时间变长-如何用-jvm-工具定位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-接口响应时间变长-如何用-jvm-工具定位"}},[v._v("#")]),v._v(" Q2：接口响应时间变长，如何用 JVM 工具定位？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("排查顺序：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("APM/调用链")]),v._v("：先看调用链（SkyWalking/Zipkin/Jaeger）定位到慢的依赖（DB、RPC、外部接口）。")]),v._v(" "),t("li",[t("strong",[v._v("线程堆栈")]),v._v("："),t("code",[v._v("jstack")]),v._v(" 抓取线程快照，看是否有大量 BLOCKED 或 WAITING（锁竞争或 IO 阻塞）。")]),v._v(" "),t("li",[t("strong",[v._v("CPU/堆内存")]),v._v("：用 "),t("code",[v._v("top")]),v._v("/"),t("code",[v._v("jstat")]),v._v("/"),t("code",[v._v("jmap")]),v._v(" 看是否 CPU 或 GC 导致，必要时做 CPU profile 查找热点方法。")]),v._v(" "),t("li",[t("strong",[v._v("数据库监控")]),v._v("：确认是否是慢 SQL 导致，使用慢查询日志与 EXPLAIN。\n结合这些步骤可以较快定位到是应用 CPU 瓶颈、GC 问题、线程阻塞还是外部依赖。\n"),t("strong",[v._v("考察点：")]),v._v(" 全链路排查能力与工具链熟悉度。\n"),t("strong",[v._v("常见追问：")]),v._v(" 如果 jstack 显示很多 BLOCKED，下一步？（答：定位持有锁的线程，看代码是否有长时间同步块）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-解释-jmm-和-volatile-的作用。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-解释-jmm-和-volatile-的作用。"}},[v._v("#")]),v._v(" Q3：解释 JMM 和 "),t("code",[v._v("volatile")]),v._v(" 的作用。")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("Java 内存模型（JMM）定义了多个线程之间变量可见性的规则和重排序的约束。"),t("code",[v._v("volatile")]),v._v(" 的两个主要语义是："),t("strong",[v._v("可见性")]),v._v("（写对其他线程立即可见）和"),t("strong",[v._v("禁止指令重排序")]),v._v("（volatile 写-读之间不会被 JVM/CPU 重排序）。但 "),t("code",[v._v("volatile")]),v._v(" 不保证复合操作的原子性（例如 "),t("code",[v._v("i++")]),v._v(" 不是原子操作），因此在需要原子复合操作时仍需锁或原子类。"),t("code",[v._v("volatile")]),v._v(" 常用于状态标志、双重检查锁中的实例引用等场景。\n"),t("strong",[v._v("考察点：")]),v._v(" 对 happen-before、内存屏障、原子性、可见性区分清楚。\n"),t("strong",[v._v("常见追问：")]),v._v(" 双重检查锁中 volatile 的作用？（答：防止指令重排序导致另一个线程看到半初始化对象）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-堆内存不足且-full-gc-无法回收对象怎么办"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-堆内存不足且-full-gc-无法回收对象怎么办"}},[v._v("#")]),v._v(" Q4：堆内存不足且 Full GC 无法回收对象怎么办？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("这通常意味着这些对象仍然被引用。排查思路：")]),v._v(" "),t("ul",[t("li",[v._v("导出 heap dump，用 MAT 查找占用大对象和 GC Roots 的引用链（静态变量、线程本地变量、类加载器引用、JNI 全局引用等）。")]),v._v(" "),t("li",[v._v("检查缓存（静态集合、LRU 未生效）、线程池中 ThreadLocal 未清理、或第三方库造成的持有。\n解决方式：修复代码释放引用、优化缓存策略（弱引用/软引用/定期清理）、或在业务上改变对象生命周期。必要时也可通过增大堆或调整 GC，但本质仍是释放不可达引用或修复泄漏。\n"),t("strong",[v._v("考察点：")]),v._v(" 对内存泄漏根源的典型来源与定位流程熟悉。\n"),t("strong",[v._v("常见追问：")]),v._v(" MAT 中看不到直接 leak，怎么办？（答：看 Dominator Tree、查找 Retained Size 最大的对象并沿引用链分析）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-如何在线上-dump-堆并分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-如何在线上-dump-堆并分析"}},[v._v("#")]),v._v(" Q5：如何在线上 dump 堆并分析？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("线上做 heap dump 时需注意安全与影响（可能会停顿），可选工具和步骤：")]),v._v(" "),t("ol",[t("li",[v._v("使用 "),t("code",[v._v("jmap -dump:live")]),v._v(" 或 Arthas 的 heap dump 命令生成文件（确保磁盘足够且在适当时窗执行）。")]),v._v(" "),t("li",[v._v("下载到本地用 Eclipse MAT 分析，查看 Dominator Tree、Top Consumers、Leak Suspects。")]),v._v(" "),t("li",[v._v("找到占用大的对象类型和引用链，定位持有根（static、thread、classloader）。")]),v._v(" "),t("li",[v._v("修复后在预发布验证并在生产小流量环境复测。\n"),t("strong",[v._v("考察点：")]),v._v(" 工程化的风险控制意识与分析流程。\n"),t("strong",[v._v("常见追问：")]),v._v(" 堆 dump 导致 OOM？（答：使用 "),t("code",[v._v("-dump:live")]),v._v(" 减少无用对象，或在低流量时段执行）")])])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_4-spring-与微服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-spring-与微服务"}},[v._v("#")]),v._v(" 4. Spring 与微服务")]),v._v(" "),t("h3",{attrs:{id:"q1-spring-boot-服务启动慢-如何排查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-spring-boot-服务启动慢-如何排查"}},[v._v("#")]),v._v(" Q1：Spring Boot 服务启动慢，如何排查？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("排查步骤：")]),v._v(" "),t("ol",[t("li",[v._v("启用 "),t("code",[v._v("spring-boot-starter-actuator")]),v._v(" 的 startup 分析，或者使用 "),t("code",[v._v("spring-boot-starter")]),v._v(" 的启动时间日志。")]),v._v(" "),t("li",[v._v("检查是否有大量自动装配 Bean、过深的包扫描、@ComponentScan 扫描过大范围。")]),v._v(" "),t("li",[v._v("是否有第三方库在启动期间做大量初始化（外部服务连接、数据迁移、Flyway/liquibase、复杂的 BeanPostProcessor）。")]),v._v(" "),t("li",[v._v("考虑使用 lazy initialization（按需加载 Bean），推迟不必要的初始化。")]),v._v(" "),t("li",[v._v("如果使用容器（如 Tomcat），检查 connector 或 SSL 初始化耗时。\n"),t("strong",[v._v("考察点：")]),v._v(" 对 Spring 启动流程的理解与工程化优化能力。\n"),t("strong",[v._v("常见追问：")]),v._v(" 如何测哪些 Bean 占时？（答：用 Spring 的 ApplicationStartup 以及启动分析工具）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-spring-的循环依赖怎么解-是否都有解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-spring-的循环依赖怎么解-是否都有解"}},[v._v("#")]),v._v(" Q2：Spring 的循环依赖怎么解？是否都有解？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("Spring 对 "),t("strong",[v._v("单例 Bean 的字段注入/Setter 注入")]),v._v(" 采用三级缓存（单例池、早期暴露对象、ObjectFactory）来解决循环依赖；但 "),t("strong",[v._v("构造器注入")]),v._v(" 的循环依赖无法自动解决，Spring 会抛出异常。解决办法：重构为 setter 注入或把其中一方拆分成接口/延迟加载，或者把部分依赖抽象为事件/回调。\n"),t("strong",[v._v("考察点：")]),v._v(" Spring IOC 的实现细节与实际工程改造能力。\n"),t("strong",[v._v("常见追问：")]),v._v(" 三级缓存是怎样工作？（答：提前放入一个 ObjectFactory，允许通过代理/早期引用打断循环）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-spring-cloud-下如何实现灰度发布"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-spring-cloud-下如何实现灰度发布"}},[v._v("#")]),v._v(" Q3：Spring Cloud 下如何实现灰度发布？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("常见灰度方案：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("网关路由")]),v._v("：在网关层（如 Spring Cloud Gateway/Nginx）按 header、cookie 或用户 ID 的 hash 对流量分配到不同版本。")]),v._v(" "),t("li",[t("strong",[v._v("注册中心元数据")]),v._v("：在服务注册时为新版本打标签，网关或客户端负载均衡器依据标签路由。")]),v._v(" "),t("li",[t("strong",[v._v("流量开关/配置中心")]),v._v("：结合配置中心（Nacos/Consul）动态调整灰度比例。")]),v._v(" "),t("li",[t("strong",[v._v("A/B & Canary")]),v._v("：先给小量真实用户放量，监控关键指标（错误率、延迟），验证后逐步扩大。要保证请求追踪与日志分离，以便对灰度用户做回退与回溯。\n"),t("strong",[v._v("考察点：")]),v._v(" 灰度发布的策略、回退机制与监控指标。\n"),t("strong",[v._v("常见追问：")]),v._v(" 灰度时如何处理数据库兼容性？（答：兼容性优先，读写分离或数据模型兼容再切换）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-分布式事务如何处理-你实际用过什么方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-分布式事务如何处理-你实际用过什么方案"}},[v._v("#")]),v._v(" Q4：分布式事务如何处理？你实际用过什么方案？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("分布式事务常见方案有三类：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("XA/2PC")]),v._v("：事务强一致，但复杂且对性能冲击大，生产上少用。")]),v._v(" "),t("li",[t("strong",[v._v("TCC（Try-Confirm-Cancel）")]),v._v("：业务可拆分三个阶段，适合对一致性要求高但能实现补偿的场景。实现复杂。")]),v._v(" "),t("li",[t("strong",[v._v("最终一致性（常用）")]),v._v("：通过消息队列（Outbox Pattern）+ 补偿机制实现，配合幂等性保证最终一致。\n在项目里我常用 "),t("strong",[v._v("消息队列 + 异步补偿")]),v._v("：写业务数据时同时写入 outbox 表或直接入 MQ，消费者再做落库并保证幂等。该方案简单、扩展性好，适合大多数电商/订单类场景。Seata 等中间件适用于需要透明化事务管理但要注意对 DB 的侵入性。\n"),t("strong",[v._v("考察点：")]),v._v(" 熟悉各种方案的利弊与工程取舍。\n"),t("strong",[v._v("常见追问：")]),v._v(" Outbox pattern 的要点？（答：保证消息与 DB 写入原子性，通常用同一 DB 事务写入 outbox 表）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-微服务-qps-激增导致雪崩-如何保护系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-微服务-qps-激增导致雪崩-如何保护系统"}},[v._v("#")]),v._v(" Q5：微服务 QPS 激增导致雪崩，如何保护系统？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("常规保护策略：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("限流")]),v._v("：在网关/服务入口做令牌桶或漏桶限流，优先保证核心业务。")]),v._v(" "),t("li",[t("strong",[v._v("降级")]),v._v("：对非关键功能返回缓存或友好提示，减少后端压力。")]),v._v(" "),t("li",[t("strong",[v._v("熔断")]),v._v("：使用 Sentinel/Hystrix/Resilience4j 对下游服务做熔断，避免级联故障。")]),v._v(" "),t("li",[t("strong",[v._v("缓存")]),v._v("：把热点数据缓存到 Redis 或 CDN，减少 DB 压力。")]),v._v(" "),t("li",[t("strong",[v._v("扩容与异步化")]),v._v("：使用消息队列缓冲突发流量，结合自动扩容。\n关键是把“短时流量控制”与“中长期扩缩容”结合，并做好灰度与回滚策略。\n"),t("strong",[v._v("考察点：")]),v._v(" 业务连续性、工程化降级与监控体系的搭建。\n"),t("strong",[v._v("常见追问：")]),v._v(" 熔断如何设置阈值？（答：根据错误率、延迟以及业务容忍度设定并动态调整）")])])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_5-数据库与缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-数据库与缓存"}},[v._v("#")]),v._v(" 5. 数据库与缓存")]),v._v(" "),t("h3",{attrs:{id:"q1-mysql-慢查询如何优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-mysql-慢查询如何优化"}},[v._v("#")]),v._v(" Q1：MySQL 慢查询如何优化？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("排查与优化步骤：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("定位慢 SQL")]),v._v("：看慢查询日志，复现并用 "),t("code",[v._v("EXPLAIN")]),v._v(" 分析执行计划。")]),v._v(" "),t("li",[t("strong",[v._v("索引优化")]),v._v("：为筛选、排序字段建立合适索引，优先覆盖索引（select 列被索引覆盖）。避免在索引字段上使用函数或隐式类型转换。")]),v._v(" "),t("li",[t("strong",[v._v("重写 SQL")]),v._v("：把子查询改成 join、避免 "),t("code",[v._v("select *")]),v._v("、分页用 seek pagination 替代 offset 大值。")]),v._v(" "),t("li",[t("strong",[v._v("表结构/架构")]),v._v("：垂直/水平拆分、读写分离、缓存读热点。")]),v._v(" "),t("li",[t("strong",[v._v("硬件/配置")]),v._v("：调整 innodb_buffer_pool_size、IO、并发连接等。\n"),t("strong",[v._v("考察点：")]),v._v(" EXPLAIN 能力与综合调优思路。\n"),t("strong",[v._v("常见追问：")]),v._v(" 覆盖索引如何工作？（答：查询字段全部被索引覆盖，避免回表）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-如何设计高并发秒杀的库存扣减方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-如何设计高并发秒杀的库存扣减方案"}},[v._v("#")]),v._v(" Q2：如何设计高并发秒杀的库存扣减方案？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("实际可行且常用的设计：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("预热库存到 Redis")]),v._v("（内存操作快）。")]),v._v(" "),t("li",[t("strong",[v._v("使用 Redis 原子操作（Lua 脚本）做库存判断和预扣")]),v._v("，返回成功后把请求异步写入 MQ。用 Lua 能保证判断+扣减原子性，减少超卖。")]),v._v(" "),t("li",[t("strong",[v._v("消费者消费 MQ")]),v._v("，负责真正写 DB（落单）。落库时再做一次库存校验/会员幂等判断，确保最终一致。")]),v._v(" "),t("li",[t("strong",[v._v("防刷")]),v._v("：验证码、限购、用户令牌、风控规则、分布式限流器。")]),v._v(" "),t("li",[t("strong",[v._v("灰度与熔断")]),v._v("：当后端压力过大时，做降级或拒绝新请求。\n该方案兼顾了高并发下的延迟要求与最终一致性。\n"),t("strong",[v._v("考察点：")]),v._v(" 原子操作、异步落库、幂等性、防刷机制。\n"),t("strong",[v._v("常见追问：")]),v._v(" 为什么还要落库时再校验？（答：双重保障，防止 Redis 与 DB 不一致或故障导致超卖）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-redis-缓存穿透-击穿-雪崩如何处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-redis-缓存穿透-击穿-雪崩如何处理"}},[v._v("#")]),v._v(" Q3：Redis 缓存穿透/击穿/雪崩如何处理？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("典型对策：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("缓存穿透")]),v._v("：对不存在的 key 使用布隆过滤器（或本地缓存）先过滤，或对空结果缓存短时空值。")]),v._v(" "),t("li",[t("strong",[v._v("缓存击穿")]),v._v("（热点 key 突然失效）：采用互斥锁（mutex）或单机请求排队，只有一个线程去加载 DB，其它线程等待或返回旧值。也可使用提前预热和热点 key 永不过期策略。")]),v._v(" "),t("li",[t("strong",[v._v("缓存雪崩")]),v._v("（大量 key 同时过期）：为 key 加随机过期时间、均衡失效时间，或使用多级缓存 + 限流。\n"),t("strong",[v._v("考察点：")]),v._v(" 对常见缓存失效模式的识别与工程化对策。\n"),t("strong",[v._v("常见追问：")]),v._v(" 布隆过滤器误判怎么办？（答：误判率可控，若误判发生会误拒真请求，需考虑二级校验或合理设置参数）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-分布式场景如何保证缓存与数据库一致性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-分布式场景如何保证缓存与数据库一致性"}},[v._v("#")]),v._v(" Q4：分布式场景如何保证缓存与数据库一致性？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("常见策略与权衡：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Cache-Aside（旁路缓存）")]),v._v("：读先读缓存，未命中再读 DB 并写缓存；写 DB 后删除缓存（delete-after-write）。这是常用做法，但有短暂不一致窗口。")]),v._v(" "),t("li",[t("strong",[v._v("写入时先更新 DB 再删除缓存")]),v._v("：解决写-读时序问题，配合消息队列保证最终一致。")]),v._v(" "),t("li",[t("strong",[v._v("消息驱动")]),v._v("：通过 Binlog（Canal）或业务消息通知各缓存节点更新。")]),v._v(" "),t("li",[t("strong",[v._v("强一致场景")]),v._v("：必须走数据库或使用分布式锁，性能开销大。\n实务中多采用 Cache-Aside + MQ/Canal 异步同步以权衡性能与一致性。\n"),t("strong",[v._v("考察点：")]),v._v(" 最佳实践与一致性-性能权衡理解。\n"),t("strong",[v._v("常见追问：")]),v._v(" delete-after-write 为什么安全于 write-after-delete？（答：delete-after-write 在多数场景下避免了先删后写导致新读到旧数据问题，但仍需防止并发调用的时序竞争）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-redis-宕机如何保证可用性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-redis-宕机如何保证可用性"}},[v._v("#")]),v._v(" Q5：Redis 宕机如何保证可用性？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("工程化方案：主从复制 + 哨兵（sentinel）或 Redis Cluster 提供自动故障转移；同时打开持久化（AOF）以减少数据丢失。架构上做降级：读场景回落到 DB 或本地缓存；在关键场景保证幂等与补偿逻辑。事务/强一致场景需谨慎，必要时采用同步持久化。监控与自动告警、定期演练故障切换也很重要。\n"),t("strong",[v._v("考察点：")]),v._v(" HA 方案与降级思想。\n"),t("strong",[v._v("常见追问：")]),v._v(" 哨兵与 Cluster 的差别？（答：哨兵用于主从架构的监控与切换，Cluster 提供分片与可扩展性）")])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_6-分布式与高并发"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-分布式与高并发"}},[v._v("#")]),v._v(" 6. 分布式与高并发")]),v._v(" "),t("h3",{attrs:{id:"q1-如何设计分布式-id-生成器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-如何设计分布式-id-生成器"}},[v._v("#")]),v._v(" Q1：如何设计分布式 ID 生成器？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("常见方案：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Snowflake（Twitter）")]),v._v("：时间戳 + 机器 ID + 序列号，生成有序、分布式唯一 ID，低延迟，需保证机器 ID 唯一与时钟回拨处理。")]),v._v(" "),t("li",[t("strong",[v._v("数据库自增 + 范围分配")]),v._v("：适合单中心场景且数量级较小。")]),v._v(" "),t("li",[t("strong",[v._v("Redis 自增")]),v._v("：使用 "),t("code",[v._v("INCR")]),v._v("，简单但需处理单点瓶颈（用多个 Redis 或分布式 Redis）。")]),v._v(" "),t("li",[t("strong",[v._v("UUID")]),v._v("：简单但长度大，不按序。\n我倾向于 Snowflake 或有分片能力的 ID 服务（保证高可用），并在实现上处理时钟回拨与机器 ID 分配。\n"),t("strong",[v._v("考察点：")]),v._v(" 各方案利弊、对时序与性能的考虑。\n"),t("strong",[v._v("常见追问：")]),v._v(" Snowflake 时钟回拨如何处理？（答：可以等待/使用备用序列或回退方案）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-分布式锁有哪些实现-如何保证高可用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-分布式锁有哪些实现-如何保证高可用"}},[v._v("#")]),v._v(" Q2：分布式锁有哪些实现，如何保证高可用？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("实现方式：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Redis（SET NX + EXPIRE）")]),v._v("：轻量、延迟小。生产中用 RedLock（多个独立实例写入）提高安全性，并用 Lua 脚本实现释放锁的原子性。注意过期与重入问题。")]),v._v(" "),t("li",[t("strong",[v._v("ZooKeeper")]),v._v("：基于临时有序节点，强一致，适合强一致场景但复杂度高。")]),v._v(" "),t("li",[t("strong",[v._v("数据库行锁")]),v._v("：靠数据库实现，可靠但性能较差。\n保证高可用需要多个节点冗余（Redis Sentinel/Cluster、ZooKeeper quorum），并处理锁的可重入、异常持有与续命逻辑。\n"),t("strong",[v._v("考察点：")]),v._v(" 分布式一致性模型、可用性与性能的折中。\n"),t("strong",[v._v("常见追问：")]),v._v(" Redis 锁如何防止死锁？（答：加过期时间并使用锁续期策略）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-kafka-消费延迟严重-如何排查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-kafka-消费延迟严重-如何排查"}},[v._v("#")]),v._v(" Q3：Kafka 消费延迟严重，如何排查？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("排查点：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("查看 consumer lag")]),v._v("（滞后）是否累计，若是说明消费端处理慢或停滞。")]),v._v(" "),t("li",[t("strong",[v._v("检查消费端处理时间")]),v._v("（profiling），是否有阻塞 IO、同步慢操作或 GC。")]),v._v(" "),t("li",[t("strong",[v._v("检查 broker 健康")]),v._v("：页面、磁盘 IO、leader 副本分布、网络延迟、分区副本抖动。")]),v._v(" "),t("li",[t("strong",[v._v("配置优化")]),v._v("：增大消费并发（更多分区/更多消费者）、调整 "),t("code",[v._v("fetch.min.bytes")]),v._v("、"),t("code",[v._v("max.poll.records")]),v._v("、批量处理参数。")]),v._v(" "),t("li",[t("strong",[v._v("监控 & 告警")]),v._v("：使用 Kafka Manager/Confluent Control Center 或自建监控（Prometheus+Grafana）排查。\n"),t("strong",[v._v("考察点：")]),v._v(" 对消息系统监控指标和消费性能调优的了解。\n"),t("strong",[v._v("常见追问：")]),v._v(" consumer poll 卡住的常见原因？（答：长时间处理单条消息导致未及时调用 poll）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-如何在高并发下避免超卖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-如何在高并发下避免超卖"}},[v._v("#")]),v._v(" Q4：如何在高并发下避免超卖？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("减少超卖的常见做法：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("预扣库存到 Redis 并使用 Lua 脚本原子判断/扣减")]),v._v("。")]),v._v(" "),t("li",[t("strong",[v._v("在业务层做用户限流与幂等 token")]),v._v("，避免重复下单。")]),v._v(" "),t("li",[t("strong",[v._v("使用分布式锁或数据库乐观锁（version）")]),v._v(" 在落库环节再次校验并回滚。")]),v._v(" "),t("li",[t("strong",[v._v("把订单写入 MQ 异步处理，真正库存落库在消费者端做强一致检查。")]),v._v("\n综上：用缓存 + 原子操作 + 异步可靠落库的组合可以把超卖概率降到最低。\n"),t("strong",[v._v("考察点：")]),v._v(" 兼顾性能和一致性的工程方案。\n"),t("strong",[v._v("常见追问：")]),v._v(" 乐观锁的缺点？（答：高并发下重试频繁导致延迟）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-cap-定理在实际项目如何取舍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-cap-定理在实际项目如何取舍"}},[v._v("#")]),v._v(" Q5：CAP 定理在实际项目如何取舍？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("CAP 定理说分布式系统在发生分区时不能同时保证一致性（C）和可用性（A），必须取其一。实际中：")]),v._v(" "),t("ul",[t("li",[v._v("对于金融/交易类系统，通常优先保证 "),t("strong",[v._v("C")]),v._v("（牺牲部分可用性），选择 CP 系统（例如 ZooKeeper 风格）。")]),v._v(" "),t("li",[v._v("对于社交/缓存类系统，更倾向于 "),t("strong",[v._v("A")]),v._v("（牺牲部分一致性），选择 AP（例如某些 NoSQL 场景）。\n选择要依据业务对延迟/一致性的容忍度，并辅以补偿机制（最终一致性、重试、冲突解决策略）。\n"),t("strong",[v._v("考察点：")]),v._v(" 能把理论与业务场景结合说明取舍。")])])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_7-设计模式与架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-设计模式与架构"}},[v._v("#")]),v._v(" 7. 设计模式与架构")]),v._v(" "),t("h3",{attrs:{id:"q1-如何设计一个可插拔的规则引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-如何设计一个可插拔的规则引擎"}},[v._v("#")]),v._v(" Q1：如何设计一个可插拔的规则引擎？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("设计思路：")]),v._v(" "),t("ul",[t("li",[v._v("核心采用 "),t("strong",[v._v("策略模式/链式责任/规则表达式")]),v._v("，把规则以模块形式组织，支持动态加载。")]),v._v(" "),t("li",[v._v("规则可以以脚本（Groovy、JS）、DSL、或预编译类的形式存储在数据库/配置中心，运行时装载并缓存。")]),v._v(" "),t("li",[v._v("附加功能：规则版本管理、回滚、规则测试环境、并行评估引擎、规则隔离（sandbox）以防注入风险。")]),v._v(" "),t("li",[v._v("性能优化：规则编译（避免每次解释）、缓存规则查询结果、对规则执行进行限时保护。\n工程化要点是“可观测、可回滚、可审计”。\n"),t("strong",[v._v("考察点：")]),v._v(" 模块化设计、可插拔实现细节与安全考虑。\n"),t("strong",[v._v("常见追问：")]),v._v(" 为什么用脚本而不是硬编码？（答：脚本允许业务方动态调整规则，减少发布成本）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-如何用责任链模式设计订单审批流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-如何用责任链模式设计订单审批流程"}},[v._v("#")]),v._v(" Q2：如何用责任链模式设计订单审批流程？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("可以把每个审批节点封装成一个处理器（Handler），Handler 实现统一接口并链式连接：每个 Handler 判断是否通过，若通过则传递给下一个 Handler，否则返回审批失败。优点是可动态插拔审批节点、可在运行时调整流程、易做权限与审核日志记录。注意异步审批/超时处理与补偿逻辑。\n"),t("strong",[v._v("考察点：")]),v._v(" 设计模式在业务建模中的应用能力。\n"),t("strong",[v._v("常见追问：")]),v._v(" 如何对审批节点做并行处理？（答：将并行节点拆成并发执行，最后做汇总决策）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-如何把事件驱动架构-eda-落地到大项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-如何把事件驱动架构-eda-落地到大项目"}},[v._v("#")]),v._v(" Q3：如何把事件驱动架构（EDA）落地到大项目？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("实践要点：")]),v._v(" "),t("ul",[t("li",[v._v("选择合适的消息中间件（Kafka/RabbitMQ），Kafka 常用于高吞吐与持久化场景。")]),v._v(" "),t("li",[t("strong",[v._v("事件建模")]),v._v("（确定事件粒度、Schema、版本化），使用 schema registry 管控兼容性。")]),v._v(" "),t("li",[t("strong",[v._v("幂等与消费侧安全")]),v._v("：消费者需设计幂等、去重与事务（Outbox pattern）。")]),v._v(" "),t("li",[t("strong",[v._v("监控与追踪")]),v._v("：链路追踪、消费延迟监控、消息堆积报警。")]),v._v(" "),t("li",[t("strong",[v._v("演化策略")]),v._v("：事件版本升级策略、灰度回放能力。\n初始先从业务边界清晰、耦合高的场景切入（如订单/库存），逐步演化。\n"),t("strong",[v._v("考察点：")]),v._v(" EDA 的实践性考虑（schema、幂等、监控、回放）。\n"),t("strong",[v._v("常见追问：")]),v._v(" 如何回溯历史事件？（答：需要消息持久化并提供重放机制）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-单例模式在并发下如何正确实现-有坑么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-单例模式在并发下如何正确实现-有坑么"}},[v._v("#")]),v._v(" Q4：单例模式在并发下如何正确实现？有坑么？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("推荐做法：")]),v._v(" "),t("ul",[t("li",[v._v("最简单且安全的方式是使用 "),t("strong",[v._v("枚举单例")]),v._v("（Java 的枚举天生避免反序列化、反射问题）。")]),v._v(" "),t("li",[v._v("另一常用方式是 "),t("strong",[v._v("静态内部类")]),v._v("（懒加载且线程安全）。")]),v._v(" "),t("li",[v._v("可用 "),t("strong",[v._v("双重检查锁")]),v._v(" + "),t("code",[v._v("volatile")]),v._v(" 实现延迟加载，注意 "),t("code",[v._v("volatile")]),v._v(" 防止指令重排序。\n陷阱包括反射/序列化破坏单例、类加载器隔离导致单例多实例等。\n"),t("strong",[v._v("考察点：")]),v._v(" 并发下资源初始化与 Java 特性。\n"),t("strong",[v._v("常见追问：")]),v._v(" 为什么枚举单例最安全？（答：JVM 保证枚举只会被实例化一次，并防止反射创建新的实例）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-工厂模式如何扩展第三方支付接入"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-工厂模式如何扩展第三方支付接入"}},[v._v("#")]),v._v(" Q5：工厂模式如何扩展第三方支付接入？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("采用抽象工厂或策略模式：定义统一的支付接口（创建订单、签名、回调验证），每个第三方支付实现该接口并注册到工厂中；工厂根据配置或参数返回对应实现。好处是新增支付渠道只需实现接口并配置即可，降低耦合。再加上配置化加载、熔断和限流等治理逻辑，最终构成可扩展的支付接入平台。\n"),t("strong",[v._v("考察点：")]),v._v(" 可扩展性、接口设计、注册/发现机制。\n"),t("strong",[v._v("常见追问：")]),v._v(" 如何做支付幂等？（答：订单号+幂等表/唯一索引或幂等 key）")])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_8-项目实战与问题排查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-项目实战与问题排查"}},[v._v("#")]),v._v(" 8. 项目实战与问题排查")]),v._v(" "),t("h3",{attrs:{id:"q1-线上接口偶发超时-你如何定位"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-线上接口偶发超时-你如何定位"}},[v._v("#")]),v._v(" Q1：线上接口偶发超时，你如何定位？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("标准排查流程：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("查看调用链")]),v._v("：用 APM/调用链（SkyWalking/Zipkin）定位是自己服务慢还是依赖慢。")]),v._v(" "),t("li",[t("strong",[v._v("抓取线程快照")]),v._v("："),t("code",[v._v("jstack")]),v._v(" 看是否有线程阻塞、死锁或大量 GC。")]),v._v(" "),t("li",[t("strong",[v._v("查看 DB & 外部依赖")]),v._v("：检查慢 SQL、外呼超时。")]),v._v(" "),t("li",[t("strong",[v._v("网络监控")]),v._v("：排查网络丢包/延迟，检查网关与 LB。")]),v._v(" "),t("li",[t("strong",[v._v("回放/复现")]),v._v("：在预发布或压力环境复现问题并定位。\n归根结底是“先定位慢链路，再深挖具体问题”。定位后讲清楚恢复与后续预防措施（限流、监控、熔断）。\n"),t("strong",[v._v("考察点：")]),v._v(" 系统化问题定位能力与沟通恢复方案。\n"),t("strong",[v._v("常见追问：")]),v._v(" 遇到死锁怎么办？（答：抓取线程堆栈，找到锁依赖链并调整加锁顺序或加超时）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-某服务-cpu-占-100-如何排查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-某服务-cpu-占-100-如何排查"}},[v._v("#")]),v._v(" Q2：某服务 CPU 占 100%，如何排查？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("ol",[t("li",[t("strong",[v._v("裸机/容器监控")]),v._v("：用 "),t("code",[v._v("top")]),v._v(" 或容器监控看是哪个进程/线程。")]),v._v(" "),t("li",[t("strong",[v._v("jstack")]),v._v("：抓取线程堆栈，看是否在某个热点方法或死循环。")]),v._v(" "),t("li",[t("strong",[v._v("CPU profiler")]),v._v("（async-profiler）做采样分析，找出热点方法和系统调用。")]),v._v(" "),t("li",[t("strong",[v._v("检查 GC")]),v._v("：高 CPU 也可能是 GC 消耗（查看 GC 日志）。")]),v._v(" "),t("li",[t("strong",[v._v("业务回归")]),v._v("：判断是否近期部署变更引入性能回退，回滚验证。\n"),t("strong",[v._v("考察点：")]),v._v(" 性能分析工具的熟练度与快速定位能力。\n"),t("strong",[v._v("常见追问：")]),v._v(" async-profiler 用法简述？（答：采样模式低开销，能定位 Java 层热点和 JNI/syscall）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-线上死锁如何处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-线上死锁如何处理"}},[v._v("#")]),v._v(" Q3：线上死锁如何处理？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("做法：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("抓取多次线程堆栈（jstack）")]),v._v(" 确定死锁是否持续。")]),v._v(" "),t("li",[t("strong",[v._v("分析锁持有者与等待者")]),v._v("，找到循环依赖链（jstack 会提示死锁信息）。")]),v._v(" "),t("li",[t("strong",[v._v("临时恢复")]),v._v("：如果能快速确定单点锁可手工释放（慎用），或者重启受影响服务实例做短期恢复。")]),v._v(" "),t("li",[t("strong",[v._v("根本修复")]),v._v("：统一加锁顺序、缩小锁粒度、使用 tryLock 超时处理或改为无锁算法。")]),v._v(" "),t("li",[t("strong",[v._v("回顾与防范")]),v._v("：补充单元/集成测试模拟并发场景，避免再次发生。\n"),t("strong",[v._v("考察点：")]),v._v(" 从临时恢复到根本解决与防范的完整流程。\n"),t("strong",[v._v("常见追问：")]),v._v(" 如果无法重启怎么办？（答：尝试定位具体线程并做探测性 dump，若能释放锁再恢复；否则按 SLA 评估重启）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-第三方接口超时不可用时如何保证系统可用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-第三方接口超时不可用时如何保证系统可用"}},[v._v("#")]),v._v(" Q4：第三方接口超时不可用时如何保证系统可用？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("方案：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("熔断降级")]),v._v("：对该依赖启用熔断器，短时间内失败则快速返回默认值或友好错误。")]),v._v(" "),t("li",[t("strong",[v._v("缓存与本地降级")]),v._v("：对重要数据使用缓存或本地备份数据，保证读服务可用。")]),v._v(" "),t("li",[t("strong",[v._v("重试策略")]),v._v("：结合指数退避与幂等保证，避免短时大量重试造成雪崩。")]),v._v(" "),t("li",[t("strong",[v._v("限流/隔离")]),v._v("：把调用隔离到独立线程池或队列，避免全局资源被耗尽。\n同时通知运维/第三方并在恢复后做补偿（如重试落单、补偿数据）。\n"),t("strong",[v._v("考察点：")]),v._v(" 设计容错的工程能力与业务连续性保证。\n"),t("strong",[v._v("常见追问：")]),v._v(" 降级返回什么内容比较合理？（答：业务友好提示或缓存旧数据，视场景而定）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-描述一次你定位并解决棘手-bug-的经历-star"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-描述一次你定位并解决棘手-bug-的经历-star"}},[v._v("#")]),v._v(" Q5：描述一次你定位并解决棘手 bug 的经历（STAR）")]),v._v(" "),t("p",[t("strong",[v._v("参考回答（示例话术）：")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("Situation（背景）")]),v._v("：我们线上在高并发场景下出现 intermittent 下单失败，日志无明显错误。\n"),t("strong",[v._v("Task（任务）")]),v._v("：定位根因并保证业务恢复。\n"),t("strong",[v._v("Action（行动）")]),v._v("：我先通过调用链发现下单关键路径在库存扣减处延迟，再抓取线程快照发现大量等待获取分布式锁。随后我在测试环境复现请求并用 profile 跟踪，发现锁粒度过粗，导致大量线程阻塞。修复方案是把大事务拆小、把跨服务同步调用改为异步 MQ，并把 Redis 原子扣减逻辑提前到前置缓存里，最后在 DB 落库时校验。上线后问题消失。\n"),t("strong",[v._v("Result（结果）")]),v._v("：成功把下单成功率从 95% 提升到 99.9%，并减少了 80% 的请求延迟。事后我们加了压测和报警，避免回归。\n"),t("strong",[v._v("考察点：")]),v._v(" 用 STAR 展示问题定位能力、技术手段和复盘改进。")])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_9-网络与安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-网络与安全"}},[v._v("#")]),v._v(" 9. 网络与安全")]),v._v(" "),t("h3",{attrs:{id:"q1-tcp-三次握手与四次挥手怎么解释-面试话术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-tcp-三次握手与四次挥手怎么解释-面试话术"}},[v._v("#")]),v._v(" Q1：TCP 三次握手与四次挥手怎么解释（面试话术）？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("三次握手")]),v._v("：客户端发送 SYN 到服务端（请求建立连接），服务端回复 SYN+ACK（同意并确认），客户端再发 ACK（确认），连接建立后双方进入数据传输阶段。\n"),t("strong",[v._v("四次挥手")]),v._v("：主动关闭一方发送 FIN（表示数据发送完），对方 ACK（确认），对方再发送 FIN（表示其数据也发送完），主动方 ACK（确认），连接彻底关闭。四次是因为双方关闭和确认需要双方分别确认各自的数据发送完成。\n"),t("strong",[v._v("考察点：")]),v._v(" TCP 状态机基础、连接与关闭语义。\n"),t("strong",[v._v("常见追问：")]),v._v(" 为什么不是两次握手？（答：需要确认双方都能接收和发送）")])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-接口遭刷流量-ddos-高频-如何防护"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-接口遭刷流量-ddos-高频-如何防护"}},[v._v("#")]),v._v(" Q2：接口遭刷流量（DDoS/高频）如何防护？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("防护措施：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("边界防护")]),v._v("：CDN/云防火墙做源头过滤与速率限制。")]),v._v(" "),t("li",[t("strong",[v._v("网关限流")]),v._v("：在网关/负载均衡层做令牌桶限流、IP 黑名单、验证码。")]),v._v(" "),t("li",[t("strong",[v._v("应用层防护")]),v._v("：使用速率限制策略（按 IP、按用户、按接口）和熔断。")]),v._v(" "),t("li",[t("strong",[v._v("异步降级")]),v._v("：对非关键功能快速返回降级结果。")]),v._v(" "),t("li",[t("strong",[v._v("行为分析")]),v._v("：检测异常行为（短时间大量请求、异常 User-Agent），结合 WAF 做精确拦截。\n"),t("strong",[v._v("考察点：")]),v._v(" 多层防护策略与工程落地。\n"),t("strong",[v._v("常见追问：")]),v._v(" 如何区分合法高并发与攻击？（答：结合用户身份、行为模式、地理和历史访问特征）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-https-原理与-ssl-握手失败如何排查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-https-原理与-ssl-握手失败如何排查"}},[v._v("#")]),v._v(" Q3：HTTPS 原理与 SSL 握手失败如何排查？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("HTTPS（TLS）是在 TCP 上层做的加密通信：客户端发起 TLS 握手，协商加密套件、校验证书并建立对称密钥，然后用对称密钥加密后续数据。排查 SSL 握手失败常用步骤：")]),v._v(" "),t("ul",[t("li",[v._v("检查证书有效期、链路完整性与根证书是否被信任。")]),v._v(" "),t("li",[v._v("用 "),t("code",[v._v("openssl s_client")]),v._v(" 检测握手日志（查看协议、证书和错误信息）。")]),v._v(" "),t("li",[v._v("查看服务器是否只支持某些过时/不兼容的加密套件（需兼容客户端）。")]),v._v(" "),t("li",[v._v("检查 SNI 配置、证书链是否完整、是否有中间证书丢失。\n"),t("strong",[v._v("考察点：")]),v._v(" TLS 工作原理与基础排错能力。\n"),t("strong",[v._v("常见追问：")]),v._v(" 什么是中间证书？（答：CA 证书链中的中间签发证书，缺失会导致部分客户端不信任）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-微服务间如何保证接口安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-微服务间如何保证接口安全"}},[v._v("#")]),v._v(" Q4：微服务间如何保证接口安全？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("常见做法：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("认证与授权")]),v._v("：使用 OAuth2/JWT 做服务间授权，API Gateway 对外统一鉴权。")]),v._v(" "),t("li",[t("strong",[v._v("传输安全")]),v._v("：启用 mTLS（双向 TLS）保证服务间通信加密与双方认证。")]),v._v(" "),t("li",[t("strong",[v._v("最小权限")]),v._v("：细粒度权限控制和 RBAC。在敏感操作上做鉴权审计。")]),v._v(" "),t("li",[t("strong",[v._v("治理")]),v._v("：限流、熔断、访问白名单与安全审计日志。\n"),t("strong",[v._v("考察点：")]),v._v(" API 安全策略与实践。\n"),t("strong",[v._v("常见追问：")]),v._v(" JWT 的短板是什么？（答：Token 无法即时撤销，需配合黑名单或短过期+刷新机制）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-如何防止-sql-注入-xss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-如何防止-sql-注入-xss"}},[v._v("#")]),v._v(" Q5：如何防止 SQL 注入 / XSS？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("防护要点：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("SQL 注入")]),v._v("：使用预编译语句（PreparedStatement）、ORM 的参数化查询、严格输入校验与最小权限数据库账号。避免拼接 SQL。")]),v._v(" "),t("li",[t("strong",[v._v("XSS")]),v._v("：对输入进行白名单校验，对输出做 HTML 转义（输出编码），并配置 CSP（Content-Security-Policy）。对富文本使用专门的白名单过滤器（如 OWASP Java HTML Sanitizer）。\n同时做安全测试（SAST/DAST）并把安全纳入 CI/CD 流程。\n"),t("strong",[v._v("考察点：")]),v._v(" OWASP 常见安全风险与工程化防护措施。\n"),t("strong",[v._v("常见追问：")]),v._v(" 为什么要用 PreparedStatement？（答：参数化查询把输入作为数据处理，避免被当成 SQL 语法执行）")])])]),v._v(" "),t("hr"),v._v(" "),t("h2",{attrs:{id:"_10-开放性与综合场景题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-开放性与综合场景题"}},[v._v("#")]),v._v(" 10. 开放性与综合场景题")]),v._v(" "),t("h3",{attrs:{id:"q1-从零设计一个秒杀系统-可直接面试话术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q1-从零设计一个秒杀系统-可直接面试话术"}},[v._v("#")]),v._v(" Q1：从零设计一个秒杀系统（可直接面试话术）")]),v._v(" "),t("p",[t("strong",[v._v("参考回答（分步骤展示）：")])]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("高层思路")]),v._v("：要兼顾高并发吞吐、低延迟、可用性、最终一致性与防刷。设计分为前端保护层、缓存层、异步队列与落库保证四个部分：")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("入口限流/防刷")]),v._v("：在 CDN/网关层做全量限流、用户级限流、验证码或签名机制（避免机器人）。")]),v._v(" "),t("li",[t("strong",[v._v("缓存预热")]),v._v("：在秒杀开始前把库存预热到 Redis，避免直接打 DB。")]),v._v(" "),t("li",[t("strong",[v._v("原子扣减")]),v._v("：使用 Redis Lua 脚本做库存判断与预扣，返回 token 给用户。Lua 保证判断与扣减原子性。")]),v._v(" "),t("li",[t("strong",[v._v("异步下单")]),v._v("：将下单请求放入 MQ，消费者异步落库并做最后库存确认与幂等处理（使用唯一索引或幂等表）。")]),v._v(" "),t("li",[t("strong",[v._v("最终一致性")]),v._v("：定期对库存做校验/对账，出现差异做补偿。")]),v._v(" "),t("li",[t("strong",[v._v("监控与回退")]),v._v("：监控队列长度、消费延迟、错误率，必要时快速降级或关闭秒杀。\n"),t("strong",[v._v("关键保障")]),v._v("：Redis 原子操作避免大部分超卖，MQ 异步处理保证 DB 不被瞬时流量打垮，幂等设计保证消息重试安全。\n"),t("strong",[v._v("实现细节与注意事项")]),v._v("：防刷、去重、用户限购、日志埋点、全链路追踪、回放与补偿。\n"),t("strong",[v._v("考察点：")]),v._v(" 从架构到细节的完整性以及对一致性/性能的权衡。")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q2-如何将系统从-1-万-tps-扩展到-10-万-tps-面试话术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q2-如何将系统从-1-万-tps-扩展到-10-万-tps-面试话术"}},[v._v("#")]),v._v(" Q2：如何将系统从 1 万 TPS 扩展到 10 万 TPS？（面试话术）")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("扩容分层次：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("无状态服务水平扩展")]),v._v("：保证服务无状态或把状态外置（Redis/DB），通过负载均衡扩容实例。")]),v._v(" "),t("li",[t("strong",[v._v("拆分瓶颈")]),v._v("：使用异步 MQ 解耦、增加分区与消费者并行度、把 CPU 密集型部分优化或下沉到批处理。")]),v._v(" "),t("li",[t("strong",[v._v("数据层分库分表")]),v._v("：水平拆分数据库与读写分离，热点表做缓存或 CQRS。")]),v._v(" "),t("li",[t("strong",[v._v("缓存与 CDN")]),v._v("：尽可能把读请求命中缓存，减少数据库压力。")]),v._v(" "),t("li",[t("strong",[v._v("连接池/网络优化")]),v._v("：减少同步阻塞、保持长连接并优化序列化（例如 Protobuf）。")]),v._v(" "),t("li",[t("strong",[v._v("垂直/水平分割业务")]),v._v("：拆分单体服务到微服务，按流量和业务分片扩容。\n关键是定位并解决系统瓶颈（CPU/IO/锁/GC/网络），并做好灰度、容量测试与回滚方案。\n"),t("strong",[v._v("考察点：")]),v._v(" 扩展策略与性能瓶颈识别能力。\n"),t("strong",[v._v("常见追问：")]),v._v(" 单点扩展中最容易忽视的问题？（答：数据库连接数、网络带宽与中间件并发限制）")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q3-双-11-类型大促前如何准备-面试话术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q3-双-11-类型大促前如何准备-面试话术"}},[v._v("#")]),v._v(" Q3：双 11 类型大促前如何准备（面试话术）")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("主要工作：容量与容错准备、性能测试、依赖切换与降级策略、运维预案。具体：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("压测与容量评估")]),v._v("：按预估流量做分层压测（全链路），找并修复瓶颈。")]),v._v(" "),t("li",[t("strong",[v._v("预热与缓存")]),v._v("：预先把热数据加载到缓存/CDN，避免冷启动。")]),v._v(" "),t("li",[t("strong",[v._v("配置开关与灰度")]),v._v("：支持快速关闭非关键功能，分步骤放量。")]),v._v(" "),t("li",[t("strong",[v._v("降级与熔断策略")]),v._v("：为非核心服务建立降级逻辑与回退数据。")]),v._v(" "),t("li",[t("strong",[v._v("演练故障")]),v._v("：演练 DB/Redis/消息队列故障切换、回滚流程与补偿机制。")]),v._v(" "),t("li",[t("strong",[v._v("监控与报警")]),v._v("：关键指标（QPS/RT/错误率/队列长度/DB slow）必须有实时告警与自动化处理脚本。")]),v._v(" "),t("li",[t("strong",[v._v("人力准备")]),v._v("：运维、SRE、后端保障团队待命并有明确责任分工。\n"),t("strong",[v._v("考察点：")]),v._v(" 大促级别运维、压测与应急机制的成熟度。")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q4-如何设计一个高可用的分布式日志收集系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q4-如何设计一个高可用的分布式日志收集系统"}},[v._v("#")]),v._v(" Q4：如何设计一个高可用的分布式日志收集系统？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("常见架构：日志采集 -> Fluentd/Logstash -> Kafka（缓冲）-> 消费者（索引到 Elasticsearch/Hadoop）-> 可视化（Kibana）。关键设计点：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("高可用收集")]),v._v("：采集层做本地缓冲和批量发送。")]),v._v(" "),t("li",[t("strong",[v._v("可靠缓冲")]),v._v("：Kafka 做持久化缓冲，避免短时峰值丢失。")]),v._v(" "),t("li",[t("strong",[v._v("索引与归档")]),v._v("：ES 用于快速检索，历史日志落到冷存储（HDFS）做归档。")]),v._v(" "),t("li",[t("strong",[v._v("结构化与规范")]),v._v("：统一日志格式（JSON + schema），便于解析与搜索。")]),v._v(" "),t("li",[t("strong",[v._v("管控 & 限流")]),v._v("：对日志流量做采样、限流以保护下游系统。")]),v._v(" "),t("li",[t("strong",[v._v("权限与审计")]),v._v("：管理访问控制和审计日志，保证安全合规。\n"),t("strong",[v._v("考察点：")]),v._v(" 可观测性与大数据流处理设计能力。")])])]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"q5-如何实现异地多活-active-active-系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q5-如何实现异地多活-active-active-系统"}},[v._v("#")]),v._v(" Q5：如何实现异地多活（Active-Active）系统？")]),v._v(" "),t("p",[t("strong",[v._v("参考回答：")])]),v._v(" "),t("blockquote",[t("p",[v._v("异地多活需要解决数据同步、冲突解决、全局流量路由与延迟问题：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("流量层")]),v._v("：采用全球负载均衡（DNS + Anycast + GSLB），根据用户地理/延迟路由到最近活跃数据中心。")]),v._v(" "),t("li",[t("strong",[v._v("数据同步")]),v._v("：采用异步双向复制（跨 DC），并设计冲突解决策略（CRDT、业务级冲突检测或基于时间戳的合并）。")]),v._v(" "),t("li",[t("strong",[v._v("一致性模型")]),v._v("：多数场景选择最终一致性，强一致场景需走中心化主写或 Paxos/Raft 跨域协议（复杂且性能差）。")]),v._v(" "),t("li",[t("strong",[v._v("回退与演练")]),v._v("：必须有故障切换与回滚机制，以及跨 DC 的演练。")]),v._v(" "),t("li",[t("strong",[v._v("监控 & 延迟容忍")]),v._v("：关注跨域延迟与队列积压，设计降级逻辑。\n异地多活适用于对可用性要求极高的业务，但实现复杂、运维成本高，要按成本收益评估。\n"),t("strong",[v._v("考察点：")]),v._v(" 分布式系统的深层次挑战与工程化能力。")])])]),v._v(" "),t("h3",{attrs:{id:"如果线上一个服务无法对外提供请求-但是服务没有挂-怎么排查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果线上一个服务无法对外提供请求-但是服务没有挂-怎么排查"}},[v._v("#")]),v._v(" 如果线上一个服务无法对外提供请求，但是服务没有挂，怎么排查")]),v._v(" "),t("p",[v._v("当线上服务无法对外提供请求，但服务本身没有挂（即服务仍然在运行），你可以按照以下步骤进行排查：")]),v._v(" "),t("ol",[t("li",[t("p",[t("strong",[v._v("检查服务日志")])]),v._v(" "),t("p",[v._v("首先检查服务的日志文件。日志文件通常包含关于服务运行状态、请求处理情况和错误信息的详细记录。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("访问日志")]),v._v(": 检查是否有请求到达服务。如果没有请求到达，问题可能在于请求路由或网络。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("错误日志")]),v._v(": 查看是否有错误日志记录。错误日志可以帮助你识别代码中的异常情况或第三方服务的问题。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("应用日志")]),v._v(": 检查是否有异常或警告信息。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("检查网络和防火墙设置")])]),v._v(" "),t("p",[v._v("服务无法对外提供请求可能是由于网络问题或防火墙配置导致的。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("网络连接")]),v._v(": 使用 "),t("code",[v._v("ping")]),v._v(" 或 "),t("code",[v._v("traceroute")]),v._v(" 命令检查服务所在机器与外部网络的连接情况。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("防火墙设置")]),v._v(": 确保防火墙允许外部请求访问服务的端口。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("检查负载均衡和反向代理配置")])]),v._v(" "),t("p",[v._v("如果服务是通过负载均衡器或反向代理进行访问的，检查这些组件的配置。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("负载均衡器")]),v._v(": 确保负载均衡器正确地将请求转发到服务实例。检查负载均衡器的健康检查配置。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("反向代理")]),v._v(": 确保反向代理配置正确，能够将请求转发到服务。")])])])]),v._v(" "),t("li",[t("p",[v._v("检查服务依赖")]),v._v(" "),t("p",[v._v("服务可能依赖其他服务、数据库或外部 API。如果这些依赖服务不可用，可能导致服务无法正常提供请求。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("依赖服务健康状况")]),v._v(": 检查依赖服务的运行状态和健康状况。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("数据库连接")]),v._v(": 检查服务是否能够连接到数据库，并且数据库是否正常运行。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("外部 API")]),v._v(": 检查外部 API 是否可用。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("检查线程和连接池")])]),v._v(" "),t("p",[v._v("服务无法处理请求可能是由于线程池或连接池耗尽。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("线程池")]),v._v(": 检查服务的线程池配置和使用情况，确保没有线程泄漏或线程池耗尽的情况。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("连接池")]),v._v(": 检查数据库连接池或 HTTP 连接池的使用情况，确保没有连接泄漏或连接池耗尽的情况。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("检查内存和 CPU 使用情况")])]),v._v(" "),t("p",[v._v("内存不足或 CPU 过载可能导致服务无法处理请求。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("内存使用情况")]),v._v(": 使用 "),t("code",[v._v("jstat")]),v._v("、"),t("code",[v._v("jmap")]),v._v(" 等工具检查 JVM 的堆内存使用情况。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("CPU 使用情况")]),v._v(": 使用 "),t("code",[v._v("top")]),v._v(" 或 "),t("code",[v._v("htop")]),v._v(" 命令检查服务所在机器的 CPU 使用情况。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("检查应用程序代码")])]),v._v(" "),t("p",[v._v("如果以上检查未发现问题，可能需要深入检查应用程序代码。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("死锁")]),v._v(": 检查代码是否存在线程死锁的情况。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("高延迟操作")]),v._v(": 检查代码是否有高延迟操作，导致请求处理超时。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("异常处理")]),v._v(": 检查代码中的异常处理逻辑，确保不会因未捕获的异常导致请求处理失败。")])])])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("检查监控和报警系统")])]),v._v(" "),t("p",[v._v("使用监控工具（如 Prometheus、Grafana）和报警系统检查服务的运行状态。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("监控指标")]),v._v(": 查看服务的关键性能指标，如请求率、错误率、响应时间、CPU 使用率、内存使用情况等。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("报警信息")]),v._v(": 检查是否有任何报警信息提示服务异常。")])])])])]),v._v(" "),t("h3",{attrs:{id:"你了解-java-应用开发中的注入攻击吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#你了解-java-应用开发中的注入攻击吗"}},[v._v("#")]),v._v(" 你了解 Java 应用开发中的注入攻击吗？")]),v._v(" "),t("p",[v._v("注入式（Inject）攻击是一类非常常见的攻击方式，其基本特征是程序允许攻击者将不可信的动态内容注入到程序中，并将其执行，这就可能完全改变最初预计的执行过程，产生恶意效果。")]),v._v(" "),t("p",[v._v("下面是几种主要的注入式攻击途径，原则上提供动态执行能力的语言特性，都需要提防发生注入攻击的可能。")]),v._v(" "),t("p",[v._v("首先，就是最常见的 SQL 注入攻击。一个典型的场景就是 Web 系统的用户登录功能，根据用户输入的用户名和密码，我们需要去后端数据库核实信息。")]),v._v(" "),t("p",[v._v("假设应用逻辑是，后端程序利用界面输入动态生成类似下面的 SQL，然后让 JDBC 执行。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("Select * from use_info where username = “input_usr_name” and password = “input_pwd”\n")])])]),t("p",[v._v("但是，如果我输入的 input_pwd 是类似下面的文本，")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("“ or “”=”\n")])])]),t("p",[v._v("那么，拼接出的 SQL 字符串就变成了下面的条件，OR 的存在导致输入什么名字都是复合条件的。")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("Select * from use_info where username = “input_usr_name” and password = “” or “” = “”\n")])])]),t("p",[v._v("这里只是举个简单的例子，它是利用了期望输入和可能输入之间的偏差。上面例子中，期望用户输入一个数值，但实际输入的则是 SQL 语句片段。类似场景可以利用注入的不同 SQL 语句，进行各种不同目的的攻击，甚至还可以加上“;delete xxx”之类语句，如果数据库权限控制不合理，攻击效果就可能是灾难性的。")]),v._v(" "),t("p",[v._v("第二，操作系统命令注入。Java 语言提供了类似 Runtime.exec(…) 的 API，可以用来执行特定命令，假设我们构建了一个应用，以输入文本作为参数，执行下面的命令：")]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("ls –la input_file_name\n")])])]),t("p",[v._v("但是如果用户输入是 “input_file_name;rm –rf /*”，这就有可能出现问题了。当然，这只是个举例，Java 标准类库本身进行了非常多的改进，所以类似这种编程错误，未必可以真的完成攻击，但其反映的一类场景是真实存在的。")]),v._v(" "),t("p",[v._v("第三，XML 注入攻击。Java 核心类库提供了全面的 XML 处理、转换等各种 API，而 XML 自身是可以包含动态内容的，例如 XPATH，如果使用不当，可能导致访问恶意内容。")]),v._v(" "),t("p",[v._v("还有类似 LDAP 等允许动态内容的协议，都是可能利用特定命令，构造注入式攻击的，包括 XSS（Cross-site Scripting）攻击，虽然并不和 Java 直接相关，但也可能在 JSP 等动态页面中发生。")]),v._v(" "),t("h3",{attrs:{id:"日志分析工具用了哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#日志分析工具用了哪些"}},[v._v("#")]),v._v(" 日志分析工具用了哪些？")]),v._v(" "),t("p",[v._v("在面试中被问到日志分析工具时，可以从以下几个方面进行回答：所用的工具、它们的主要功能、你是如何使用这些工具的，以及它们在你的项目中带来的具体好处。以下是一些常用的日志分析工具及其特点：")]),v._v(" "),t("p",[t("strong",[v._v("常用日志分析工具")])]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("ELK Stack (Elasticsearch, Logstash, Kibana)")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("Elasticsearch")]),v._v(": 一个强大的搜索引擎，用于存储和查询日志数据。")]),v._v(" "),t("li",[t("strong",[v._v("Logstash")]),v._v(": 一个数据处理管道工具，用于收集、解析和存储日志数据。")]),v._v(" "),t("li",[t("strong",[v._v("Kibana")]),v._v(": 一个数据可视化工具，用于展示和分析 Elasticsearch 中的数据。")]),v._v(" "),t("li",[t("strong",[v._v("使用场景")]),v._v(": 大量日志数据的集中管理和实时分析。")]),v._v(" "),t("li",[t("strong",[v._v("个人经验")]),v._v(": 可以提到如何设置 Logstash 管道、创建 Kibana 仪表盘来监控特定的日志模式或异常。")])])]),v._v(" "),t("li",[t("strong",[v._v("Graylog")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("特点")]),v._v(": 基于 Elasticsearch 的日志管理工具，具有强大的日志聚合、搜索和分析功能。")]),v._v(" "),t("li",[t("strong",[v._v("使用场景")]),v._v(": 实时日志监控和警报。")]),v._v(" "),t("li",[t("strong",[v._v("个人经验")]),v._v(": 可以提到如何配置 Graylog 采集日志、设置警报规则，以及如何利用 Graylog 的搜索功能进行故障排除。")])])]),v._v(" "),t("li",[t("strong",[v._v("Splunk")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("特点")]),v._v(": 商业化的日志管理和分析工具，提供强大的搜索、监控和可视化功能。")]),v._v(" "),t("li",[t("strong",[v._v("使用场景")]),v._v(": 复杂的企业级日志分析和安全监控。")]),v._v(" "),t("li",[t("strong",[v._v("个人经验")]),v._v(": 可以提到如何利用 Splunk 进行实时日志分析、创建报告和仪表盘，以及如何使用 Splunk 的机器学习功能进行异常检测。")])])]),v._v(" "),t("li",[t("strong",[v._v("Fluentd")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("特点")]),v._v(": 一个开源的数据收集器，用于统一日志数据。")]),v._v(" "),t("li",[t("strong",[v._v("使用场景")]),v._v(": 日志数据的收集和转发。")]),v._v(" "),t("li",[t("strong",[v._v("个人经验")]),v._v(": 可以提到如何配置 Fluentd 插件、收集和转发日志到不同的存储系统（如 Elasticsearch、MongoDB）。")])])]),v._v(" "),t("li",[t("strong",[v._v("Loggly")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("特点")]),v._v(": 基于云的日志管理和分析服务，提供实时日志监控和警报。")]),v._v(" "),t("li",[t("strong",[v._v("使用场景")]),v._v(": 云环境中的日志管理。")]),v._v(" "),t("li",[t("strong",[v._v("个人经验")]),v._v(": 可以提到如何将应用日志发送到 Loggly、配置日志搜索和警报，以及利用 Loggly 的仪表盘进行日志可视化。")])])]),v._v(" "),t("li",[t("strong",[v._v("Prometheus 和 Grafana")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("特点")]),v._v(": Prometheus 用于监控和告警，Grafana 用于数据可视化。虽然主要用于度量和监控，但也可以用于日志分析。")]),v._v(" "),t("li",[t("strong",[v._v("使用场景")]),v._v(": 系统和应用的监控。")]),v._v(" "),t("li",[t("strong",[v._v("个人经验")]),v._v(": 可以提到如何配置 Prometheus 采集日志指标、设置警报规则，以及如何利用 Grafana 创建可视化面板。")])])])]),v._v(" "),t("p",[v._v("我们使用 ELK Stack 来集中管理和分析日志数据。通过 Logstash 我们收集来自不同服务的日志，并将其存储在 Elasticsearch 中，然后使用 Kibana 创建了多个仪表盘来监控系统的健康状况和性能")])])}),[],!1,null,null,null);_.default=s.exports}}]);