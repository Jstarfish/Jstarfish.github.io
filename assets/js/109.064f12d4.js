(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{601:function(_,v,t){"use strict";t.r(v);var r=t(2),s=Object(r.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h3",{attrs:{id:"什么是缓存模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存模式"}},[_._v("#")]),_._v(" "),t("strong",[_._v("什么是缓存模式？")])]),_._v(" "),t("p",[_._v("缓存模式是指在系统中如何设计和实现缓存机制，用以快速存取数据并减轻后端数据存储的负载。Redis 提供了灵活多样的缓存策略，常见模式包括：")]),_._v(" "),t("ol",[t("li",[t("strong",[_._v("直写模式（Write Through）")])]),_._v(" "),t("li",[t("strong",[_._v("回写模式（Write Back）")])]),_._v(" "),t("li",[t("strong",[_._v("旁路缓存模式（Cache Aside）")])]),_._v(" "),t("li",[t("strong",[_._v("只缓存模式（Read Through）")])])]),_._v(" "),t("p",[_._v("通过合理选择和优化这些模式，可以满足不同业务场景对性能、数据一致性和可用性的需求。")]),_._v(" "),t("hr"),_._v(" "),t("h3",{attrs:{id:"redis-缓存模式详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-缓存模式详解"}},[_._v("#")]),_._v(" "),t("strong",[_._v("Redis 缓存模式详解")])]),_._v(" "),t("h4",{attrs:{id:"_1-cache-aside-旁路缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-cache-aside-旁路缓存"}},[_._v("#")]),_._v(" "),t("strong",[_._v("1. Cache Aside（旁路缓存）")])]),_._v(" "),t("p",[_._v("Cache Aside 模式又称为 "),t("strong",[_._v("Lazy Loading")]),_._v("，是使用最广泛的缓存模式之一，通常由业务代码显式管理缓存和数据库，核心思想是：")]),_._v(" "),t("ul",[t("li",[_._v("数据从数据库加载到缓存中，缓存作为数据库的一个“旁路”。")]),_._v(" "),t("li",[_._v("应用程序负责读取缓存，缓存未命中时再从数据库读取并更新缓存。")])]),_._v(" "),t("p",[t("strong",[_._v("读请求")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("先从缓存中读取数据；")]),_._v(" "),t("li",[_._v("如果缓存中没有数据（缓存未命中），从数据库中获取数据，将数据写入缓存，返回给客户端。")])]),_._v(" "),t("p",[t("strong",[_._v("写请求")]),_._v("：")]),_._v(" "),t("ul",[t("li",[_._v("数据写入数据库后，将缓存中的数据清除或更新。")])]),_._v(" "),t("p",[t("strong",[_._v("适用场景：")])]),_._v(" "),t("ul",[t("li",[_._v("数据更新较少但读取频率较高的场景，例如商品详情、热搜榜单。")]),_._v(" "),t("li",[_._v("对数据一致性要求不严格的系统。")])]),_._v(" "),t("p",[t("strong",[_._v("优缺点：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("优点")]),_._v("：简单易用，缓存与数据库解耦。")]),_._v(" "),t("li",[t("strong",[_._v("缺点")]),_._v("：缓存预热需要时间，容易出现缓存击穿问题。")])]),_._v(" "),t("h4",{attrs:{id:"_2-write-through-直写模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-write-through-直写模式"}},[_._v("#")]),_._v(" 2. Write Through（直写模式）")]),_._v(" "),t("p",[_._v("在直写模式中，应用程序的所有写操作都会同时更新缓存和数据库：")]),_._v(" "),t("ul",[t("li",[_._v("数据写入数据库的同时同步写入缓存。")])]),_._v(" "),t("p",[t("strong",[_._v("工作流程：")])]),_._v(" "),t("ol",[t("li",[_._v("应用将数据同时写入 Redis 和数据库。")]),_._v(" "),t("li",[_._v("读取时直接从 Redis 获取数据。")])]),_._v(" "),t("p",[t("strong",[_._v("适用场景：")])]),_._v(" "),t("ul",[t("li",[_._v("需要缓存和数据库一致性非常高的场景，例如账户余额、订单状态等敏感数据。")])]),_._v(" "),t("p",[t("strong",[_._v("优缺点：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("优点")]),_._v("：一致性高，数据实时同步。")]),_._v(" "),t("li",[t("strong",[_._v("缺点")]),_._v("：写入速度较慢，因为每次写操作都需要更新两处存储。")])]),_._v(" "),t("h4",{attrs:{id:"_3-write-back-回写模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-write-back-回写模式"}},[_._v("#")]),_._v(" 3. Write Back（回写模式）")]),_._v(" "),t("p",[_._v("在回写模式下，数据首先写入缓存，之后异步写入数据库：")]),_._v(" "),t("ul",[t("li",[_._v("写入数据库的操作由后台线程或任务队列完成。")])]),_._v(" "),t("p",[t("strong",[_._v("工作流程：")])]),_._v(" "),t("ol",[t("li",[_._v("数据先写入 Redis。")]),_._v(" "),t("li",[_._v("Redis 异步将数据批量写入数据库。")])]),_._v(" "),t("p",[t("strong",[_._v("适用场景：")])]),_._v(" "),t("ul",[t("li",[_._v("写频率高、读频率较低且对一致性要求不严格的场景，例如日志系统。")])]),_._v(" "),t("p",[t("strong",[_._v("优缺点：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("优点")]),_._v("：写入性能高，因为写数据库是异步的。")]),_._v(" "),t("li",[t("strong",[_._v("缺点")]),_._v("：可能导致数据丢失，如果缓存写入后还未同步到数据库时发生故障。")])]),_._v(" "),t("h4",{attrs:{id:"_4-read-through-只缓存模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-read-through-只缓存模式"}},[_._v("#")]),_._v(" 4. Read Through（只缓存模式）")]),_._v(" "),t("p",[_._v("在这种模式中，所有的读写操作都必须通过缓存完成：")]),_._v(" "),t("ul",[t("li",[_._v("缓存未命中时，应用从数据库中加载数据并自动更新缓存。")])]),_._v(" "),t("p",[t("strong",[_._v("工作流程：")])]),_._v(" "),t("ol",[t("li",[_._v("应用读取 Redis，如果未命中，自动从数据库加载并更新。")]),_._v(" "),t("li",[_._v("写入时同步更新缓存和数据库。")])]),_._v(" "),t("p",[t("strong",[_._v("适用场景：")])]),_._v(" "),t("ul",[t("li",[_._v("读多写少且对实时性要求较高的场景。")])]),_._v(" "),t("p",[t("strong",[_._v("优缺点：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("优点")]),_._v("：应用层逻辑简单。")]),_._v(" "),t("li",[t("strong",[_._v("缺点")]),_._v("：依赖于缓存层，缓存崩溃可能导致大量数据库请求。")])]),_._v(" "),t("h4",{attrs:{id:"_5、refresh-ahead-提前刷新缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5、refresh-ahead-提前刷新缓存"}},[_._v("#")]),_._v(" 5、Refresh Ahead（提前刷新缓存）")]),_._v(" "),t("p",[_._v("Refresh Ahead 模式通过提前异步加载数据，防止缓存失效时查询数据库的性能抖动。")]),_._v(" "),t("ul",[t("li",[_._v("基于预设的过期时间，在缓存即将失效前，后台异步加载数据并更新缓存。")])]),_._v(" "),t("h4",{attrs:{id:"_6、singleflight-模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6、singleflight-模式"}},[_._v("#")]),_._v(" 6、Singleflight 模式")]),_._v(" "),t("p",[_._v("Singleflight 是一种"),t("strong",[_._v("抑制重复请求")]),_._v("的模式，用于解决缓存未命中时的高并发问题。")]),_._v(" "),t("ul",[t("li",[_._v("当多个请求同时查询相同的缓存未命中数据时，只有一个请求会执行数据库查询，其余请求等待结果返回。")])]),_._v(" "),t("p",[t("strong",[_._v("核心思路")])]),_._v(" "),t("ul",[t("li",[_._v("当多个并发请求同时访问"),t("strong",[_._v("同一个缓存键")]),_._v("，导致缓存未命中时，"),t("strong",[_._v("Singleflight")]),_._v(" 机制保证只有"),t("strong",[_._v("一个请求")]),_._v("去执行实际的数据库查询或计算操作，其余请求会等待第一个请求的结果完成后直接返回相同的结果。")]),_._v(" "),t("li",[_._v("这样可以有效避免重复查询或计算，减少对数据库、API 等资源的压力。")])]),_._v(" "),t("p",[t("strong",[_._v("流程")])]),_._v(" "),t("ol",[t("li",[_._v("多个请求到来时，检测是否已有请求正在执行。\n"),t("ul",[t("li",[_._v("如果没有请求在执行，则当前请求负责查询数据。")]),_._v(" "),t("li",[_._v("如果已有请求在执行，其他请求进入等待队列。")])])]),_._v(" "),t("li",[t("strong",[_._v("第一个请求执行数据库查询或计算操作，并保存结果。")])]),_._v(" "),t("li",[t("strong",[_._v("等待中的请求获取到第一个请求的结果，直接返回相同数据。")])])]),_._v(" "),t("h3",{attrs:{id:"redis-缓存模式的优化策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-缓存模式的优化策略"}},[_._v("#")]),_._v(" Redis 缓存模式的优化策略")]),_._v(" "),t("h4",{attrs:{id:"_1-缓存雪崩"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存雪崩"}},[_._v("#")]),_._v(" "),t("strong",[_._v("1. 缓存雪崩")])]),_._v(" "),t("p",[_._v("缓存雪崩指缓存集中失效时，大量请求直接击穿数据库，导致数据库压力激增甚至崩溃。")]),_._v(" "),t("p",[t("strong",[_._v("解决方案：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("设置随机过期时间")]),_._v("：避免大量缓存同时失效。")]),_._v(" "),t("li",[t("strong",[_._v("多级缓存")]),_._v("：在 Redis 之上增加本地缓存（如 Guava）。")]),_._v(" "),t("li",[t("strong",[_._v("请求限流")]),_._v("：通过限流机制控制瞬时流量。")])]),_._v(" "),t("h4",{attrs:{id:"_2-缓存击穿"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存击穿"}},[_._v("#")]),_._v(" "),t("strong",[_._v("2. 缓存击穿")])]),_._v(" "),t("p",[_._v("缓存击穿指某个热点数据缓存失效后，短时间内大量请求直接打到数据库。")]),_._v(" "),t("p",[t("strong",[_._v("解决方案：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("热点数据预加载")]),_._v("：提前将热点数据缓存。")]),_._v(" "),t("li",[t("strong",[_._v("加互斥锁")]),_._v("：在缓存未命中时，通过锁机制防止数据库过载。")])]),_._v(" "),t("h4",{attrs:{id:"_3-缓存穿透"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-缓存穿透"}},[_._v("#")]),_._v(" 3. 缓存穿透")]),_._v(" "),t("p",[_._v("缓存穿透指用户请求的数据既不在缓存中，也不存在于数据库中，导致所有请求打到数据库。")]),_._v(" "),t("p",[t("strong",[_._v("解决方案：")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("布隆过滤器")]),_._v("：拦截无效请求，减少数据库查询。")]),_._v(" "),t("li",[t("strong",[_._v("缓存空结果")]),_._v("：将不存在的数据写入缓存，避免重复查询。")])]),_._v(" "),t("h3",{attrs:{id:"redis-缓存模式的应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-缓存模式的应用场景"}},[_._v("#")]),_._v(" Redis 缓存模式的应用场景")]),_._v(" "),t("h4",{attrs:{id:"_1-电商秒杀"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-电商秒杀"}},[_._v("#")]),_._v(" "),t("strong",[_._v("1. 电商秒杀")])]),_._v(" "),t("p",[_._v("在高并发的秒杀场景中，Redis 通常用于缓存商品库存数据。典型模式为：")]),_._v(" "),t("ul",[t("li",[_._v("使用 "),t("code",[_._v("Cache Aside")]),_._v(" 模式缓存库存数据，避免频繁访问数据库。")]),_._v(" "),t("li",[_._v("配合分布式锁，防止超卖问题。")])]),_._v(" "),t("h4",{attrs:{id:"_2-社交网络"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-社交网络"}},[_._v("#")]),_._v(" "),t("strong",[_._v("2. 社交网络")])]),_._v(" "),t("p",[_._v("在社交平台上，Redis 用于存储用户会话、好友关系等数据：")]),_._v(" "),t("ul",[t("li",[_._v("使用 "),t("code",[_._v("Write Through")]),_._v(" 模式保证数据一致性。")]),_._v(" "),t("li",[_._v("通过 Redis 的 Set 结构实现快速去重和交集运算。")])]),_._v(" "),t("h4",{attrs:{id:"_3-实时排行榜"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-实时排行榜"}},[_._v("#")]),_._v(" "),t("strong",[_._v("3. 实时排行榜")])]),_._v(" "),t("p",[_._v("Redis 的 Sorted Set 结构非常适合实现排行榜功能：")]),_._v(" "),t("ul",[t("li",[_._v("使用 "),t("code",[_._v("Cache Aside")]),_._v(" 模式，定期将缓存中的排行榜数据同步到数据库。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);