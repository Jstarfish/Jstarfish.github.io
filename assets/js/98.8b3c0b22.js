(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{595:function(_,v,t){"use strict";t.r(v);var e=t(2),r=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[t("img",{attrs:{src:"https://dbastack.com/wp-content/uploads/2024/09/MySQL-Storage-Engine-3.png.webp",alt:"img"}})]),_._v(" "),t("blockquote",[t("p",[_._v("存储引擎是 MySQL 的组件，用于处理不同表类型的 SQL 操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。")]),_._v(" "),t("p",[_._v("使用哪一种引擎可以灵活选择，"),t("strong",[t("font",{attrs:{color:"red"}},[_._v("一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求")])],1),_._v("，使用合适的存储引擎，将会提高整个数据库的性能 。")]),_._v(" "),t("p",[_._v("MySQL 服务器使用可插拔的存储引擎体系结构，可以从运行中的MySQL服务器加载或卸载存储引擎 。")])]),_._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("MySQL 5.7 可供选择的存储引擎"),t("OutboundLink")],1)])]),_._v(" "),t("h2",{attrs:{id:"一、存储引擎的作用与架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、存储引擎的作用与架构"}},[_._v("#")]),_._v(" 一、存储引擎的作用与架构")]),_._v(" "),t("p",[_._v("MySQL 存储引擎是数据库的底层核心组件，负责数据的"),t("strong",[_._v("存储、检索、事务控制")]),_._v("以及"),t("strong",[_._v("并发管理")]),_._v("。其架构采用"),t("strong",[_._v("插件式设计")]),_._v("，允许用户根据业务需求灵活选择引擎类型，例如 InnoDB、MyISAM、Memory 等。这种设计将"),t("strong",[_._v("查询处理")]),_._v("与"),t("strong",[_._v("数据存储")]),_._v("解耦，提升了系统的可扩展性和灵活性 。")]),_._v(" "),t("p",[_._v("MySQL  的体系架构分为四层：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("连接层")]),_._v("：管理客户端连接、认证与线程分配，支持 SSL 安全协议。")]),_._v(" "),t("li",[t("strong",[_._v("核心服务层")]),_._v("：处理 SQL 解析、优化、缓存及内置函数执行。")]),_._v(" "),t("li",[t("strong",[_._v("存储引擎层")]),_._v("：实际负责数据的存储和提取，支持多引擎扩展。")]),_._v(" "),t("li",[t("strong",[_._v("数据存储层")]),_._v("：通过文件系统与存储引擎交互，管理物理文件。")])]),_._v(" "),t("h2",{attrs:{id:"二、核心存储引擎详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、核心存储引擎详解"}},[_._v("#")]),_._v(" 二、核心存储引擎详解")]),_._v(" "),t("h3",{attrs:{id:"_2-1-常用存储引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-常用存储引擎"}},[_._v("#")]),_._v(" 2.1 常用存储引擎")]),_._v(" "),t("p",[t("strong",[_._v("查看存储引擎")])]),_._v(" "),t("div",{staticClass:"language-mysql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("-- 查看支持的存储引擎\nSHOW ENGINES\n\n-- 查看默认存储引擎\nSHOW VARIABLES LIKE 'storage_engine'\n\n--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！\nshow create table tablename\n\n--准确查看某个数据库中的某一表所使用的存储引擎\nshow table status like 'tablename'\nshow table status from database where name=\"tablename\"\n")])])]),t("p",[_._v("以下是 MySQL 主要存储引擎的对比表格，整合了各引擎的核心特性及适用场景，结合最新版本（MySQL 8.0+）特性更新：")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[t("strong",[_._v("存储引擎")])]),_._v(" "),t("th",[t("strong",[_._v("核心特性")])]),_._v(" "),t("th",[t("strong",[_._v("事务支持")])]),_._v(" "),t("th",[t("strong",[_._v("锁级别")])]),_._v(" "),t("th",[t("strong",[_._v("索引类型")])]),_._v(" "),t("th",[t("strong",[_._v("文件结构")])]),_._v(" "),t("th",[t("strong",[_._v("适用场景")])])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("strong",[_._v("InnoDB")])]),_._v(" "),t("td",[_._v("支持ACID事务、行级锁、MVCC、外键约束，具备崩溃恢复能力，默认使用聚簇索引")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td",[_._v("行锁/表锁")]),_._v(" "),t("td",[_._v("B+Tree/全文索引（5.6+）")]),_._v(" "),t("td",[t("code",[_._v(".ibd")]),_._v("（数据+索引）、"),t("code",[_._v(".frm")]),_._v("（表结构）")]),_._v(" "),t("td",[_._v("高并发OLTP（电商交易、金融系统）")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("MyISAM")])]),_._v(" "),t("td",[_._v("非事务型，表级锁，支持全文索引和压缩表，查询速度快")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("表锁")]),_._v(" "),t("td",[_._v("B+Tree/全文索引")]),_._v(" "),t("td",[t("code",[_._v(".MYD")]),_._v("（数据）、"),t("code",[_._v(".MYI")]),_._v("（索引）、"),t("code",[_._v(".frm")])]),_._v(" "),t("td",[_._v("静态报表、日志分析、只读业务")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("Memory")])]),_._v(" "),t("td",[_._v("数据全内存存储，哈希索引加速查询，重启后数据丢失")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("表锁")]),_._v(" "),t("td",[_._v("Hash/B-Tree")]),_._v(" "),t("td",[t("code",[_._v(".frm")]),_._v("（仅表结构）")]),_._v(" "),t("td",[_._v("临时表、会话缓存、高速缓存层")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("Archive")])]),_._v(" "),t("td",[_._v("仅支持INSERT/SELECT，Zlib压缩存储（压缩率10:1），无索引")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("行锁（仅插入）")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[t("code",[_._v(".ARZ")]),_._v("（数据）、"),t("code",[_._v(".ARM")]),_._v("（元数据）")]),_._v(" "),t("td",[_._v("历史数据归档、审计日志")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("CSV")])]),_._v(" "),t("td",[_._v("数据以CSV格式存储，可直接文本编辑，不支持索引")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("表锁")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[t("code",[_._v(".CSV")]),_._v("（数据）、"),t("code",[_._v(".CSM")]),_._v("（元数据）")]),_._v(" "),t("td",[_._v("数据导入/导出中间表")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("Blackhole")])]),_._v(" "),t("td",[_._v("写入数据即丢弃，仅保留二进制日志，用于复制链路中继")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[t("code",[_._v(".frm")]),_._v("（仅表结构）")]),_._v(" "),t("td",[_._v("主从复制中继、性能测试")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("Federated")])]),_._v(" "),t("td",[_._v("代理访问远程表，本地无实际数据存储")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("依赖远程表引擎")]),_._v(" "),t("td",[_._v("依赖远程表引擎")]),_._v(" "),t("td",[t("code",[_._v(".frm")]),_._v("（仅表结构）")]),_._v(" "),t("td",[_._v("分布式数据聚合")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("NDB")])]),_._v(" "),t("td",[_._v("集群式存储引擎，支持数据自动分片和高可用性")]),_._v(" "),t("td",[_._v("✅")]),_._v(" "),t("td",[_._v("行锁")]),_._v(" "),t("td",[_._v("Hash/B-Tree")]),_._v(" "),t("td",[_._v("数据存储在集群节点")]),_._v(" "),t("td",[_._v("MySQL Cluster分布式系统")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("Merge")])]),_._v(" "),t("td",[_._v("聚合多个MyISAM表，逻辑上作为单个表操作")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("表锁")]),_._v(" "),t("td",[_._v("B-Tree")]),_._v(" "),t("td",[t("code",[_._v(".MRG")]),_._v("（聚合定义）、底层使用MyISAM文件")]),_._v(" "),t("td",[_._v("分库分表聚合查询")])]),_._v(" "),t("tr",[t("td",[t("strong",[_._v("Performance Schema")])]),_._v(" "),t("td",[_._v("内置性能监控引擎，采集服务器运行时指标")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("❌")]),_._v(" "),t("td",[_._v("内存存储，无物理文件")]),_._v(" "),t("td",[_._v("性能监控与诊断")])])])]),_._v(" "),t("h3",{attrs:{id:"_2-2-存储引擎架构演进"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-存储引擎架构演进"}},[_._v("#")]),_._v(" 2.2 存储引擎架构演进")]),_._v(" "),t("p",[t("strong",[_._v("1. MySQL 8.0 关键改进")])]),_._v(" "),t("ul",[t("li",[_._v("原子 DDL：DDL操作（如CREATE TABLE）具备事务性，失败时自动回滚元数据变更")]),_._v(" "),t("li",[_._v("数据字典升级：系统表全部转为InnoDB引擎，替代原有的.frm文件，实现事务化元数据管理")]),_._v(" "),t("li",[_._v("Redo日志优化：MySQL 8.0.30+ 引入 "),t("code",[_._v("innodb_redo_log_capacity")]),_._v(" 参数替代旧版日志配置，支持动态调整redo日志大小")])]),_._v(" "),t("p",[t("strong",[_._v("2.  物理文件结构变化")])]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("文件类型")]),_._v(" "),t("th",[_._v("5.7及之前版本")]),_._v(" "),t("th",[_._v("8.0+版本")]),_._v(" "),t("th",[_._v("作用")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("表结构定义文件")]),_._v(" "),t("td",[_._v(".frm")]),_._v(" "),t("td",[_._v(".sdi (JSON格式)")]),_._v(" "),t("td",[_._v("存储表结构元数据 6")])]),_._v(" "),t("tr",[t("td",[_._v("事务日志")]),_._v(" "),t("td",[_._v("ibdata1")]),_._v(" "),t("td",[_._v("undo_001, undo_002")]),_._v(" "),t("td",[_._v("独立UNDO表空间")])]),_._v(" "),t("tr",[t("td",[_._v("数据文件")]),_._v(" "),t("td",[_._v(".ibd")]),_._v(" "),t("td",[_._v(".ibd")]),_._v(" "),t("td",[_._v("表数据与索引存储")])]),_._v(" "),t("tr",[t("td",[_._v("临时文件")]),_._v(" "),t("td",[_._v("ibtmp1")]),_._v(" "),t("td",[_._v("ibtmp1")]),_._v(" "),t("td",[_._v("临时表空间")])])])]),_._v(" "),t("blockquote",[t("p",[_._v("示例：通过 "),t("code",[_._v("SHOW CREATE TABLE")]),_._v(" 可查看SDI元数据，支持 JSON 格式导出")])]),_._v(" "),t("h3",{attrs:{id:"_2-3-innodb-引擎的-4-大特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-innodb-引擎的-4-大特性"}},[_._v("#")]),_._v(" 2.3 Innodb 引擎的 4 大特性")]),_._v(" "),t("h4",{attrs:{id:"_1-插入缓冲-insert-buffer-change-buffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-插入缓冲-insert-buffer-change-buffer"}},[_._v("#")]),_._v(" "),t("strong",[_._v("1. 插入缓冲（Insert Buffer / Change Buffer）")])]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("作用")]),_._v("：优化非唯一二级索引的插入、删除、更新（即 DML 操作）性能，减少磁盘随机 I/O 开销。")]),_._v(" "),t("li",[_._v("原理：\n"),t("ul",[t("li",[_._v("当非唯一索引页不在内存中时，操作会被暂存到 Change Buffer（内存区域）中，而非直接写入磁盘。")]),_._v(" "),t("li",[_._v("后续通过合并（Merge）操作，将多个离散的修改批量写入磁盘，减少 I/O 次数。")])])]),_._v(" "),t("li",[_._v("适用条件：\n"),t("ul",[t("li",[_._v("仅针对非唯一二级索引。")]),_._v(" "),t("li",[_._v("可通过参数 "),t("code",[_._v("innodb_change_buffer_max_size")]),_._v(" 调整缓冲区大小（默认 25% 缓冲池）。")])])])]),_._v(" "),t("h4",{attrs:{id:"_2-二次写-double-write"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-二次写-double-write"}},[_._v("#")]),_._v(" 2. 二次写（Double Write）")]),_._v(" "),t("ul",[t("li",[_._v("作用：防止因部分页写入（Partial Page Write）导致的数据页损坏，确保崩溃恢复的可靠性。")]),_._v(" "),t("li",[_._v("流程：\n"),t("ul",[t("li",[_._v("脏页刷盘时，先写入内存的 Doublewrite Buffer，再分两次（每次 1MB）顺序写入共享表空间的连续磁盘区域。")]),_._v(" "),t("li",[_._v("若数据页写入过程中崩溃，恢复时从共享表空间副本还原损坏页，再通过 Redo Log 恢复。")])])]),_._v(" "),t("li",[_._v("意义：牺牲少量顺序 I/O 换取数据完整性，避免因随机 I/O 中断导致数据丢失。")])]),_._v(" "),t("h4",{attrs:{id:"_3-自适应哈希索引-adaptive-hash-index-ahi"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-自适应哈希索引-adaptive-hash-index-ahi"}},[_._v("#")]),_._v(" 3. 自适应哈希索引（Adaptive Hash Index, AHI）")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("作用：自动为高频访问的索引页创建哈希索引，加速查询速度（尤其等值查询）。")])]),_._v(" "),t("li",[t("p",[_._v("触发条件：")]),_._v(" "),t("ul",[t("li",[_._v("同一索引被连续访问 17 次以上。")]),_._v(" "),t("li",[_._v("某页被访问超过 100 次，且访问模式一致（如固定 WHERE 条件）。")])])]),_._v(" "),t("li",[t("p",[_._v("限制")]),_._v(" "),t("p",[_._v("：仅对热点数据生效，无法手动指定，可通过参数 "),t("code",[_._v("innodb_adaptive_hash_index")]),_._v(" 启用或关闭。")])])]),_._v(" "),t("h4",{attrs:{id:"_4-预读-read-ahead"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-预读-read-ahead"}},[_._v("#")]),_._v(" 4. 预读（Read Ahead）")]),_._v(" "),t("ul",[t("li",[_._v("作用：基于空间局部性原理，异步预加载相邻数据页到缓冲池，减少未来查询的磁盘 I/O。")]),_._v(" "),t("li",[_._v("模式：\n"),t("ul",[t("li",[_._v("线性预读：按顺序访问的页超过阈值时，预加载下一批连续页（默认 64 页为一个块）。")]),_._v(" "),t("li",[_._v("随机预读（已废弃）：当某块中部分页在缓冲池时，预加载剩余页，但因性能问题被弃用。")])])])]),_._v(" "),t("h4",{attrs:{id:"其他重要特性补充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他重要特性补充"}},[_._v("#")]),_._v(" 其他重要特性补充")]),_._v(" "),t("p",[_._v("尽管上述四点是核心性能优化特性，但 InnoDB 的其他关键能力也值得注意：")]),_._v(" "),t("ul",[t("li",[_._v("事务支持：通过 ACID 特性（原子性、一致性、隔离性、持久性）保障数据一致性。")]),_._v(" "),t("li",[_._v("行级锁与外键约束：支持高并发与数据完整性。")]),_._v(" "),t("li",[t("strong",[_._v("崩溃恢复")]),_._v("：结合 Redo Log 和 Double Write 实现快速恢复")])]),_._v(" "),t("h3",{attrs:{id:"_2-4-数据的存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-数据的存储"}},[_._v("#")]),_._v(" 2.4 数据的存储")]),_._v(" "),t("p",[_._v("在整个数据库体系结构中，我们可以使用不同的存储引擎来存储数据，而绝大多数存储引擎都以二进制的形式存储数据；我们来看下InnoDB 中对数据是如何存储的。")]),_._v(" "),t("p",[_._v("在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.starfish.ink/mysql/table-space.jpg",alt:""}})]),_._v(" "),t("p",[_._v("同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 "),t("code",[_._v("innodb_page_size")]),_._v(" 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同")]),_._v(" "),t("p",[_._v("对于 16KB 的页来说，连续的 64 个页就是一个区，也就是 1 个区默认占用 1 MB 空间的大小。")]),_._v(" "),t("h4",{attrs:{id:"数据页结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据页结构"}},[_._v("#")]),_._v(" 数据页结构")]),_._v(" "),t("p",[_._v("页是 InnoDB 存储引擎管理数据的最小磁盘单位，一个页的大小一般是 "),t("code",[_._v("16KB")]),_._v("。")]),_._v(" "),t("p",[t("code",[_._v("InnoDB")]),_._v(" 为了不同的目的而设计了许多种不同类型的"),t("code",[_._v("页")]),_._v("，比如存放表空间头部信息的页，存放 "),t("code",[_._v("Insert Buffer")]),_._v(" 信息的页，存放 "),t("code",[_._v("INODE")]),_._v("信息的页，存放 "),t("code",[_._v("undo")]),_._v(" 日志信息的页等等等等。")]),_._v(" "),t("p",[_._v("B-Tree 节点就是实际存放表中数据的页面，我们在这里将要介绍页是如何组织和存储记录的；首先，一个 InnoDB 页有以下七个部分：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.starfish.ink/mysql/innodb-b-tree-node.jpg",alt:""}})]),_._v(" "),t("p",[_._v("有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th",[_._v("名称")]),_._v(" "),t("th",[_._v("中文名")]),_._v(" "),t("th",[_._v("占用空间大小")]),_._v(" "),t("th",[_._v("简单描述")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[t("code",[_._v("File Header")])]),_._v(" "),t("td",[_._v("文件头部")]),_._v(" "),t("td",[t("code",[_._v("38")]),_._v("字节")]),_._v(" "),t("td",[_._v("页的一些通用信息")])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("Page Header")])]),_._v(" "),t("td",[_._v("页面头部")]),_._v(" "),t("td",[t("code",[_._v("56")]),_._v("字节")]),_._v(" "),t("td",[_._v("数据页专有的一些信息")])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("Infimum + Supremum")])]),_._v(" "),t("td",[_._v("最小记录和最大记录")]),_._v(" "),t("td",[t("code",[_._v("26")]),_._v("字节")]),_._v(" "),t("td",[_._v("两个虚拟的行记录")])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("User Records")])]),_._v(" "),t("td",[_._v("用户记录")]),_._v(" "),t("td",[_._v("不确定")]),_._v(" "),t("td",[_._v("实际存储的行记录内容")])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("Free Space")])]),_._v(" "),t("td",[_._v("空闲空间")]),_._v(" "),t("td",[_._v("不确定")]),_._v(" "),t("td",[_._v("页中尚未使用的空间")])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("Page Directory")])]),_._v(" "),t("td",[_._v("页面目录")]),_._v(" "),t("td",[_._v("不确定")]),_._v(" "),t("td",[_._v("页中的某些记录的相对位置")])]),_._v(" "),t("tr",[t("td",[t("code",[_._v("File Trailer")])]),_._v(" "),t("td",[_._v("文件尾部")]),_._v(" "),t("td",[t("code",[_._v("8")]),_._v("字节")]),_._v(" "),t("td",[_._v("校验页是否完整")])])])]),_._v(" "),t("p",[_._v("在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的"),t("code",[_._v("行格式")]),_._v("存储到 "),t("code",[_._v("User Records")]),_._v(" 部分。但是在一开始生成页的时候，其实并没有 "),t("code",[_._v("User Records")]),_._v(" 这个部分，每当我们插入一条记录，都会从 "),t("code",[_._v("Free Space")]),_._v(" 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 "),t("code",[_._v("User Records")]),_._v(" 部分，当 "),t("code",[_._v("Free Space")]),_._v(" 部分的空间全部被 "),t("code",[_._v("User Records")]),_._v(" 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.starfish.ink/mysql/page-application-record.png",alt:""}})]),_._v(" "),t("h4",{attrs:{id:"如何存储表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何存储表"}},[_._v("#")]),_._v(" 如何存储表")]),_._v(" "),t("p",[_._v("MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 "),t("code",[_._v(".frm")]),_._v(" 文件中，后者存储在 "),t("code",[_._v(".ibd")]),_._v(" 文件中。")]),_._v(" "),t("h4",{attrs:{id:"frm-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#frm-文件"}},[_._v("#")]),_._v(" .frm 文件")]),_._v(" "),t("p",[_._v("无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 "),t("code",[_._v(".frm")]),_._v(" 文件用来描述表的格式或者说定义；"),t("code",[_._v(".frm")]),_._v(" 文件的格式在不同的平台上都是相同的。")]),_._v(" "),t("blockquote",[t("p",[_._v("MySQL 官方文档中的 "),t("a",{attrs:{href:"https://dev.mysql.com/doc/internals/en/frm-file-format.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("11.1 MySQL .frm File Format"),t("OutboundLink")],1),_._v(" 一文对于 "),t("code",[_._v(".frm")]),_._v(" 文件格式中的二进制的内容有着非常详细的表述。")])]),_._v(" "),t("h4",{attrs:{id:"ibd-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ibd-文件"}},[_._v("#")]),_._v(" .ibd 文件")]),_._v(" "),t("p",[_._v("InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 "),t("code",[_._v("ibdata1")]),_._v("、"),t("code",[_._v("ibdata2")]),_._v(" 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。")]),_._v(" "),t("p",[_._v("当打开 "),t("code",[_._v("innodb_file_per_table")]),_._v(" 选项时，"),t("code",[_._v(".ibd")]),_._v(" 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。")]),_._v(" "),t("h4",{attrs:{id:"如何存储记录-innodb-行格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何存储记录-innodb-行格式"}},[_._v("#")]),_._v(" 如何存储记录 | InnoDB  行格式")]),_._v(" "),t("p",[_._v("InnoDB 存储引擎和大多数数据库一样，记录是以行的形式存储的，每个 16KB 大小的页中可以存放多条行记录。")]),_._v(" "),t("p",[_._v("它可以使用不同的行格式进行存储。")]),_._v(" "),t("p",[_._v("InnoDB 早期的文件格式为 "),t("code",[_._v("Antelope")]),_._v("，可以定义两种行记录格式，分别是 "),t("code",[_._v("Compact")]),_._v(" 和 "),t("code",[_._v("Redundant")]),_._v("，InnoDB 1.0.x 版本开始引入了新的文件格式 "),t("code",[_._v("Barracuda")]),_._v("。"),t("code",[_._v("Barracuda")]),_._v("文件格式下拥有两种新的行记录格式："),t("code",[_._v("Compressed")]),_._v(" 和 "),t("code",[_._v("Dynamic")]),_._v("。")]),_._v(" "),t("blockquote",[t("p",[t("a",{attrs:{href:"https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html#innodb-row-format-redundant",target:"_blank",rel:"noopener noreferrer"}},[_._v("InnoDB Row Formats"),t("OutboundLink")],1)])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.starfish.ink/mysql/innodb-row-format.png",alt:""}})]),_._v(" "),t("p",[_._v("MySQL 5.7 版本支持以上格式的行存储方式。")]),_._v(" "),t("p",[_._v("我们可以在创建或修改表的语句中指定行格式：")]),_._v(" "),t("div",{staticClass:"language-mysql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称\n    \nALTER TABLE 表名 ROW_FORMAT=行格式名称\n")])])]),t("p",[t("code",[_._v("Compact")]),_._v("行记录格式是在 MySQL 5.0 中引入的，其首部是一个非 NULL 变长列长度列表，并且是逆序放置的，其长度为：")]),_._v(" "),t("ul",[t("li",[_._v("若列的长度小于等于 255 字节，用 1 个字节表示；")]),_._v(" "),t("li",[_._v("若列的长度大于 255 字节，用 2 个字节表示。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://miro.medium.com/v2/resize:fit:1400/1*wNIUPIn4jo9kKbLvsmSUDQ.png",alt:"Compact row format"}})]),_._v(" "),t("p",[_._v("变长字段的长度最大不可以超过 2 字节，这是因为 MySQL 数据库中 VARCHAR 类型的最大长度限制为 65535。变长字段之后的第二个部分是 NULL 标志位，该标志位指示了该行数据中某列是否为 NULL 值，有则用 1 表示，NULL 标志位也是不定长的。接下来是记录头部信息，固定占用 5 字节。")]),_._v(" "),t("p",[t("code",[_._v("Redundant")]),_._v(" 是 MySQL 5.0 版本之前 InnoDB 的行记录格式，"),t("code",[_._v("Redundant")]),_._v(" 行记录格式的首部是每一列长度偏移列表，同样是逆序存放的。从整体上看，"),t("code",[_._v("Compact")]),_._v("格式的存储空间减少了约 20%，但代价是某些操作会增加 CPU 的使用。")]),_._v(" "),t("p",[t("code",[_._v("Dynamic")]),_._v(" 和 "),t("code",[_._v("Compressed")]),_._v("是 "),t("code",[_._v("Compact")]),_._v("行记录格式的变种，"),t("code",[_._v("Compressed")]),_._v("会对存储在其中的行数据会以 "),t("code",[_._v("zlib")]),_._v(" 的算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 这类大长度类型的数据能够进行非常有效的存储。")]),_._v(" "),t("blockquote",[t("p",[_._v("高版本，比如 8.3 默认使用的是 Dynamic")]),_._v(" "),t("div",{staticClass:"language-sql extra-class"},[t("pre",{pre:!0,attrs:{class:"language-sql"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("SELECT")]),_._v(" @"),t("span",{pre:!0,attrs:{class:"token variable"}},[_._v("@innodb_default_row_format")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])])])]),_._v(" "),t("h4",{attrs:{id:"行溢出数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#行溢出数据"}},[_._v("#")]),_._v(" 行溢出数据")]),_._v(" "),t("p",[_._v("当 InnoDB 存储极长的 TEXT 或者 BLOB 这类大对象时，MySQL 并不会直接将所有的内容都存放在数据页中。因为 InnoDB 存储引擎使用 B+Tree 组织索引，每个页中至少应该有两条行记录，因此，如果页中只能存放下一条记录，那么 InnoDB 存储引擎会自动将行数据存放到溢出页中。")]),_._v(" "),t("p",[_._v("如果我们使用 "),t("code",[_._v("Compact")]),_._v(" 或 "),t("code",[_._v("Redundant")]),_._v(" 格式，那么会将行数据中的前  768  个字节存储在数据页中，后面的数据会通过指针指向 Uncompressed BLOB Page。")]),_._v(" "),t("p",[_._v("但是如果我们使用新的行记录格式 "),t("code",[_._v("Compressed")]),_._v(" 或者 "),t("code",[_._v("Dynamic")]),_._v(" 时只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。")]),_._v(" "),t("h3",{attrs:{id:"参考与引用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考与引用"}},[_._v("#")]),_._v(" 参考与引用：")]),_._v(" "),t("ul",[t("li",[_._v("https://www.linkedin.com/pulse/leverage-innodb-architecture-optimize-django-model-design-bouslama")]),_._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/chenpingzhao/p/9177324.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("踏雪无痕-InnoDB存储引擎"),t("OutboundLink")],1)]),_._v(" "),t("li",[t("a",{attrs:{href:"https://wingsxdu.com/posts/database/mysql/innodb/",target:"_blank",rel:"noopener noreferrer"}},[_._v("MySQL 与 InnoDB 存储引擎总结"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=r.exports}}]);