(window.webpackJsonp=window.webpackJsonp||[]).push([[233],{722:function(t,s,a){"use strict";a.r(s);var _=a(2),n=Object(_.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("img",{attrs:{src:"https://img.starfish.ink/common/faq-banner.png",alt:""}})]),t._v(" "),a("blockquote",[a("p",[t._v("写在之前：不建议背书式的去记忆面试题，对技术的提升帮助很小，对正经面试也没什么帮助，准备面试的过程还是要把各个知识点真懂了，然后再连成线。")]),t._v(" "),a("p",[t._v("个人建议把面试题看作是费曼学习法中的回顾、简化的环节，准备面试的时候，跟着题目先自己讲给自己听，看看自己会满意吗，不满意就继续学习这个点，然后调整自己的话术，如此反复，对这块知识也会理解的更到位，而且面试时候也会得心应手，心仪的 offer 肯定会有的。")]),t._v(" "),a("p",[t._v("当然，大家有遇到过什么样『有趣』『有含量』的题目，欢迎提出来，一起学习~")])]),t._v(" "),a("h2",{attrs:{id:"🗺️-知识导航"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🗺️-知识导航"}},[t._v("#")]),t._v(" 🗺️ 知识导航")]),t._v(" "),a("h3",{attrs:{id:"🏷️-核心知识分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🏷️-核心知识分类"}},[t._v("#")]),t._v(" 🏷️ 核心知识分类")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("🏗️ 基础与架构")]),t._v("：MySQL架构组件、SQL语法（DDL/DML/DCL）、存储原理")]),t._v(" "),a("li",[a("strong",[t._v("🗄️ 存储引擎")]),t._v("：InnoDB vs MyISAM特性对比、存储格式、缓冲池机制")]),t._v(" "),a("li",[a("strong",[t._v("🔍 索引机制与优化")]),t._v("：B+树原理、索引类型、覆盖索引、联合索引、索引失效场景")]),t._v(" "),a("li",[a("strong",[t._v("🔒 事务与锁机制")]),t._v("：ACID特性、隔离级别、死锁处理、MVCC原理、并发控制")]),t._v(" "),a("li",[a("strong",[t._v("📊 数据类型与查询优化")]),t._v("：数据类型选择、JOIN优化、子查询、窗口函数、执行计划分析")]),t._v(" "),a("li",[a("strong",[t._v("📝 日志系统")]),t._v("：redo log、undo log、binlog机制、WAL原理")]),t._v(" "),a("li",[a("strong",[t._v("⚡ 性能调优")]),t._v("：慢查询分析、参数调优、缓存策略、硬件优化")]),t._v(" "),a("li",[a("strong",[t._v("🚀 分库分表与集群")]),t._v("：主从复制、读写分离、分片策略、数据迁移、集群部署")]),t._v(" "),a("li",[a("strong",[t._v("💻 SQL实战编程")]),t._v("：复杂查询编写、存储过程、触发器、性能优化案例")]),t._v(" "),a("li",[a("strong",[t._v("🖊️ 手撕SQL")]),t._v("：经典SQL题目、复杂业务场景查询、算法实现、面试真题")]),t._v(" "),a("li",[a("strong",[t._v("🔧 运维与监控")]),t._v("：备份恢复、监控指标、故障排查、容量规划、日常维护")])]),t._v(" "),a("h2",{attrs:{id:"一、基础与架构-🏗️"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、基础与架构-🏗️"}},[t._v("#")]),t._v(" 一、基础与架构 🏗️")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-整体架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-整体架构"}},[t._v("#")]),t._v(" 🎯 MySQL 整体架构")]),t._v(" "),a("p",[t._v("和其它数据库相比，MySQL 有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，"),a("strong",[t._v("插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离")]),t._v("。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img.starfish.ink/mysql/architecture.png",alt:""}})]),t._v(" "),a("blockquote",[a("ul",[a("li",[a("p",[a("strong",[t._v("连接层")]),t._v("：最上层是一些客户端和连接服务。"),a("strong",[t._v("主要完成一些类似于连接处理、授权认证、及相关的安全方案")]),t._v("。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("服务层")]),t._v("：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("引擎层")]),t._v("：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("存储层")]),t._v("：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-的查询流程具体是怎么样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-的查询流程具体是怎么样的"}},[t._v("#")]),t._v(" 🎯 MySQL 的查询流程具体是怎么样的？")]),t._v(" "),a("blockquote",[a("p",[t._v("[!TIP]")]),t._v(" "),a("p",[t._v("一条 SQL 语句在 MySQL 中如何执行的？")]),t._v(" "),a("p",[t._v("画出 MySQL 架构图？ 「这种变态问题都能问的出来~」")])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("客户端请求")]),t._v("：客户端通过连接器发送查询到 MySQL 服务器（验证用户身份，给予权限）")]),t._v(" "),a("li",[a("strong",[t._v("查询接收")]),t._v("：连接器接收请求，管理连接")]),t._v(" "),a("li",[a("strong",[t._v("解析器")]),t._v("：对 SQL 进行词法分析和语法分析，转换为解析树")]),t._v(" "),a("li",[a("strong",[t._v("优化器")]),t._v("：优化器生成执行计划，选择最优索引和连接顺序")]),t._v(" "),a("li",[a("strong",[t._v("查询执行器")]),t._v("：执行器执行查询，通过存储引擎接口获取数据")]),t._v(" "),a("li",[a("strong",[t._v("存储引擎")]),t._v("：存储引擎检索数据，返回给执行器")]),t._v(" "),a("li",[a("strong",[t._v("返回结果")]),t._v("：结果通过连接器返回给客户端")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img.starfish.ink/mysql/MySQL-select-flow.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-的数据存储结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-的数据存储结构"}},[t._v("#")]),t._v(" 🎯 MySQL 的数据存储结构")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL（InnoDB）的存储结构是分层设计的，数据最终存放在页（Page）里，页是最小的存储和 I/O 单位（16KB）。多个页组成区（Extent，1MB），多个区组成段（Segment），段属于表空间（Tablespace）。每张表对应一个表空间，里面包含数据段和索引段。行数据存放在数据页中，大字段可能存放在溢出页。这样的设计能兼顾存储管理、性能和空间利用。")])]),t._v(" "),a("p",[t._v("在 MySQL 中，数据的存储结构从上到下大致分为 "),a("strong",[t._v("库 → 表 → 表空间 → 段（Segment）→ 区（Extent）→ 页（Page）→ 行（Row）")]),t._v(" 这几个层次。")]),t._v(" "),a("p",[a("strong",[t._v("1. 库（Database）")])]),t._v(" "),a("ul",[a("li",[t._v("最上层的逻辑组织单位，相当于一个文件夹。")]),t._v(" "),a("li",[t._v("在磁盘上表现为一个 "),a("strong",[t._v("目录")]),t._v("，里面包含了表对应的文件。")])]),t._v(" "),a("p",[a("strong",[t._v("2. 表（Table）")])]),t._v(" "),a("ul",[a("li",[t._v("每张表就是一组结构化的数据。")])]),t._v(" "),a("p",[a("strong",[t._v("3. 表空间（Tablespace）")])]),t._v(" "),a("ul",[a("li",[t._v("表空间是 InnoDB 的数据存储文件，可以是共享的（ibdata）或独立的（.ibd）。")]),t._v(" "),a("li",[t._v("表空间里存放表的所有数据和索引。")]),t._v(" "),a("li",[t._v("每个表空间由若干个 "),a("strong",[t._v("段（Segment）")]),t._v(" 组成。")])]),t._v(" "),a("p",[a("strong",[t._v("4. 段（Segment）")])]),t._v(" "),a("ul",[a("li",[t._v("段是表空间中的存储单位，用于管理不同用途的空间。")]),t._v(" "),a("li",[t._v("主要有两类：\n"),a("ul",[a("li",[a("strong",[t._v("数据段（Data Segment）")]),t._v("：存储表的数据（聚簇索引）。")]),t._v(" "),a("li",[a("strong",[t._v("索引段（Index Segment）")]),t._v("：存储二级索引的数据。")])])]),t._v(" "),a("li",[t._v("段是由 "),a("strong",[t._v("多个区（Extent）")]),t._v(" 组成的。")])]),t._v(" "),a("p",[a("strong",[t._v("5. 区（Extent）")])]),t._v(" "),a("ul",[a("li",[t._v("区是空间分配的基本单位，每个区大小固定为 "),a("strong",[t._v("1MB")]),t._v("。")]),t._v(" "),a("li",[t._v("在 InnoDB 默认 16KB 页大小时：\n"),a("ul",[a("li",[t._v("每个区包含 "),a("strong",[t._v("64 个页（16KB × 64 = 1MB）")]),t._v("。")])])]),t._v(" "),a("li",[t._v("为了减少空间碎片，InnoDB 会先以页为单位分配，表大了再按区分配。")])]),t._v(" "),a("p",[a("strong",[t._v("6. 页（Page）")])]),t._v(" "),a("ul",[a("li",[t._v("页是 "),a("strong",[t._v("InnoDB 磁盘和内存交互的基本单位")]),t._v("，默认大小 "),a("strong",[t._v("16KB")]),t._v("。")]),t._v(" "),a("li",[t._v("常见页类型：\n"),a("ul",[a("li",[a("strong",[t._v("数据页（B+Tree Node Page）")]),t._v("：存储表数据。")]),t._v(" "),a("li",[a("strong",[t._v("Undo 页")]),t._v("：存储回滚日志。")]),t._v(" "),a("li",[a("strong",[t._v("系统页")]),t._v("：存储事务系统信息。")]),t._v(" "),a("li",[a("strong",[t._v("索引页")]),t._v("：存储索引数据。")])])]),t._v(" "),a("li",[t._v("页内的数据通过 "),a("strong",[t._v("页目录（Page Directory）")]),t._v(" 进行管理。")])]),t._v(" "),a("p",[a("strong",[t._v("7. 行（Row）")])]),t._v(" "),a("ul",[a("li",[t._v("行是最小的数据存储单元。")]),t._v(" "),a("li",[t._v("InnoDB 是 "),a("strong",[t._v("行存储")]),t._v("，每行数据会按字段存储在数据页中。")]),t._v(" "),a("li",[t._v("行存储的特点：\n"),a("ul",[a("li",[t._v("一行数据可能存不下时，大字段（如 TEXT、BLOB）会存储在溢出页（Overflow Page），行中只保留指针。")]),t._v(" "),a("li",[t._v("每行都有额外的隐藏字段，比如："),a("strong",[t._v("DB_TRX_ID")]),t._v("（事务 ID）、"),a("strong",[t._v("DB_ROLL_PTR")]),t._v("（回滚指针）等")])])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("数据库（Database）\n   └── 表（Table）\n        └── 表空间（Tablespace）\n             └── 段（Segment）\n                  └── 区（Extent，1MB）\n                       └── 页（Page，16KB）\n                            └── 行（Row）\n")])])]),a("h3",{attrs:{id:"🎯-ddl、dml、dcl的区别和应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-ddl、dml、dcl的区别和应用"}},[t._v("#")]),t._v(" 🎯 DDL、DML、DCL的区别和应用？")]),t._v(" "),a("p",[t._v("MySQL语言分为三大类，各有不同的作用和权限要求：")]),t._v(" "),a("p",[a("strong",[t._v("语言分类对比")]),t._v("：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("DDL（Data Definition Language）")]),t._v("：数据定义语言")]),t._v(" "),a("li",[a("strong",[t._v("DML（Data Manipulation Language）")]),t._v("：数据操作语言")]),t._v(" "),a("li",[a("strong",[t._v("DCL（Data Control Language）")]),t._v("：数据控制语言")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"二、存储引擎-🗄️"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、存储引擎-🗄️"}},[t._v("#")]),t._v(" 二、存储引擎 🗄️")]),t._v(" "),a("blockquote",[a("p",[t._v("存储引擎是 MySQL 的组件，用于处理不同表类型的 SQL 操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。")]),t._v(" "),a("p",[t._v("使用哪一种引擎可以灵活选择，"),a("strong",[a("mark",[t._v("一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求")])]),t._v("，使用合适的存储引擎，将会提高整个数据库的性能 。")]),t._v(" "),a("p",[t._v("MySQL 服务器使用"),a("strong",[t._v("可插拔")]),t._v("的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。")]),t._v(" "),a("p",[a("strong",[t._v("查看存储引擎")])]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-- 查看支持的存储引擎\nSHOW ENGINES\n\n-- 查看默认存储引擎\nSHOW VARIABLES LIKE 'storage_engine'\n\n--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！\nshow create table tablename\n\n--准确查看某个数据库中的某一表所使用的存储引擎\nshow table status like 'tablename'\nshow table status from database where name=\"tablename\"\n")])])]),a("p",[a("strong",[t._v("设置存储引擎")])]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-- 建表时指定存储引擎。默认的就是INNODB，不需要设置\nCREATE TABLE t1 (i INT) ENGINE = INNODB;\nCREATE TABLE t2 (i INT) ENGINE = CSV;\nCREATE TABLE t3 (i INT) ENGINE = MEMORY;\n\n-- 修改存储引擎\nALTER TABLE t ENGINE = InnoDB;\n\n-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎\nSET default_storage_engine=NDBCLUSTER;\n")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-说说-mysql-都有哪些存储引擎-都有哪些区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说说-mysql-都有哪些存储引擎-都有哪些区别"}},[t._v("#")]),t._v(" 🎯 说说 MySQL 都有哪些存储引擎？都有哪些区别？")]),t._v(" "),a("p",[t._v("常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。")]),t._v(" "),a("p",[t._v("InnoDB 现在是 MySQL5.5 版本后默认的存储引擎，支持"),a("strong",[t._v("事务、行级锁定和外键")]),t._v("。我们一般和 MyISAM 进行对比即可")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("事务支持")]),t._v("：InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；")]),t._v(" "),a("li",[a("strong",[t._v("外键约束")]),t._v("：InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；")]),t._v(" "),a("li",[a("strong",[t._v("存储结构")]),t._v("：InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。")]),t._v(" "),a("li",[a("strong",[t._v("表空间管理")]),t._v("：InnoDB 使用表空间（tablespace）来管理数据存储，支持自动扩展，支持表和索引分开存储，提高存储效率。MyISAM 每个表有三个文件："),a("code",[t._v(".frm")]),t._v("（表定义文件）、"),a("code",[t._v(".MYD")]),t._v("（数据文件）和 "),a("code",[t._v(".MYI")]),t._v("（索引文件）")]),t._v(" "),a("li",[a("strong",[t._v("锁定机制")]),t._v("：InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；")]),t._v(" "),a("li",[a("strong",[t._v("崩溃恢复")]),t._v("：InnoDB 具有崩溃恢复的能力，使用重做日志（redo log）和回滚日志（undo log）来恢复数据；MyISAM 没有崩溃恢复机制，可能需要手动恢复")]),t._v(" "),a("li",[a("strong",[t._v("性能")]),t._v("： InnoDB 在写密集型操作中表现更好，特别是在需要事务和外键约束的场景下。MyISAM 在读密集型操作中表现更好，尤其是在没有写操作的情况下。")])]),t._v(" "),a("blockquote",[a("h4",{attrs:{id:"文件存储结构对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件存储结构对比"}},[t._v("#")]),t._v(" 文件存储结构对比")]),t._v(" "),a("p",[t._v("在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 "),a("code",[t._v(".frm")]),t._v(" 文件，"),a("code",[t._v(".frm")]),t._v(" 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有"),a("code",[t._v(".frm")]),t._v("文件，命名方式为 数据表名.frm，如 user.frm。")]),t._v(" "),a("p",[t._v("查看 MySQL 数据保存在哪里："),a("code",[t._v("show variables like 'data%'")])]),t._v(" "),a("p",[t._v("MyISAM 物理文件结构为：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v(".frm")]),t._v("文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等")]),t._v(" "),a("li",[a("code",[t._v(".MYD")]),t._v(" ("),a("code",[t._v("MYData")]),t._v(") 文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的数据")]),t._v(" "),a("li",[a("code",[t._v(".MYI")]),t._v(" ("),a("code",[t._v("MYIndex")]),t._v(")文件：MyISAM 存储引擎专用，用于存储 MyISAM 表的索引相关信息")])]),t._v(" "),a("p",[t._v("InnoDB 物理文件结构为：")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v(".frm")]),t._v(" 文件：与表相关的元数据信息都存放在 frm 文件，包括表结构的定义信息等")])]),t._v(" "),a("li",[a("p",[a("code",[t._v(".ibd")]),t._v(" 文件或 "),a("code",[t._v(".ibdata")]),t._v(" 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用"),a("strong",[t._v("共享表空间")]),t._v("存放存储数据，还是用"),a("strong",[t._v("独享表空间")]),t._v("存放存储数据。")]),t._v(" "),a("p",[t._v("独享表空间存储方式使用"),a("code",[t._v(".ibd")]),t._v("文件，并且每个表一个"),a("code",[t._v(".ibd")]),t._v("文件\n共享表空间存储方式使用"),a("code",[t._v(".ibdata")]),t._v("文件，所有表共同使用一个"),a("code",[t._v(".ibdata")]),t._v("文件（或多个，可自己配置）")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-哪个存储引擎执行-select-count-更快-为什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-哪个存储引擎执行-select-count-更快-为什么"}},[t._v("#")]),t._v(" 🎯 哪个存储引擎执行 select count(*) 更快，为什么?")]),t._v(" "),a("p",[t._v("MyISAM 更快，因为 MyISAM 内部维护了一个计数器，可以直接调取。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("MyISAM 存储每个表的行数在表的元数据中，因此执行 "),a("code",[t._v("SELECT COUNT(*)")]),t._v(" 时，它可以直接读取这个值，而不需要扫描整个表")])]),t._v(" "),a("li",[a("p",[t._v("nnoDB 不存储行数信息在表的元数据中。每次执行 "),a("code",[t._v("SELECT COUNT(*)")]),t._v(" 查询时，InnoDB 都需要扫描整个表来计算行数。这对于大表来说可能会非常慢。")])])]),t._v(" "),a("p",[t._v("InnoDB 不将表的行数存储在元数据中，主要原因是其设计目标与 MyISAM 不同。InnoDB 设计为支持高并发的事务处理和数据一致性，因此其存储和计数机制需要权衡性能和一致性。以下是一些具体原因：")]),t._v(" "),a("p",[a("strong",[t._v("1. 行级锁定和并发控制")])]),t._v(" "),a("p",[t._v("InnoDB 支持行级锁定，这意味着在高并发环境中，不同事务可以同时对不同的行进行操作，而不会相互阻塞。为了确保这种并发控制和数据一致性，InnoDB 需要动态计算行数，以反映当前事务视图下的数据状态。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("事务隔离级别")]),t._v("：InnoDB 支持多种事务隔离级别（如 READ COMMITTED、REPEATABLE READ、SERIALIZABLE），这些隔离级别决定了事务如何看到数据。预先存储的行数无法满足这些隔离级别的要求，因为行数在不同事务下可能有所不同。")]),t._v(" "),a("li",[a("strong",[t._v("锁机制")]),t._v("：由于行级锁定，InnoDB 在处理大量并发事务时，需要动态调整行数信息，而不是依赖预先存储的静态行数。")])]),t._v(" "),a("p",[a("strong",[t._v("2. 一致性和持久性")])]),t._v(" "),a("p",[t._v("InnoDB 设计为支持 ACID 属性（原子性、一致性、隔离性、持久性），这要求所有的数据操作都必须保证一致性和可靠性。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("崩溃恢复")]),t._v("：InnoDB 使用重做日志（redo log）和回滚日志（undo log）来实现崩溃恢复。如果行数保存在元数据中，崩溃恢复后行数可能与实际数据不一致，从而破坏数据的一致性。")]),t._v(" "),a("li",[a("strong",[t._v("并发更新")]),t._v("：在高并发环境中，多个事务可能同时修改表中的数据。如果行数保存在元数据中，每次更新都需要锁定并更新元数据，这将导致严重的性能瓶颈。")])]),t._v(" "),a("p",[a("strong",[t._v("3. 性能优化")])]),t._v(" "),a("p",[t._v("动态计算行数虽然在某些查询中（如 "),a("code",[t._v("SELECT COUNT(*)")]),t._v("）较慢，但它避免了在高并发写操作下频繁更新元数据的性能开销。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("写操作性能")]),t._v("：为了保证高效的写操作，InnoDB 设计避免了每次写操作都需要更新元数据的设计，这样可以更好地处理高并发写入。")]),t._v(" "),a("li",[a("strong",[t._v("实际应用")]),t._v("：在实际应用中，行数的精确统计并不是经常需要的操作。大多数情况下，应用程序可以通过索引和其他机制来实现高效的数据访问，而不依赖于 "),a("code",[t._v("SELECT COUNT(*)")]),t._v(" 的性能。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-为什么-mysql-默认存储引擎从-myisam-改为-innodb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-为什么-mysql-默认存储引擎从-myisam-改为-innodb"}},[t._v("#")]),t._v(" 🎯 为什么 MySQL 默认存储引擎从 MyISAM 改为 InnoDB？")]),t._v(" "),a("p",[t._v("MySQL 从 5.5 开始默认引擎改为 InnoDB，主要是因为 InnoDB 更符合企业级应用的需求：")]),t._v(" "),a("ul",[a("li",[t._v("支持事务，保证 ACID；")]),t._v(" "),a("li",[t._v("宕机时能通过 redo/undo log 保证数据安全；")]),t._v(" "),a("li",[t._v("行级锁提高了并发性能，而 MyISAM 只有表级锁；")]),t._v(" "),a("li",[t._v("支持外键，保证数据一致性；")]),t._v(" "),a("li",[t._v("有 Buffer Pool 缓存机制，性能更优；")]),t._v(" "),a("li",[t._v("也是 MySQL 社区未来重点发展的方向。")])]),t._v(" "),a("p",[t._v("因此 InnoDB 逐渐取代 MyISAM，成为默认存储引擎。")]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"三、索引机制与优化-🔍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、索引机制与优化-🔍"}},[t._v("#")]),t._v(" 三、索引机制与优化 🔍")]),t._v(" "),a("blockquote",[a("ul",[a("li",[a("p",[t._v("MYSQL官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构，所以说"),a("strong",[t._v("索引的本质是：数据结构")])])]),t._v(" "),a("li",[a("p",[t._v("索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。")])]),t._v(" "),a("li",[a("p",[t._v("可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，"),a("font",{attrs:{color:"#FF0000"}},[a("strong",[t._v("数据库还维护者一个满足特定查找算法的数据结构")])]),t._v("，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例。")],1),t._v(" "),a("p",[a("img",{attrs:{src:"https://img.starfish.ink/mysql/search-index-demo.png",alt:""}})]),t._v(" "),a("p",[t._v("左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址")]),t._v(" "),a("p",[t._v("为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。")])]),t._v(" "),a("li",[a("p",[t._v("索引本身也很大，不可能全部存储在内存中，"),a("strong",[t._v("一般以索引文件的形式存储在磁盘上")])])]),t._v(" "),a("li",[a("p",[t._v("平常说的索引，没有特别指明的话，就是 B+ 树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用 B+ 树索引，统称索引。此外还有哈希索引等。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-说说你对-mysql-索引的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说说你对-mysql-索引的理解"}},[t._v("#")]),t._v(" 🎯 说说你对 MySQL 索引的理解？")]),t._v(" "),a("blockquote",[a("p",[t._v("这种就属于比较宽泛的问题，可以有结构条例的多说一些。差不多的问法：")]),t._v(" "),a("ul",[a("li",[t._v("索引是越多越好吗？为什么？")]),t._v(" "),a("li",[t._v("索引有哪些优缺点？")])])]),t._v(" "),a("blockquote",[a("p",[t._v("[!TIP]")]),t._v(" "),a("p",[a("strong",[t._v("话术点")]),t._v("：B+ 树、优缺点、索引分类、最左匹配原则")])]),t._v(" "),a("p",[t._v("索引是数据库优化的重要工具，从数据结构上来说，在 MySQL 里面索引主要是 B+ 树索引。它的查询性能更好，适合范围查询，也适合放在内存里。 MySQL 的索引又可以从不同的角度进一步划分。比如说根据叶子节点是否包含 数据分成聚簇索引和非聚簇索引，还有包含某个查询的所有列的覆盖索引等 等。数据库使用索引遵循最左匹配原则。但是最终数据库会不会用索引，也是一个比较难说的事情，跟查询有关，也跟数据量有关。在实践中，是否使用索引以及使用什么索引，都要以 EXPLAIN 为准。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("优势")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("提高数据检索效率，降低数据库IO成本")])]),t._v(" "),a("li",[a("p",[t._v("降低数据排序的成本，降低CPU的消耗")])])]),t._v(" "),a("p",[a("strong",[t._v("劣势")])]),t._v(" "),a("ul",[a("li",[t._v("索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存")]),t._v(" "),a("li",[t._v("虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行 INSERT、UPDATE 和 DELETE。\n因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，\n都会调整因为更新所带来的键值变化后的索引信息")])])]),t._v(" "),a("blockquote",[a("h5",{attrs:{id:"mysql索引分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引分类"}},[t._v("#")]),t._v(" MySQL索引分类")]),t._v(" "),a("h6",{attrs:{id:"数据结构角度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构角度"}},[t._v("#")]),t._v(" 数据结构角度")]),t._v(" "),a("ul",[a("li",[t._v("B+树索引")]),t._v(" "),a("li",[t._v("Hash索引")]),t._v(" "),a("li",[t._v("R-Tree索引")])]),t._v(" "),a("h6",{attrs:{id:"从物理存储角度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从物理存储角度"}},[t._v("#")]),t._v(" 从物理存储角度")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("聚集索引（clustered index）")])]),t._v(" "),a("li",[a("p",[t._v("非聚集索引（non-clustered index），也叫辅助索引（secondary index）")]),t._v(" "),a("p",[t._v("聚集索引和非聚集索引都是B+树结构")])])]),t._v(" "),a("h6",{attrs:{id:"从逻辑角度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#从逻辑角度"}},[t._v("#")]),t._v(" 从逻辑角度")]),t._v(" "),a("ul",[a("li",[t._v("主键索引：主键索引是一种特殊的唯一索引，不允许有空值")]),t._v(" "),a("li",[t._v("普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引")]),t._v(" "),a("li",[t._v("多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合")]),t._v(" "),a("li",[t._v("唯一索引或者非唯一索引")]),t._v(" "),a("li",[t._v("空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。\nMYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-说一下-mysql-innodb-的索引原理是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说一下-mysql-innodb-的索引原理是什么"}},[t._v("#")]),t._v(" 🎯 说一下 MySQL InnoDB 的索引原理是什么?")]),t._v(" "),a("blockquote",[a("p",[t._v("这就涉及到了好多知识点，我们可以列举几项关键点，说说**"),a("mark",[t._v("索引结构")]),a("strong",[t._v("、")]),a("mark",[t._v("聚簇索引")]),t._v("**")])]),t._v(" "),a("p",[a("strong",[t._v("首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面")]),t._v("。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("B+Tree索引")])]),t._v(" "),a("p",[t._v("InnoDB 的主要索引结构是 B+ 树索引。B+ 树是一种平衡树，每个节点可以有多个子节点。与 B 树不同，B+ 树的所有数据都存储在叶子节点中，叶子节点之间通过指针相连，这使得范围查询和排序操作非常高效。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("聚簇索引 和 非聚簇索引")])])]),t._v(" "),a("li",[a("p",[t._v("InnoDB 中的主键索引就是聚簇索引。聚簇索引将数据行与索引紧密结合在一起，数据行存储在叶子节点中，因此通过主键查找数据非常高效")]),t._v(" "),a("ul",[a("li",[t._v("当你创建一个表并指定主键时，InnoDB 会自动使用主键创建一个聚簇索引。")]),t._v(" "),a("li",[t._v("如果没有显式定义主键，InnoDB 会选择一个唯一的非空索引代替。")]),t._v(" "),a("li",[t._v("如果没有唯一非空索引，InnoDB 会自动生成一个隐藏的行 ID 作为聚簇索引")])])]),t._v(" "),a("li",[a("p",[t._v("辅助索引（也称为二级索引或非聚簇索引）是用于加速对非主键列的查询。辅助索引的叶子节点存储索引列的值以及对应的主键值。")]),t._v(" "),a("p",[t._v("使用辅助索引进行查询时，InnoDB 首先通过辅助索引找到主键值，然后通过主键值在聚簇索引中查找实际数据。这种回表（回查）过程可能增加查询时间，但仍然比全表扫描快得多。")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-为什么要用-b-树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-为什么要用-b-树"}},[t._v("#")]),t._v(" 🎯 为什么要用 B+树？")]),t._v(" "),a("blockquote",[a("p",[t._v("B+ 树 索引相比于其他索引类型的优势？")]),t._v(" "),a("p",[t._v("为什么MySQL 索引中用 B+tree，不用 B-tree 或者其他树，为什么不用 Hash 索引")]),t._v(" "),a("p",[t._v("B-Tree 对比 B+Tree索引")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("B+Tree 相对于 B 树 索引结构的优势：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("B+ 树空间利用率更高：B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。")])]),t._v(" "),a("li",[a("p",[t._v("B 树只适合随机检索，B+Tree 叶子节点采用的是双链表连接，同时支持"),a("strong",[t._v("随机检索和顺序检索")])])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("B+Tree 相对于二叉树索引结构的优势：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("与 B+ 树相比，平衡二叉树、红黑树在同等数据量下，高度更高，性能更差，而且它们会频 繁执行再平衡过程，来保证树形结构平衡")])]),t._v(" "),a("li",[a("p",[t._v("对于有 N 个叶子节点的 B+Tree，其搜索复杂度为"),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"SVG"}},[a("svg",{staticStyle:{"vertical-align":"-0.566ex"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"9.523ex",height:"2.262ex",viewBox:"0 -750 4209 1000"}},[a("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"matrix(1 0 0 -1 0 0)"}},[a("g",{attrs:{"data-mml-node":"math"}},[a("g",{attrs:{"data-mml-node":"mi"}},[a("path",{attrs:{"data-c":"4F",d:"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"}})]),a("g",{attrs:{"data-mml-node":"mo",transform:"translate(763, 0)"}},[a("path",{attrs:{"data-c":"28",d:"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(1152, 0)"}},[a("path",{attrs:{"data-c":"6C",d:"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(1450, 0)"}},[a("path",{attrs:{"data-c":"6F",d:"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(1935, 0)"}},[a("path",{attrs:{"data-c":"67",d:"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(2412, 0)"}},[a("path",{attrs:{"data-c":"64",d:"M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(2932, 0)"}},[a("path",{attrs:{"data-c":"4E",d:"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"}})]),a("g",{attrs:{"data-mml-node":"mo",transform:"translate(3820, 0)"}},[a("path",{attrs:{"data-c":"29",d:"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"}})])])])])]),t._v("，其中 d 表示节点允许的最大子节点个数为 d 个。在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据（这里的查询参考上面 B+Tree 的聚簇索引的查询过程）。")],1),t._v(" "),a("p",[t._v("而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"SVG"}},[a("svg",{staticStyle:{"vertical-align":"-0.566ex"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"8.346ex",height:"2.262ex",viewBox:"0 -750 3689 1000"}},[a("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"matrix(1 0 0 -1 0 0)"}},[a("g",{attrs:{"data-mml-node":"math"}},[a("g",{attrs:{"data-mml-node":"mi"}},[a("path",{attrs:{"data-c":"4F",d:"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"}})]),a("g",{attrs:{"data-mml-node":"mo",transform:"translate(763, 0)"}},[a("path",{attrs:{"data-c":"28",d:"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(1152, 0)"}},[a("path",{attrs:{"data-c":"6C",d:"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(1450, 0)"}},[a("path",{attrs:{"data-c":"6F",d:"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(1935, 0)"}},[a("path",{attrs:{"data-c":"67",d:"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(2412, 0)"}},[a("path",{attrs:{"data-c":"4E",d:"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"}})]),a("g",{attrs:{"data-mml-node":"mo",transform:"translate(3300, 0)"}},[a("path",{attrs:{"data-c":"29",d:"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"}})])])])])]),t._v("，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。")],1)])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("B+Tree 相对于 Hash 表存储结构的优势")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("我们知道范围查询是 MySQL 中常见的场景，但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("B+Tree 相对于 跳表存储结构的优势")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("与B+ 树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期 的查询时间，并且跳表需要更多的内存。")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。")]),t._v(" "),a("p",[t._v("B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。")]),t._v(" "),a("p",[t._v("系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。")]),t._v(" "),a("p",[t._v("InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB。")]),t._v(" "),a("p",[t._v("而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。")]),t._v(" "),a("p",[t._v("B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构。从 B-Tree 结构图中可以看到每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。在 B+Tree 中，"),a("strong",[t._v("所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上")]),t._v("，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/MySQL-B%2BTree-store.png",alt:""}})]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("节点存储内容")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("B-Tree")]),t._v("：每个节点可以存储多个键和多个子节点的指针。键被存储在节点内部，并且可以被多次访问。")]),t._v(" "),a("li",[a("strong",[t._v("B+Tree")]),t._v("：非叶子节点仅存储键作为索引，不存储实际的数据记录，所以"),a("strong",[t._v("适合放入内存中")]),t._v("。所有的数据记录都存储在叶子节点中，并且叶子节点被额外的指针连接在一起，形成一个有序链表。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("查询性能")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("B-Tree")]),t._v("：叶子节点可能包含数据记录，也可能不包含，取决于具体的实现。在查找特定值时，可以在找到对应节点时立即返回结果。")]),t._v(" "),a("li",[a("strong",[t._v("B+Tree")]),t._v("：所有的数据记录都存储在叶子节点中。在查找特定值时，需要访问叶子节点，但因为"),a("strong",[t._v("叶子节点形成了有序链表")]),t._v("，所以"),a("strong",[t._v("范围查询和顺序访问的性能更好")]),t._v("。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("空间效率")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("B-Tree")]),t._v("：因为每个节点存储更多的键和指针，所以每个节点可以有更少的子节点，树的高度可能会更小。")]),t._v(" "),a("li",[a("strong",[t._v("B+Tree")]),t._v("：每个内部节点可以有更多子节点，因为它们只存储键的索引，这使得树更宽、更浅，减少了树的高度，"),a("strong",[t._v("提高了 I/O 效率")]),t._v("。")])])])])]),t._v(" "),a("blockquote",[a("h4",{attrs:{id:"b-tree-性质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-tree-性质"}},[t._v("#")]),t._v(" B+Tree 性质")]),t._v(" "),a("p",[t._v("在数据库中，B+ 树索引结构的高度 "),a("em",[t._v("h")]),t._v(" 直接影响到进行一次索引查找所需的 I/O 次数。这是因为每次 I/O 操作通常只能读取一个磁盘块（或页）的数据。")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("B+ 树高度 h")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("B+树的高度是由树中节点的最大数量决定的，可以通过以下公式近似计算： "),a("mjx-container",{staticClass:"MathJax",attrs:{jax:"SVG"}},[a("svg",{staticStyle:{"vertical-align":"-0.566ex"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"12.927ex",height:"2.262ex",viewBox:"0 -750 5713.6 1000"}},[a("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"matrix(1 0 0 -1 0 0)"}},[a("g",{attrs:{"data-mml-node":"math"}},[a("g",{attrs:{"data-mml-node":"mi"}},[a("path",{attrs:{"data-c":"68",d:"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"}})]),a("g",{attrs:{"data-mml-node":"mo",transform:"translate(853.8, 0)"}},[a("path",{attrs:{"data-c":"2248",d:"M55 319Q55 360 72 393T114 444T163 472T205 482Q207 482 213 482T223 483Q262 483 296 468T393 413L443 381Q502 346 553 346Q609 346 649 375T694 454Q694 465 698 474T708 483Q722 483 722 452Q722 386 675 338T555 289Q514 289 468 310T388 357T308 404T224 426Q164 426 125 393T83 318Q81 289 69 289Q55 289 55 319ZM55 85Q55 126 72 159T114 210T163 238T205 248Q207 248 213 248T223 249Q262 249 296 234T393 179L443 147Q502 112 553 112Q609 112 649 141T694 220Q694 249 708 249T722 217Q722 153 675 104T555 55Q514 55 468 76T388 123T308 170T224 192Q164 192 125 159T83 84Q80 55 69 55Q55 55 55 85Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(1909.6, 0)"}},[a("path",{attrs:{"data-c":"6C",d:"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(2207.6, 0)"}},[a("path",{attrs:{"data-c":"6F",d:"M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(2692.6, 0)"}},[a("path",{attrs:{"data-c":"67",d:"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(3169.6, 0)"}},[a("path",{attrs:{"data-c":"6D",d:"M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"}})]),a("g",{attrs:{"data-mml-node":"mo",transform:"translate(4047.6, 0)"}},[a("path",{attrs:{"data-c":"28",d:"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"}})]),a("g",{attrs:{"data-mml-node":"mi",transform:"translate(4436.6, 0)"}},[a("path",{attrs:{"data-c":"4E",d:"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"}})]),a("g",{attrs:{"data-mml-node":"mo",transform:"translate(5324.6, 0)"}},[a("path",{attrs:{"data-c":"29",d:"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"}})])])])])])],1)]),t._v(" "),a("li",[a("p",[t._v("其中 "),a("em",[t._v("N")]),t._v(" 是树中存储的总记录数，"),a("em",[t._v("m")]),t._v(" 是每个磁盘块（页）可以存储的数据项数量。")])])])])]),t._v(" "),a("p",[t._v("当数据量 N 一定的情况下，m 越大，h 越小；而 m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的（默认 16 KB），如果数据项占的空间越小，数据项的数量越多，树的高度越低。")]),t._v(" "),a("p",[t._v("这就是为什么每个数据项，即索引字段要尽量的小，比如 int 占 4 字节，要比 bigint 8 字节少一半。这也是为什么 B+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。")]),t._v(" "),a("blockquote",[a("p",[t._v("[!NOTE]")]),t._v(" "),a("p",[t._v("在实际应用中，B+树的高度和 I/O 次数会受到许多因素的影响，包括页的大小、数据的分布、索引的选择性等")])]),t._v(" "),a("p",[t._v("当 B+ 树的数据项是复合的数据结构，比如(name,age,sex) 的时候，B+ 树是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F) 这样的数据来检索的时候，B+树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，B+ 树就不知道下一步该查哪个节点，因为建立搜索树的时候name 就是第一个"),a("strong",[t._v("比较因子")]),t._v("，必须要先根据 name 来搜索才能知道下一步去哪里查询。比如当 (张三,F) 这样的数据来检索时，B+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，就是我们说的"),a("strong",[t._v("索引的最左匹配特性")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-说下页分裂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说下页分裂"}},[t._v("#")]),t._v(" 🎯 说下页分裂？")]),t._v(" "),a("blockquote",[a("p",[t._v("InnoDB 的索引是基于 B+ 树实现的，存储单元是 16KB 的页。当一个页的数据写满后，如果需要在其中间插入新数据，InnoDB 会申请新的页，把部分数据迁移过去，并更新父节点指针，这个过程就是“页分裂”。页分裂会带来 "),a("strong",[t._v("性能开销")]),t._v("（申请页、搬迁数据、更新索引）和 "),a("strong",[t._v("空间浪费")]),t._v("（页利用率下降），因此在设计表结构时，推荐使用 "),a("strong",[t._v("自增主键")]),t._v("，减少离散插入，避免频繁页分裂。")])]),t._v(" "),a("p",[a("strong",[t._v("1. 什么是“页”？")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("InnoDB 的最小存储单元")]),t._v("是 "),a("strong",[t._v("页（Page）")]),t._v("，默认大小是 "),a("strong",[t._v("16KB")]),t._v("。")]),t._v(" "),a("li",[t._v("一个索引（不管是聚簇索引还是二级索引），底层都是一个 "),a("strong",[t._v("B+ 树")]),t._v("，每个节点就是一个 "),a("strong",[t._v("页")]),t._v("。")])]),t._v(" "),a("p",[a("strong",[t._v("2. 什么是“页分裂”？")])]),t._v(" "),a("ul",[a("li",[t._v("当 "),a("strong",[t._v("在一个页中插入数据时，空间不足")]),t._v("（16KB 填满了），就会触发 "),a("strong",[t._v("页分裂")]),t._v("。")]),t._v(" "),a("li",[t._v("页分裂过程：\n"),a("ol",[a("li",[t._v("申请一个新的页；")]),t._v(" "),a("li",[t._v("把原来的数据 "),a("strong",[t._v("一部分迁移到新页")]),t._v("；")]),t._v(" "),a("li",[t._v("在父节点更新索引指针。")])])])]),t._v(" "),a("p",[t._v("👉 简单理解：一页塞不下了，就拆成两页，然后更新 B+树结构。")]),t._v(" "),a("p",[a("strong",[t._v("3. 页分裂的触发场景")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("自增主键插入")]),t._v("（推荐方式）：\n插入的数据总是追加到页的末尾，几乎不会引发页分裂（因为新纪录总是在最后一页）。")]),t._v(" "),a("li",[a("strong",[t._v("非自增/离散主键插入")]),t._v("：\n新数据可能插到页的中间，导致页中间腾挪空间，如果塞不下就分裂。")]),t._v(" "),a("li",[a("strong",[t._v("二级索引插入")]),t._v("：\n由于二级索引按字段值排序，也可能导致中间插入，从而引发分裂。")])]),t._v(" "),a("p",[a("strong",[t._v("4. 页分裂的代价")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("性能损耗")]),t._v("：\n"),a("ul",[a("li",[t._v("页分裂需要申请新页、数据搬迁、更新父节点，属于一次 "),a("strong",[t._v("重操作")]),t._v("。")]),t._v(" "),a("li",[t._v("插入效率会下降。")])])]),t._v(" "),a("li",[a("strong",[t._v("空间浪费")]),t._v("：\n"),a("ul",[a("li",[t._v("分裂后可能出现 "),a("strong",[t._v("页利用率下降")]),t._v("（例如原来满页 16KB，分裂后两个页各只有 8KB）。")]),t._v(" "),a("li",[t._v("长期频繁分裂 → 索引树更“高”，查询和维护成本上升。")])])])]),t._v(" "),a("p",[a("strong",[t._v("5. 页合并")])]),t._v(" "),a("ul",[a("li",[t._v("与分裂相反，当删除大量数据后，页空间利用率太低时（小于 50%），InnoDB 会触发 "),a("strong",[t._v("页合并")]),t._v("，把数据重新压缩到一起，减少浪费。")]),t._v(" "),a("li",[t._v("页合并同样需要数据搬迁，也有开销。")])]),t._v(" "),a("p",[a("strong",[t._v("6. 如何减少页分裂？")])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("使用自增主键")]),t._v("：避免在索引中间频繁插入数据，最大限度减少分裂。")]),t._v(" "),a("li",[a("strong",[t._v("控制索引数量")]),t._v("：每个二级索引在写入时都可能分裂，减少不必要的索引。")]),t._v(" "),a("li",[a("strong",[t._v("合理设计字段类型")]),t._v("：让索引页能存放更多记录，降低分裂概率。")]),t._v(" "),a("li",[a("strong",[t._v("批量插入")]),t._v("：避免随机分散插入，尽量顺序写。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-聚集索引与非聚集索引的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-聚集索引与非聚集索引的区别"}},[t._v("#")]),t._v(" 🎯 聚集索引与非聚集索引的区别？")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址?")])]),t._v(" "),a("p",[t._v("聚集索引（Clustered Index）和非聚集索引（Non-clustered Index）是数据库管理系统中常见的两种索引类型，是一种"),a("strong",[t._v("数据存储方式")]),t._v("的区分，特别是在 MySQL 中。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("聚簇索引，也叫“"),a("strong",[t._v("聚集索引")]),t._v("”，表示索引结构和数据一起存放的索引。")])]),t._v(" "),a("li",[a("p",[t._v("非聚集索引是"),a("strong",[t._v("索引结构和数据分开存放的索引")]),t._v("。")])])]),t._v(" "),a("p",[t._v("因为 InnoDB  默认存储引擎的原因，我们说这个一般指的是 InnoDB 中的聚集索引和非聚集索引")]),t._v(" "),a("p",[a("strong",[t._v("InnoDB 引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录")]),t._v("（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，"),a("strong",[t._v("InnoDB 的数据文件本身就是主键索引文件")]),t._v('，这样的索引被称为"“'),a("strong",[t._v("聚簇索引")]),t._v("”，一个表只能有一个聚簇索引。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("InnoDB 聚集索引")]),t._v("：InnoDB 存储引擎使用聚集索引来存储主键列，并且所有非主键列都包含在聚集索引中，这意味着聚集索引实际上包含了整行数据。一个表只能有一个聚簇索引")]),t._v(" "),a("li",[a("strong",[t._v("InnoDB 非聚集索引")]),t._v("：InnoDB 的非聚集索引（也称为辅助索引）首先存储非主键索引列的值，然后通过主键列的值来查找对应的行。这种方式称为“索引的索引”，因为非聚集索引首先查找主键。")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img.starfish.ink/mysql/MySQL-secondary-index.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"🎯-非聚簇索引一定会回表查询吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-非聚簇索引一定会回表查询吗"}},[t._v("#")]),t._v(" 🎯 非聚簇索引一定会回表查询吗?")]),t._v(" "),a("p",[t._v("不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。")]),t._v(" "),a("p",[t._v("举个简单的例子：假设我们在员工表的年龄上建立了索引，那么当进行的查询时,在索引的叶子节点上,已经包含了 age 信息，不会再次进行回表查询。")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("select")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" employee "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v("\n")])])]),a("h3",{attrs:{id:"🎯-innodb-引擎中的索引策略-了解过吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-innodb-引擎中的索引策略-了解过吗"}},[t._v("#")]),t._v(" 🎯 InnoDB 引擎中的索引策略，了解过吗？")]),t._v(" "),a("p",[t._v("InnoDB 索引策略主要包括以下几个方面:")]),t._v(" "),a("ul",[a("li",[t._v("聚簇索引")]),t._v(" "),a("li",[t._v("辅助索引，也就是非聚簇索引")]),t._v(" "),a("li",[t._v("覆盖索引：查询可以直接通过索引获取所需数据，而无需回表查询")]),t._v(" "),a("li",[t._v("前缀索引：用于对较长的字符串列进行索引，只索引字符串的前 N 个字符")]),t._v(" "),a("li",[t._v("全文索引：用于对大文本字段进行全文检索")])]),t._v(" "),a("p",[t._v("每种索引类型都有其独特的用途和优势，通过合理使用这些索引，可以显著提高数据库的查询性能。")]),t._v(" "),a("h3",{attrs:{id:"🎯-使用索引查询一定能提高查询的性能吗-为什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-使用索引查询一定能提高查询的性能吗-为什么"}},[t._v("#")]),t._v(" 🎯 使用索引查询一定能提高查询的性能吗？为什么?")]),t._v(" "),a("blockquote",[a("p",[t._v("其实这个问题也对应的是哪些情况需要建立索引，哪些不需要")]),t._v(" "),a("p",[t._v("使用索引需要注意的几个地方？")])]),t._v(" "),a("p",[t._v("使用索引查询并不一定总能提高查询性能")]),t._v(" "),a("p",[a("strong",[t._v("为什么使用索引通常能提高查询性能：")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("减少需要扫描的数据量来加快数据检索速度")]),t._v(" "),a("ul",[a("li",[t._v("频繁作为查询条件的字段")]),t._v(" "),a("li",[t._v("查询中与其他表关联的字段，外键关系建立索引")]),t._v(" "),a("li",[t._v("在查询涉及的所有列都在索引中时，可以避免回表查询，提高查询效率")])])]),t._v(" "),a("li",[a("p",[t._v("索引可以显著加快 "),a("code",[t._v("ORDER BY")]),t._v(" 和 "),a("code",[t._v("GROUP BY")]),t._v(" 操作")])])]),t._v(" "),a("p",[a("strong",[t._v("为什么在某些情况下索引查询反而可能降低性能")]),t._v("：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("小表或低选择性列")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("小表")]),t._v("：对于行数很少的表，索引带来的性能提升有限，因为全表扫描的开销也很小。索引反而增加了额外的维护开销。")]),t._v(" "),a("p",[a("strong",[t._v("低选择性列")]),t._v('：如果索引列的选择性很低（例如，性别列只有两个值 "M" 和 "F"），使用索引可能会导致大量的行扫描，无法显著减少数据量，索引的效果不明显。')])])])]),t._v(" "),a("li",[a("p",[t._v("经常增删改的表")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("频繁的写操作")]),t._v("：索引不仅在读取数据时加速查询，还在插入、更新和删除操作时带来额外的开销。每次写操作都需要更新索引，索引越多，写操作的开销就越大。")])])]),t._v(" "),a("li",[a("p",[t._v("在高并发环境下，索引也可能导致锁竞争，影响查询性能")])])]),t._v(" "),a("p",[t._v("是否使用索引以及如何设计索引需要根据具体的查询模式、数据量、更新频率、硬件资源等多种因素综合考虑")]),t._v(" "),a("h3",{attrs:{id:"🎯-innodb-表为什么要建议用自增列做主键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-innodb-表为什么要建议用自增列做主键"}},[t._v("#")]),t._v(" 🎯 InnoDB 表为什么要建议用自增列做主键？")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("聚簇索引优化")]),t._v("：自增 ID 的顺序插入让数据在磁盘连续存储，避免页拆分和碎片，提升 IO 效率；")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("B + 树特性匹配")]),t._v("：插入时仅扩展树的最右节点，减少索引分裂开销，范围查询可利用顺序扫描；")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("缓存与锁优化")]),t._v("：顺序插入的新记录使得最近插入的数据很可能在相邻的存储位置，这提高了缓存的命中率。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("缓存友好")]),t._v("：数据库缓存更容易缓存相邻的存储块，从而提高查询的性能，特别是在高并发的读写环境下。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-你们建表会定义自增id么-为什么-自增id用完了怎么办"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-你们建表会定义自增id么-为什么-自增id用完了怎么办"}},[t._v("#")]),t._v(" 🎯 你们建表会定义自增id么，为什么，自增id用完了怎么办?")]),t._v(" "),a("p",[t._v("建表时通常会使用自增 ID 作为主键，因为它在写入性能、存储空间和索引效率上有显著优势。")]),t._v(" "),a("p",[t._v("针对 ID 耗尽问题：首先评估数据规模，小表可重置自增值，核心业务表则升级为 BIGINT（理论可支撑 1.8e19 条数据）；分布式场景用雪花算法，高频删改表可设计 ID 回收机制。")]),t._v(" "),a("h3",{attrs:{id:"🎯-如何写-sql-能够有效的使用到复合索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-如何写-sql-能够有效的使用到复合索引"}},[t._v("#")]),t._v(" 🎯 如何写 SQL 能够有效的使用到复合索引？")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL高效索引")])]),t._v(" "),a("p",[t._v("要有效地使用复合索引（也称为多列索引或组合索引），编写 SQL 查询时需要考虑以下几点：")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("覆盖索引")]),t._v("（Covering Index），或者叫索引覆盖， 也就是平时所说的不需要回表操作")]),t._v(" "),a("ul",[a("li",[t._v("如果查询的列完全包含在复合索引中，那么可以使用覆盖索引，这样可以避免回表查询，提高性能。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("最左前缀法则")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("复合索引的效率取决于查询条件是否遵循最左前缀法则，即从索引的最左边列开始匹配。")])]),t._v(" "),a("li",[a("p",[t._v("例如，如果你有一个 ("),a("code",[t._v("c1")]),t._v(", "),a("code",[t._v("c2")]),t._v(", "),a("code",[t._v("c3")]),t._v(") 的复合索引，那么以下查询可以高效地使用索引：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" c1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'value1'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" c1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'value1'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" c2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'value2'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("如果查询条件不包含 "),a("code",[t._v("c1")]),t._v("，则该复合索引不会被使用。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("索引列的顺序")]),t._v("：在复合索引中，列的顺序很重要。应该将选择性最高的列（即不同值占总行数比例最高的列）放在前面。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("使用索引列作为条件")]),t._v("：确保 WHERE 子句中的条件列与复合索引中的列相匹配，并且顺序正确。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("避免使用函数和表达式")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("如果在 WHERE 子句中对索引列应用了函数或计算，可能会使索引失效。")]),t._v(" "),a("li",[t._v("例如，如果 "),a("code",[t._v("c1")]),t._v(" 是索引的一部分，应避免 "),a("code",[t._v("WHERE UPPER(col1) = 'VALUE'")]),t._v("，而应使用 "),a("code",[t._v("WHERE c1 = 'value'")]),t._v("。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("范围查询和排序")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("复合索引可以用于涉及范围查询的 ORDER BY 和 GROUP BY 子句。")]),t._v(" "),a("li",[t._v("例如，如果有一个 ("),a("code",[t._v("c1")]),t._v(", "),a("code",[t._v("c2")]),t._v(") 的索引，"),a("code",[t._v("ORDER BY c1, c2")]),t._v(" 可以有效地使用索引。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("限制索引的使用")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("使用 "),a("code",[t._v("LIKE")]),t._v(" 操作符进行模糊匹配时，如果模式以通配符（"),a("code",[t._v("%")]),t._v("）开头，索引将不会被使用。")]),t._v(" "),a("li",[t._v("例如，使用 "),a("code",[t._v("WHERE c1 LIKE '%value'")]),t._v(" 将无法利用索引。")])])])]),t._v(" "),a("p",[t._v("考虑查询的实际条件，如数据量大小、表的更新频率等，以确定是否真正需要复合索引。在实际的数据库环境中测试查询性能，并根据查询执行计划（"),a("code",[t._v("EXPLAIN")]),t._v("）来优化索引的使用")]),t._v(" "),a("h3",{attrs:{id:"🎯-数据库不使用索引的几种可能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-数据库不使用索引的几种可能"}},[t._v("#")]),t._v(" 🎯 数据库不使用索引的几种可能？")]),t._v(" "),a("blockquote",[a("p",[t._v("上一个问题的反向问法")])]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("小型表或数据量少")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("全表扫描速度快：对于小型表或数据量较少的表，全表扫描的速度可能与使用索引扫描的速度相当甚至更快，因为读取整个表所需的时间较短。")])]),t._v(" "),a("li",[a("p",[t._v("索引开销大：索引的创建和维护需要额外的存储空间和资源，对小型表来说，这些开销可能超过其带来的性能提升。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据分布不均")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("低选择性：如果某个列的值的重复率很高，例如性别列只有“男”和“女”两种值，使用索引的选择性很低，索引扫描可能比全表扫描更慢。")])]),t._v(" "),a("li",[a("p",[t._v("数据倾斜：数据在某些特定值上高度集中，这种情况下，使用索引可能不会带来显著的性能提升。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("查询模式不适合")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("范围查询")]),t._v("：对于范围查询，例如“BETWEEN”、“>”和“<”，使用索引的效率可能不如期望中的高，因为索引可能需要扫描较多的记录。")]),t._v(" "),a("blockquote",[a("p",[t._v("范围查询，不是一定不会使用索引，成本决定执行计划，优化器会首先针对可能使用到的二级索引划分几个扫描区间，然后分别调查这些区间内有多少条记录，在这些扫描区间内的二级索引记录的总和占总共的记录数量的比例达到某个值时，优化器将放弃使用二级索引执行查询，转而采用全表扫描")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("LIKE 操作")]),t._v("：对于使用通配符“%”在前的LIKE查询（如“%value”），索引无法高效使用，因为数据库需要扫描整个表来找到匹配的值。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("索引未命中")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("函数操作")]),t._v("：在查询条件中使用函数操作（如UPPER(column_name) = 'VALUE'）会导致索引无法被使用，因为索引存储的是原始数据。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("隐式类型转换")]),t._v("：如果列的数据类型与查询条件中的数据类型不一致（如列为整数，但条件中使用字符串），数据库可能进行隐式类型转换，导致索引失效。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据库优化器选择")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("优化器策略")]),t._v("：数据库优化器根据统计信息和查询成本选择执行计划。在某些情况下，优化器可能判断全表扫描比索引扫描更高效。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("统计信息不准确")]),t._v("：如果统计信息不准确或过期，优化器可能做出不合适的决策，选择不使用索引。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("索引维护成本")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("高频更新")]),t._v("：对于高频插入、更新和删除操作的表，索引的维护成本可能较高，影响整体性能。在这种情况下，可能会选择不使用索引或减少索引的数量。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("多列索引的限制")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("索引列顺序")]),t._v("：多列索引只有在按索引列顺序查询时才能被高效使用，如果查询条件中不包含索引的前导列，索引将无法使用。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("查询不完全匹配")]),t._v("：对于复合索引，如果查询条件不完全匹配索引定义，索引的使用效果可能不佳。")])])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-哪些情况会导致索引失效"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-哪些情况会导致索引失效"}},[t._v("#")]),t._v(" 🎯 哪些情况会导致索引失效?")]),t._v(" "),a("p",[t._v("索引失效常见的情况包括：在索引列上使用函数/运算、隐式类型转换、OR 连接不同字段、模糊查询前缀 "),a("code",[t._v("%")]),t._v("、不满足最左前缀原则、使用 "),a("code",[t._v("!=")]),t._v("/"),a("code",[t._v("NOT IN")]),t._v("/"),a("code",[t._v("IS NOT NULL")]),t._v(" 等、范围查询导致后续列失效、ORDER BY / GROUP BY 字段不符合索引顺序、以及数据量太少导致优化器选择全表扫描。")]),t._v(" "),a("p",[t._v("实际项目中，可以通过 "),a("strong",[t._v("EXPLAIN")]),t._v(" 分析执行计划，避免这些写法，并合理设计联合索引。")]),t._v(" "),a("h3",{attrs:{id:"🎯-联合索引abc-现在有个执行语句是-a-xxx-and-c-xxx-索引怎么走"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-联合索引abc-现在有个执行语句是-a-xxx-and-c-xxx-索引怎么走"}},[t._v("#")]),t._v(" 🎯 联合索引ABC，现在有个执行语句是 A = XXX and C < XXX，索引怎么走?")]),t._v(" "),a("p",[t._v("给定查询语句 "),a("code",[t._v("A = XXX AND C < XXX")]),t._v(" 和联合索引 "),a("code",[t._v("(A, B, C)")]),t._v("，我们来分析索引的使用情况：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("精确匹配 "),a("code",[t._v("A")])]),t._v("：\n"),a("ul",[a("li",[t._v("由于条件 "),a("code",[t._v("A = XXX")]),t._v(" 是精确匹配，第一个索引列 "),a("code",[t._v("A")]),t._v(" 将被使用。")])])]),t._v(" "),a("li",[a("strong",[t._v("跳过 "),a("code",[t._v("B")])]),t._v("：\n"),a("ul",[a("li",[t._v("由于查询条件中没有涉及列 "),a("code",[t._v("B")]),t._v("，联合索引的第二列 "),a("code",[t._v("B")]),t._v(" 将被跳过。")])])]),t._v(" "),a("li",[a("strong",[t._v("范围查询 "),a("code",[t._v("C")])]),t._v("：\n"),a("ul",[a("li",[t._v("条件 "),a("code",[t._v("C < XXX")]),t._v(" 是范围查询。根据最左前缀法则和范围查询终止索引使用的规则，虽然条件 "),a("code",[t._v("C < XXX")]),t._v(" 出现在查询中，但因为 "),a("code",[t._v("B")]),t._v(" 没有出现在条件中，所以索引在 "),a("code",[t._v("C")]),t._v(" 列上不能继续有效使用。")])])])]),t._v(" "),a("p",[t._v("在这个查询 "),a("code",[t._v("A = XXX AND C < XXX")]),t._v(" 中，联合索引 "),a("code",[t._v("(A, B, C)")]),t._v(" 只能部分使用，即只会使用索引的第一列 "),a("code",[t._v("A")]),t._v("，后续的 "),a("code",[t._v("B")]),t._v(" 和 "),a("code",[t._v("C")]),t._v(" 列将不会被索引利用。具体来说，执行计划会使用索引 "),a("code",[t._v("(A, B, C)")]),t._v(" 中的 "),a("code",[t._v("(A)")]),t._v(" 进行查找，然后对找到的记录进行筛选以满足 "),a("code",[t._v("C < XXX")]),t._v(" 的条件。")]),t._v(" "),a("h3",{attrs:{id:"🎯-主键索引和唯一索引的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-主键索引和唯一索引的区别"}},[t._v("#")]),t._v(" 🎯 主键索引和唯一索引的区别？")]),t._v(" "),a("p",[t._v("主键索引是特殊的唯一索引，唯一索引查询会涉及到“回表”操作")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("特性")]),t._v(" "),a("th",[t._v("主键索引（Primary Key Index）")]),t._v(" "),a("th",[t._v("唯一索引（Unique Index）")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("唯一性")]),t._v(" "),a("td",[t._v("必须唯一")]),t._v(" "),a("td",[t._v("必须唯一（允许 NULL 值）")])]),t._v(" "),a("tr",[a("td",[t._v("是否允许 NULL")]),t._v(" "),a("td",[t._v("不允许")]),t._v(" "),a("td",[t._v("允许多个 NULL 值「这里 NULL 的定义 ，是指 未知值。 所以多个 NULL ，都是未知的」")])]),t._v(" "),a("tr",[a("td",[t._v("聚簇索引")]),t._v(" "),a("td",[t._v("是（在 InnoDB 中）")]),t._v(" "),a("td",[t._v("否（除非是主键）")])]),t._v(" "),a("tr",[a("td",[t._v("每个表的数量")]),t._v(" "),a("td",[t._v("只能有一个")]),t._v(" "),a("td",[t._v("可以有多个")])]),t._v(" "),a("tr",[a("td",[t._v("主要用途")]),t._v(" "),a("td",[t._v("唯一标识每一行")]),t._v(" "),a("td",[t._v("强制唯一性约束，非主键用途")])]),t._v(" "),a("tr",[a("td",[t._v("创建语法")]),t._v(" "),a("td",[a("code",[t._v("PRIMARY KEY")])]),t._v(" "),a("td",[a("code",[t._v("UNIQUE")])])])])]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" example "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AUTO_INCREMENT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PRIMARY")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("KEY")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    email "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UNIQUE")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INSERT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INTO")]),t._v(" example "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("email"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VALUES")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h3",{attrs:{id:"🎯-索引下推"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-索引下推"}},[t._v("#")]),t._v(" 🎯 索引下推？")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("索引下推（ICP）是 MySQL 5.6 引入的一项优化")]),t._v("，允许在存储引擎层就利用索引字段做部分 "),a("code",[t._v("WHERE")]),t._v(" 条件过滤，从而减少回表次数，降低 I/O。\n例如 "),a("code",[t._v("name LIKE 'J%' AND age=20")]),t._v("，如果有 "),a("code",[t._v("(name, age)")]),t._v(" 联合索引，MySQL 会在存储引擎层就过滤 "),a("code",[t._v("age=20")]),t._v("，避免回表后再判断。\nICP 只对二级索引有效，可以通过 "),a("code",[t._v("EXPLAIN")]),t._v(" 的 "),a("code",[t._v("Using index condition")]),t._v(" 来确认是否生效。")])]),t._v(" "),a("p",[a("strong",[t._v("索引下推（Index Condition Pushdown，ICP）")]),t._v(" 是 MySQL 5.6 中引入的一种优化技术，用于提升范围查询或排序查询的性能。通过索引下推，MySQL 可以减少不必要的表数据行访问，加快查询速度。")]),t._v(" "),a("p",[a("strong",[t._v("1. 索引下推的由来")])]),t._v(" "),a("p",[t._v("在 "),a("strong",[t._v("没有 ICP 之前")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("MySQL 在通过索引扫描时，先拿到索引里的主键 ID；")]),t._v(" "),a("li",[t._v("然后回表到数据页取出完整的行；")]),t._v(" "),a("li",[t._v("最后在 "),a("strong",[t._v("Server 层")]),t._v("做条件过滤。")])]),t._v(" "),a("p",[t._v("这样即使很多行最终不满足条件，也必须 "),a("strong",[t._v("回表取出整行数据")]),t._v("，造成 I/O 浪费。")]),t._v(" "),a("p",[a("strong",[t._v("2. 什么是索引下推？")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("索引下推")]),t._v("就是把部分 "),a("code",[t._v("WHERE")]),t._v(" 条件判断下推到 "),a("strong",[t._v("存储引擎层")]),t._v("，利用索引本身就能获取到的字段提前过滤数据。")]),t._v(" "),a("li",[t._v("这样可以在"),a("strong",[t._v("回表之前就过滤掉不必要的行")]),t._v("，减少回表次数，提高查询效率。")])]),t._v(" "),a("p",[a("strong",[t._v("3. 举个例子")])]),t._v(" "),a("p",[t._v("假设有表：")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CREATE TABLE user (\n    id INT PRIMARY KEY,\n    name VARCHAR(50),\n    age INT,\n    KEY idx_name_age (name, age)\n);\n")])])]),a("p",[t._v("查询：")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM user WHERE name LIKE 'J%' AND age = 20;\n")])])]),a("p",[a("strong",[t._v("没有 ICP 的情况：")])]),t._v(" "),a("ul",[a("li",[a("code",[t._v("name LIKE 'J%'")]),t._v(" 用到索引（范围扫描）。")]),t._v(" "),a("li",[t._v("但 "),a("code",[t._v("age = 20")]),t._v(" 只能在回表后做判断。")]),t._v(" "),a("li",[t._v("即使扫描出来 10 万行 "),a("code",[t._v("name LIKE 'J%'")]),t._v("，也得回表逐条验证 "),a("code",[t._v("age")]),t._v("。")])]),t._v(" "),a("p",[a("strong",[t._v("有 ICP 的情况：")])]),t._v(" "),a("ul",[a("li",[t._v("MySQL 把 "),a("code",[t._v("age = 20")]),t._v(" 条件下推到存储引擎层。")]),t._v(" "),a("li",[t._v("存储引擎在扫描 "),a("code",[t._v("idx_name_age")]),t._v(" 索引时，就能直接判断 "),a("code",[t._v("age")]),t._v("。")]),t._v(" "),a("li",[t._v("这样可能只剩下几百行需要回表，大大减少 I/O。")])]),t._v(" "),a("p",[a("strong",[t._v("4. 哪些场景能触发 ICP？")])]),t._v(" "),a("ul",[a("li",[t._v("只对 "),a("strong",[t._v("二级索引")]),t._v(" 有效（主键索引存的就是全字段，不需要回表）。")]),t._v(" "),a("li",[t._v("查询条件中，"),a("strong",[t._v("部分字段能利用索引顺序")]),t._v("，部分不能利用。")]),t._v(" "),a("li",[t._v("不支持的情况：某些复杂表达式、函数计算等。")])]),t._v(" "),a("p",[a("strong",[t._v("5. 如何确认是否使用了 ICP？")])]),t._v(" "),a("p",[t._v("执行 "),a("code",[t._v("EXPLAIN")]),t._v("，如果 "),a("code",[t._v("Extra")]),t._v(" 列里有：")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Using index condition\n")])])]),a("p",[t._v("说明 MySQL 启用了索引下推。")]),t._v(" "),a("p",[a("strong",[t._v("索引下推的优势")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("减少回表次数")]),t._v("：通过提前过滤不符合条件的记录，减少回表操作。")]),t._v(" "),a("li",[a("strong",[t._v("提升查询效率")]),t._v("：尤其是当索引列上的范围条件命中大量记录，而回表的记录较少时，索引下推可以显著减少不必要的 IO 操作。")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"四、事务与锁机制-🔒"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、事务与锁机制-🔒"}},[t._v("#")]),t._v(" 四、事务与锁机制 🔒")]),t._v(" "),a("p",[t._v("MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！")]),t._v(" "),a("h3",{attrs:{id:"🎯-什么是事务-事务有哪些特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-什么是事务-事务有哪些特性"}},[t._v("#")]),t._v(" 🎯 什么是事务？事务有哪些特性？")]),t._v(" "),a("p",[t._v("事务是由一组 SQL 语句组成的逻辑处理单元，具有 4 个属性，通常简称为事务的 ACID 属性。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("A (Atomicity) 原子性")]),t._v("：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样")]),t._v(" "),a("li",[a("strong",[t._v("C (Consistency) 一致性")]),t._v("：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏")]),t._v(" "),a("li",[a("strong",[t._v("I (Isolation)隔离性")]),t._v("：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰")]),t._v(" "),a("li",[a("strong",[t._v("D (Durability) 持久性")]),t._v("：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚")])]),t._v(" "),a("h3",{attrs:{id:"🎯-什么是脏读、不可重复读和幻读"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-什么是脏读、不可重复读和幻读"}},[t._v("#")]),t._v(" 🎯 什么是脏读、不可重复读和幻读？")]),t._v(" "),a("p",[a("strong",[t._v("并发事务处理带来的问题")])]),t._v(" "),a("ul",[a("li",[t._v("更新丢失（Lost Update)： 事务 A 和事务 B 选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题")]),t._v(" "),a("li",[t._v("脏读(Dirty Reads)：事务 A 读取了事务 B 未提交的数据，然后 B  回滚操作，那么 A 读取到的数据是脏数据")]),t._v(" "),a("li",[t._v("不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。")]),t._v(" "),a("li",[t._v("幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务 A 读取了几行数据，接着另一个并发事务 B 插入了一些数据时。在随后的查询中，事务 A 就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。")])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("幻读和不可重复读的区别：")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("不可重复读的重点是修改")]),t._v("：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）")]),t._v(" "),a("li",[a("strong",[t._v("幻读的重点在于新增或者删除")]),t._v("：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-支持哪些事务隔离级别-各有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-支持哪些事务隔离级别-各有什么区别"}},[t._v("#")]),t._v(" 🎯 MySQL 支持哪些事务隔离级别？各有什么区别？")]),t._v(" "),a("p",[t._v("MySQL 支持四种事务隔离级别，由低到高分别为：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("READ UNCOMMITTED(读未提交)：")]),t._v(" 最低的隔离级别，允许读取尚未提交的数据变更，"),a("strong",[t._v("可能会导致脏读、幻读或不可重复读")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("READ COMMITTED(读已提交)：")]),t._v(" 允许读取并发事务已经提交的数据，"),a("strong",[t._v("可以阻止脏读，但是幻读或不可重复读仍有可能发生")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("REPEATABLE READ(可重复读)：")]),t._v(" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，"),a("strong",[t._v("可以阻止脏读和不可重复读，但幻读仍有可能发生")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("SERIALIZABLE(可串行化)：")]),t._v(" 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，"),a("strong",[t._v("该级别可以防止脏读、不可重复读以及幻读")]),t._v("。")])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("简单点的理解")])]),t._v(" "),a("p",[t._v("读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。")]),t._v(" "),a("p",[t._v("读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。")]),t._v(" "),a("p",[t._v("可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。")]),t._v(" "),a("p",[t._v("串行：我的事务尚未提交，别人就别想改数据。")])]),t._v(" "),a("p",[t._v("查看当前数据库的事务隔离级别：")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("show variables like 'tx_isolation'\n")])])]),a("h3",{attrs:{id:"🎯-mysql-如何实现事务隔离-并发事务处理带来的问题的解决办法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-如何实现事务隔离-并发事务处理带来的问题的解决办法"}},[t._v("#")]),t._v(" 🎯 MySQL 如何实现事务隔离 | 并发事务处理带来的问题的解决办法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("“更新丢失” 通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。")])]),t._v(" "),a("li",[a("p",[t._v("“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：")]),t._v(" "),a("ul",[a("li",[t._v("一种是加"),a("strong",[t._v("锁")]),t._v("：在读取数据前，对其加锁，阻止其他事务对数据进行修改。MySQL 通过行级锁和表级锁来管理并发访问。行级锁包括共享锁（读锁）和排他锁（写锁），表级锁包括意向锁和元数据锁。")]),t._v(" "),a("li",[t._v("另一种是数据"),a("strong",[t._v("多版本并发控制")]),t._v("（MultiVersion Concurrency Control，简称 "),a("strong",[t._v("MVCC")]),t._v("），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。")])])])]),t._v(" "),a("p",[t._v("MySQL InnoDB 存储引擎的默认支持的隔离级别是 "),a("strong",[t._v("REPEATABLE-READ（可重读）")]),t._v("。我们可以通过"),a("code",[t._v("SELECT @@tx_isolation;")]),t._v("命令来查看，MySQL 8.0 该命令改为"),a("code",[t._v("SELECT @@transaction_isolation;")])]),t._v(" "),a("p",[t._v("这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 "),a("strong",[t._v("REPEATABLE-READ（可重读）"),a("strong",[t._v("事务隔离级别下")]),t._v("使用的是 Next-Key Lock 算法，因此可以避免幻读的产生")]),t._v("，这与其他数据库系统(如 SQL Server)是不同的。所以说 InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 **SERIALIZABLE(可串行化)**隔离级别，而且保留了比较好的并发性能。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("Next-Key Locks")]),t._v("：MySQL通过在索引上的间隙加锁（Gap Lock），结合行锁，形成所谓的Next-Key锁，锁定一个范围。这样即使在事务运行期间，其他事务也无法在该范围内插入新的行，从而避免了幻读")])]),t._v(" "),a("p",[t._v("因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是"),a("strong",[t._v("READ-COMMITTED(读已提交):")]),t._v("，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。")]),t._v(" "),a("blockquote",[a("p",[t._v("加锁的基本原则（RR隔离级别下）")]),t._v(" "),a("ul",[a("li",[t._v("原则1：加锁的对象是 next-key lock。（是一个前开后闭的区间）")]),t._v(" "),a("li",[t._v("原则2：查找过程中访问到的对象才加锁")])]),t._v(" "),a("p",[t._v("优化1：唯一索引加锁时，next-key lock 退化为行锁。\n索引上的等值查询，向右遍历时最后一个不满足等值条件的时候，next-key lock 退化为间隙锁\n唯一索引和普通索引在范围查询的时候 都会访问到不满足条件的第一个值为止")])]),t._v(" "),a("h3",{attrs:{id:"🎯-mvcc-熟悉吗-它的底层原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mvcc-熟悉吗-它的底层原理"}},[t._v("#")]),t._v(" 🎯 MVCC 熟悉吗，它的底层原理？")]),t._v(" "),a("p",[t._v("MVCC（Multi-Version Concurrency Control）中文叫做多版本并发控制协议，是 MySQL InnoDB 引擎用于控制数据并发访问的协议。")]),t._v(" "),a("p",[t._v("MVCC 主要是借助于版本链来实现的。")]),t._v(" "),a("p",[t._v("在 InnoDB 引擎里面，每一行都有两个额外的列，一个是 trx_id，代表的是修改这一行数据的事务 ID。另外一个是 roll_ptr，代表的是回滚指针。")]),t._v(" "),a("p",[t._v("InnoDB 引擎通过回滚指针，将数据的不同版本串联在一起，也就是版本链。这些串联起来的历史版本，被放到了 undolog 里面。当某一个事务发起查询的时候，MVCC 会根据事务的隔离级别来生成不同的 Read View，从而控制事务查询最终得到的结果。")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL 的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。")]),t._v(" "),a("p",[t._v("多版本并发控制（MVCC, Multi-Version Concurrency Control）是一种用于处理数据库并发操作的机制，它允许多个事务同时读取和写入数据，而"),a("strong",[t._v("不会互相阻塞")]),t._v("。MVCC 通过为每个事务提供数据的不同版本来实现，并确保每个事务都能看到一致的数据快照")]),t._v(" "),a("p",[t._v("可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。")]),t._v(" "),a("p",[a("strong",[t._v("核心概念")])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("快照读（Snapshot Read）")]),t._v("：\n"),a("ul",[a("li",[t._v("每个事务在开始时，会获取一个数据快照，事务在读取数据时，总是读取该快照中的数据。")]),t._v(" "),a("li",[t._v("这意味着即使在事务进行期间，其他事务对数据的更新也不会影响当前事务的读取。")])])]),t._v(" "),a("li",[a("strong",[t._v("版本链（Version Chain）")]),t._v("：\n"),a("ul",[a("li",[t._v("每个数据行都有多个版本，每个版本包含数据和元数据（如创建时间、删除时间等）。")]),t._v(" "),a("li",[t._v("新版本的数据行会被链接到旧版本的数据行，形成一个版本链。")])])]),t._v(" "),a("li",[a("strong",[t._v("隐式锁（Implicit Locking）")]),t._v("：\n"),a("ul",[a("li",[t._v("MVCC 通过版本管理避免了显式锁定，减少了锁争用问题。")]),t._v(" "),a("li",[t._v("对于读取操作，事务读取其开始时的快照数据，不会被写操作阻塞。")])])])]),t._v(" "),a("p",[t._v("MySQL InnoDB 存储引擎使用 MVCC 来实现可重复读（REPEATABLE READ）隔离级别，避免脏读、不可重复读和幻读问题。具体机制如下：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("隐藏列")]),t._v("：\n"),a("ul",[a("li",[t._v("InnoDB 在每行记录中存储两个隐藏列："),a("code",[t._v("trx_id")]),t._v("（事务ID，也叫做事务版本号）和"),a("code",[t._v("roll_pointer")]),t._v("（回滚指针）。")]),t._v(" "),a("li",[a("code",[t._v("trx_id")]),t._v(" 记录最后一次修改该行的事务ID，"),a("code",[t._v("roll_pointer")]),t._v(" 指向该行的上一版本，把每一行的历史版本串联在一起。")])])]),t._v(" "),a("li",[a("strong",[t._v("Undo日志")]),t._v("：\n"),a("ul",[a("li",[t._v("每次数据更新时，InnoDB 会在 Undo 日志中记录旧版本数据。")]),t._v(" "),a("li",[t._v("如果需要读取旧版本数据，InnoDB 会通过 "),a("code",[t._v("roll_pointer")]),t._v(" 找到 Undo 日志中的旧版本。")])])]),t._v(" "),a("li",[a("strong",[t._v("一致性视图（Consistent Read View）")]),t._v("：\n"),a("ul",[a("li",[t._v("InnoDB 为每个事务创建一致性视图，记录当前活动的所有事务ID。")]),t._v(" "),a("li",[t._v("读取数据时，会根据一致性视图决定哪些版本的数据对当前事务可见。")])])])])]),t._v(" "),a("p",[a("strong",[t._v("MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作")]),t._v("。")]),t._v(" "),a("blockquote",[a("h4",{attrs:{id:"mvcc-解决了什么问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvcc-解决了什么问题"}},[t._v("#")]),t._v(" MVCC 解决了什么问题")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("读写不冲突，极大的增加了系统的并发性能")])]),t._v(" "),a("li",[a("p",[t._v("解决脏读，幻读，不可重复读 等问题（注:其实多版本只是解决不可重复读问题，而加上临界（"),a("strong",[t._v("next-key")]),t._v("）锁(也就是它这里所谓的并发控制)才解决了幻读问题。）")]),t._v(" "),a("p",[a("strong",[t._v("Next-Key Locking")]),t._v(" 是行锁和间隙锁的组合，它锁定的是索引记录以及其附近的间隙，防止其他事务在查询范围内插入或删除记录，确保当前事务在后续的查询中不会看到“幻影”。")]),t._v(" "),a("p",[t._v("举例：如果事务A查询了范围 "),a("code",[t._v("WHERE age BETWEEN 18 AND 25")]),t._v("，Next-Key Locking 会锁定已经存在的记录以及这个范围的间隙，防止其他事务在这个范围内插入新数据")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("InnoDB下的Compact行结构，有三个隐藏的列")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("列名")]),t._v(" "),a("th",[t._v("是否必须")]),t._v(" "),a("th",[t._v("描述")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("row_id")]),t._v(" "),a("td",[t._v("否")]),t._v(" "),a("td",[t._v("行ID，唯一标识一条记录（如果定义主键，它就没有啦）")])]),t._v(" "),a("tr",[a("td",[t._v("transaction_id")]),t._v(" "),a("td",[t._v("是")]),t._v(" "),a("td",[t._v("事务ID")])]),t._v(" "),a("tr",[a("td",[t._v("roll_pointer")]),t._v(" "),a("td",[t._v("是")]),t._v(" "),a("td",[t._v("DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本")])])])])]),t._v(" "),a("blockquote",[a("p",[t._v("在可重复读（Repeatable Read）隔离级别下，MySQL的InnoDB存储引擎通过多版本并发控制（MVCC）和next-key锁机制在很大程度上减少了幻读的发生，但并没有完全消除幻读的可能性。")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("快照读（Snapshot Read）")]),t._v("：在可重复读隔离级别下，InnoDB使用MVCC来处理普通的SELECT查询。MVCC通过为每个事务创建一个Read View，使得事务在其执行期间看到的是一致的快照数据，即使其他事务在这段时间内插入了新记录，当前事务的查询也不会看到这些新记录。这通常可以避免幻读。")]),t._v(" "),a("li",[a("strong",[t._v("当前读（Current Read）")]),t._v("：对于需要锁定结果集的查询，如SELECT ... FOR UPDATE或SELECT ... IN SHARE MODE，InnoDB使用next-key锁，这是记录锁和间隙锁的组合。这种锁机制可以防止其他事务在锁定的范围内插入新记录，从而避免幻读。")])]),t._v(" "),a("p",[t._v("然而，根据搜索结果中的讨论，即使在可重复读隔离级别下，仍然存在一些特殊情况可能导致幻读：")]),t._v(" "),a("ul",[a("li",[t._v("如果事务在执行快照读之后，立即执行更新操作，可能会看到其他事务插入的新记录，因为更新操作会检查最新版本的数据。")]),t._v(" "),a("li",[t._v("如果事务在执行当前读之前，其他事务已经提交了插入操作，那么当前读可能会观察到这些新记录。")])]),t._v(" "),a("p",[t._v("因此，虽然InnoDB的可重复读隔离级别提供了强有力的幻读保护，但在某些特殊情况下，幻读仍然可能发生。开发者需要了解这些情况，并在必要时采取额外的措施来确保数据的一致性和隔离性。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-当前读与快照读的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-当前读与快照读的区别"}},[t._v("#")]),t._v(" 🎯 当前读与快照读的区别？")]),t._v(" "),a("blockquote",[a("p",[t._v("在 InnoDB 中，普通的 "),a("code",[t._v("SELECT")]),t._v(" 是快照读，它基于 MVCC 从 undo log 里读取历史版本，不加锁，性能高；而带锁的查询（如 "),a("code",[t._v("SELECT ... FOR UPDATE")]),t._v("）以及 "),a("code",[t._v("UPDATE/DELETE/INSERT")]),t._v(" 属于当前读，它会加锁并返回记录的最新版本，用来保证数据一致性。")])]),t._v(" "),a("p",[a("strong",[t._v("1. 快照读（Snapshot Read）")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("定义")]),t._v("：读取的是数据的 "),a("strong",[t._v("快照版本")]),t._v("（历史版本），不加锁。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("实现机制")]),t._v("：依赖 InnoDB 的 "),a("strong",[t._v("MVCC（多版本并发控制）")]),t._v("，通过 "),a("code",[t._v("undo log")]),t._v(" 保存旧版本数据，根据事务的隔离级别和 Read View 来决定能看到哪一条版本。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("特点")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("不加锁，读写不冲突 → 性能好。")]),t._v(" "),a("li",[t._v("可能读到旧数据（取决于隔离级别：RC、RR）。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("常见 SQL 场景")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM user WHERE id = 1;\n")])])]),a("p",[t._v("（普通的 "),a("code",[t._v("SELECT")]),t._v("，没有加 "),a("code",[t._v("for update / lock in share mode")]),t._v("）")])])]),t._v(" "),a("p",[a("strong",[t._v("2. 当前读（Current Read）")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("定义")]),t._v("：读取的是 "),a("strong",[t._v("记录的最新版本")]),t._v("，并且会加锁（保证数据一致性）。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("实现机制")]),t._v("：通过加锁（共享锁 / 排他锁）来保证读取的是最新值，阻塞其他事务的修改，避免并发问题。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("特点")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("读取最新数据，带有锁。")]),t._v(" "),a("li",[t._v("和写操作冲突时会等待或死锁。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("常见 SQL 场景")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM user WHERE id = 1 FOR UPDATE;   -- 排他锁\nSELECT * FROM user WHERE id = 1 LOCK IN SHARE MODE; -- 共享锁\nUPDATE user SET name = 'Tom' WHERE id = 1;   -- 写操作，本质也是当前读\nDELETE FROM user WHERE id = 1;\nINSERT INTO user VALUES (...);\n")])])])])]),t._v(" "),a("p",[a("strong",[t._v("3. 核心区别总结")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("对比点")]),t._v(" "),a("th",[t._v("快照读（Snapshot Read）")]),t._v(" "),a("th",[t._v("当前读（Current Read）")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[t._v("是否加锁")])]),t._v(" "),a("td",[t._v("不加锁")]),t._v(" "),a("td",[t._v("加锁（共享/排他）")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("读的数据")])]),t._v(" "),a("td",[t._v("历史版本（符合隔离级别的可见性规则）")]),t._v(" "),a("td",[t._v("最新版本")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("性能")])]),t._v(" "),a("td",[t._v("高，读写不冲突")]),t._v(" "),a("td",[t._v("较低，可能阻塞")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("典型场景")])]),t._v(" "),a("td",[t._v("普通 "),a("code",[t._v("SELECT")])]),t._v(" "),a("td",[a("code",[t._v("SELECT … FOR UPDATE")]),t._v("、"),a("code",[t._v("UPDATE")]),t._v("、"),a("code",[t._v("DELETE")])])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-版本链问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-版本链问题"}},[t._v("#")]),t._v(" 🎯 版本链问题？")]),t._v(" "),a("p",[t._v("我现在有三个事务，ID 分别是 101、102、103。如果事务 101 已经提交了，但是 102、103 还没提交。这个时候，我开启了一个事务，准备读取数据，那么我读到的是哪个事务的数据？如果这时候事务 103 提交了，但是 102 还没提交，那么会读到谁的呢？")]),t._v(" "),a("p",[t._v("这种题，就和隔离级别有关系了。")]),t._v(" "),a("p",[t._v("在MVCC机制中，事务读取数据的可见性取决于事务的隔离级别和事务的开始时间。以下是根据你描述的情况，按照可重复读（Repeatable Read）隔离级别来分析：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("事务101已提交，事务102和103未提交时开启新事务读取数据")]),t._v("：\n"),a("ul",[a("li",[t._v("当你开启一个新的事务时，这个事务会创建一个Read View。Read View会根据事务的隔离级别来确定哪些数据版本是可见的。在可重复读隔离级别下，新事务的Read View将只能看到在该事务开始之前已经提交的事务所做的修改。因此，如果你的新事务是在事务102和103提交之前开启的，你将能够读取到事务101提交的数据，但是看不到事务102和103的修改。")])])]),t._v(" "),a("li",[a("strong",[t._v("事务103提交后，但事务102还未提交时读取数据")]),t._v("：\n"),a("ul",[a("li",[t._v("如果在新事务的Read View创建之后，事务103提交了，那么在可重复读隔离级别下，新事务的Read View已经创建完成，它不会包含事务103提交后的数据。因此，即使你的新事务在事务103提交后读取数据，你仍然不会看到事务103的修改，除非你的新事务重新启动并创建一个新的Read View。")])])])]),t._v(" "),a("p",[t._v("在可重复读隔离级别下，新事务读取的数据版本是基于事务开始时数据库的快照，这个快照包括了所有在此之前已经提交的事务的修改。一旦Read View创建，即使其他事务提交了，新事务也不会看到这些新提交的修改，除非新事务重新启动并创建一个新的Read View。")]),t._v(" "),a("p",[t._v("需要注意的是，如果隔离级别是读已提交（Read Committed），情况会有所不同。在这种情况下，每次读取操作都会看到最新的提交事务的结果，所以如果事务103提交了，即使新事务已经开启，它在读取数据时也会看到事务103的修改。")]),t._v(" "),a("h3",{attrs:{id:"🎯-简单说下事务日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-简单说下事务日志"}},[t._v("#")]),t._v(" 🎯 简单说下事务日志？")]),t._v(" "),a("p",[t._v("InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。")]),t._v(" "),a("p",[t._v("事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。")]),t._v(" "),a("p",[t._v("InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。")]),t._v(" "),a("p",[t._v("InnoDB 用日志把随机 IO 变成顺序 IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。")]),t._v(" "),a("p",[t._v("InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。")]),t._v(" "),a("p",[t._v("事务日志可以帮助提高事务效率：")]),t._v(" "),a("ul",[a("li",[t._v("使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。")]),t._v(" "),a("li",[t._v("事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。")]),t._v(" "),a("li",[t._v("事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。")]),t._v(" "),a("li",[t._v("如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。")])]),t._v(" "),a("p",[t._v("目前来说，大多数存储引擎都是这样实现的，我们通常称之为"),a("strong",[t._v("预写式日志")]),t._v("（Write-Ahead Logging），修改数据需要写两次磁盘。")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-事务的-acid-实现原理-事务的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-事务的-acid-实现原理-事务的实现"}},[t._v("#")]),t._v(" 🎯 MySQL 事务的 ACID 实现原理？ | 事务的实现？")]),t._v(" "),a("p",[t._v("事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。")]),t._v(" "),a("p",[t._v("事务的实现就是如何实现 ACID 特性。")]),t._v(" "),a("p",[t._v("事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("还看到一种说法")]),t._v("：")]),t._v(" "),a("p",[t._v("从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说 ACID 四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。例如，原子性无法保证，显然一致性也无法保证。")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("原子性保证："),a("code",[t._v("undo log")]),t._v(" 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息。")])]),t._v(" "),a("li",[a("p",[t._v("持久性保证：持久性主要通过 redo log 和数据文件的刷新（flush）来实现。InnoDB 存储引擎在事务提交时会将 redo log 写入到磁盘，确保更改可以被恢复")])]),t._v(" "),a("li",[a("p",[t._v("隔离性保证：MySQL 支持不同的事务隔离级别，隔离级别的实现依赖于锁机制和多版本并发控制（MVCC）。")])]),t._v(" "),a("li",[a("p",[t._v("一致性保证：MySQL 通过约束（如主键、外键、检查约束等）、触发器和存储过程等来维护数据的完整性和一致性。")])])]),t._v(" "),a("blockquote",[a("p",[t._v("分布式事务相关问题，可能还会问到 2PC、3PC，，，")])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-对分布式事务的支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-对分布式事务的支持"}},[t._v("#")]),t._v(" 🎯 MySQL 对分布式事务的支持")]),t._v(" "),a("p",[t._v("分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。")]),t._v(" "),a("p",[t._v("MySQL 从 5.0.3  InnoDB 存储引擎开始支持 XA 协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。")]),t._v(" "),a("p",[t._v("以下是 MySQL 对分布式事务支持的几个关键点：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("XA 事务")]),t._v("：MySQL 的 InnoDB 存储引擎支持 XA 事务，这是分布式事务处理的基础。XA 事务允许跨多个数据库实例的事务操作，要么全部提交，要么全部回滚，以保持数据的一致性。")]),t._v(" "),a("li",[a("strong",[t._v("两阶段提交")]),t._v("：XA 事务使用两阶段提交协议来确保事务的原子性和一致性。在第一阶段，所有的参与资源（如不同的数据库实例）准备提交事务；在第二阶段，根据第一阶段的准备结果，决定是提交还是回滚事务。")]),t._v(" "),a("li",[a("strong",[t._v("隔离级别")]),t._v("：在使用 XA 事务时，InnoDB 存储引擎的事务隔离级别必须设置为 "),a("code",[t._v("SERIALIZABLE")]),t._v("，这是最高的隔离级别，可以避免脏读、不可重复读和幻读。")]),t._v(" "),a("li",[a("strong",[t._v("XA 语法")]),t._v("：MySQL 支持 XA 事务的特定语法，包括 "),a("code",[t._v("XA START")]),t._v("、"),a("code",[t._v("XA END")]),t._v("、"),a("code",[t._v("XA PREPARE")]),t._v("、"),a("code",[t._v("XA COMMIT")]),t._v(" 和 "),a("code",[t._v("XA ROLLBACK")]),t._v(" 等命令，用于控制分布式事务的流程。")]),t._v(" "),a("li",[a("strong",[t._v("事务管理器和资源管理器")]),t._v("：在 XA 事务中，事务管理器（TM）负责协调全局事务，而资源管理器（RM）负责管理具体的事务资源，如数据库连接。")]),t._v(" "),a("li",[a("strong",[t._v("分布式事务的问题")]),t._v("：XA 事务可能面临一些问题，如超时、死锁和资源管理器故障等。此外，MySQL 中的 XA 事务在早期版本中存在一些限制，比如在服务器故障重启后，已准备的事务的二进制日志可能会丢失，导致主从复制的数据不一致问题。")]),t._v(" "),a("li",[a("strong",[t._v("MySQL 5.7 改进")]),t._v("：在 MySQL 5.7 版本中，对分布式事务的支持有所改进，解决了一些长期存在的问题，比如在客户端退出或服务宕机时，已准备的事务会被正确回滚，以及在服务器故障重启后，相应的 Binlog 被正确处理。")]),t._v(" "),a("li",[a("strong",[t._v("应用场景")]),t._v("：分布式事务在分布式架构或需要跨多个数据库系统进行数据同步的场景中比较常见，例如金融行业的转账操作。")])]),t._v(" "),a("p",[t._v("总的来说，MySQL 通过 XA 事务为分布式系统提供了强大的事务支持，确保了跨多个数据库实例的操作能够满足 ACID 原则。随着 MySQL 版本的更新，分布式事务的支持也在不断改进和增强。")]),t._v(" "),a("blockquote",[a("p",[t._v("关于分布式事务，首先你需要弄清楚一个东西，就是分布式事务既可以是纯粹多个数据库实例之间的分布式事务，也可以是跨越不同中间件的业务层面上的分布式事务。前者一般是分库分表中间件提供支持，后者一般是独立的第三方中间件提供支持，比如 Seata。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-在单体应用拆分成微服务架构之后-你怎么解决分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-在单体应用拆分成微服务架构之后-你怎么解决分布式事务"}},[t._v("#")]),t._v(" 🎯 在单体应用拆分成微服务架构之后，你怎么解决分布式事务？")]),t._v(" "),a("p",[a("strong",[t._v("常见的解决方案")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("最终一致性：")]),t._v(' "最理想的解决方案是通过最终一致性来避免分布式事务。可以通过事件驱动架构、异步消息和服务之间的解耦来处理。每个服务都处理自己的事务，当一个服务完成业务操作后，它会发布一个事件，其他服务订阅并处理相应的事件，逐步确保数据一致性。最终一致性容忍系统中的暂时不一致，但它能有效避免长时间的锁定和事务阻塞问题。"')]),t._v(" "),a("li",[a("strong",[t._v("Saga模式：")]),t._v(' "Saga模式是解决分布式事务的一种常见方法，它将长事务拆分成多个局部事务，每个局部事务都会发布事件。如果某个事务失败，系统会触发补偿事务来回滚之前的操作。Saga模式有两种实现方式：一种是基于长事务的补偿机制，另一种是基于事件驱动的方式，适用于更高并发的环境。通过Saga模式，我们可以避免分布式事务中常见的性能瓶颈。"')]),t._v(" "),a("li",[a("strong",[t._v("两阶段提交（2PC）：")]),t._v(' "两阶段提交（2PC）是一种经典的分布式事务解决方案，它通过协调者保证所有参与者在提交事务前的一致性。然而，2PC有一个显著的问题，就是在网络分区或者某些参与者失败时，容易导致系统的阻塞。这使得它不适合高并发和高可用的微服务环境。"')]),t._v(" "),a("li",[a("strong",[t._v("三阶段提交（3PC）：")]),t._v(' "三阶段提交是2PC的改进，旨在解决2PC中的阻塞问题。它引入了准备阶段、提交阶段和确认阶段来确保系统的一致性。尽管比2PC更安全，但在高并发场景下仍然会对性能造成影响。"')]),t._v(" "),a("li",[a("strong",[t._v("TCC模式：")]),t._v(' "TCC（Try-Confirm/Cancel）模式将每个操作分为三个阶段：尝试阶段（Try）、确认阶段（Confirm）和取消阶段（Cancel）。如果所有操作都成功，执行确认，失败则执行取消操作回滚之前的所有操作。这种模式适用于复杂的分布式事务场景，确保每个操作的最终一致性。”')])]),t._v(" "),a("p",[a("strong",[t._v("强调最佳实践与策略：")]),t._v(' "在实际应用中，我会根据具体的业务场景选择合适的解决方案。如果业务逻辑允许，我倾向于通过'),a("strong",[t._v("最终一致性")]),t._v("和"),a("strong",[t._v("事件驱动架构")]),t._v("来避免复杂的分布式事务管理。如果需要严格的一致性保障，可以选择"),a("strong",[t._v("Saga模式")]),t._v("，它能较好地平衡可用性与一致性。"),a("strong",[t._v("TCC模式")]),t._v("适用于事务较为复杂的场景，尤其是在资金交易类系统中。”")]),t._v(" "),a("h3",{attrs:{id:"mysql-锁机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mysql-锁机制"}},[t._v("#")]),t._v(" MySQL 锁机制")]),t._v(" "),a("p",[t._v("锁是计算机协调多个进程或线程并发访问某一资源的机制。")]),t._v(" "),a("p",[t._v("在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。")]),t._v(" "),a("p",[t._v("打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？这里肯定要用到事务，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。")]),t._v(" "),a("p",[t._v("在 MySQL 的 InnoDB 引擎里面，锁是借助索引来实现的。或者说，加锁锁住的其实是索引项，更加具体地来说，就是锁住了"),a("strong",[t._v("叶子节点")])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("锁的物理载体")]),t._v("：B+树索引节点（非数据页）")]),t._v(" "),a("li",[a("strong",[t._v("锁升级条件")]),t._v("：无索引或索引失效时退化为表锁")]),t._v(" "),a("li",[a("strong",[t._v("锁兼容性")]),t._v("：共享锁（S锁）允许并行读，排他锁（X锁）独占写")])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-中有哪几种锁-列举一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-中有哪几种锁-列举一下"}},[t._v("#")]),t._v(" 🎯 MySQL 中有哪几种锁，列举一下？")]),t._v(" "),a("p",[a("strong",[t._v("从对数据操作的类型分类")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("读锁")]),t._v("（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("写锁")]),t._v("（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁")])])]),t._v(" "),a("p",[a("strong",[t._v("从对数据操作的粒度分类")]),t._v("：")]),t._v(" "),a("p",[t._v("为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("表级锁")]),t._v("：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("行级锁")]),t._v("：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("页面锁")]),t._v("：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。")])])]),t._v(" "),a("p",[t._v("适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th"),t._v(" "),a("th",[t._v("行锁")]),t._v(" "),a("th",[t._v("表锁")]),t._v(" "),a("th",[t._v("页锁")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("MyISAM")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("√")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("BDB")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("√")]),t._v(" "),a("td",[t._v("√")])]),t._v(" "),a("tr",[a("td",[t._v("InnoDB")]),t._v(" "),a("td",[t._v("√")]),t._v(" "),a("td",[t._v("√")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("Memory")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("√")]),t._v(" "),a("td")])])]),t._v(" "),a("blockquote",[a("h5",{attrs:{id:"myisam-表锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#myisam-表锁"}},[t._v("#")]),t._v(" MyISAM 表锁")]),t._v(" "),a("p",[t._v("MyISAM 的表锁有两种模式：")]),t._v(" "),a("ul",[a("li",[t._v("表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；")]),t._v(" "),a("li",[t._v("表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；")])]),t._v(" "),a("p",[t._v("MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。")]),t._v(" "),a("p",[t._v("默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。")]),t._v(" "),a("h5",{attrs:{id:"innodb-行锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb-行锁"}},[t._v("#")]),t._v(" InnoDB 行锁")]),t._v(" "),a("p",[t._v("InnoDB 实现了以下两种类型的"),a("strong",[t._v("行锁")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("共享锁又称为读锁，简称  S 锁，顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。")])]),t._v(" "),a("li",[a("p",[t._v("排他锁又称为写锁，简称 X 锁，顾名思义，排他锁就是不能与其他所并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。")])])]),t._v(" "),a("p",[t._v("为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是"),a("strong",[t._v("表锁")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。")]),t._v(" "),a("li",[t._v("意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。")])]),t._v(" "),a("p",[a("strong",[t._v("索引失效会导致行锁变表锁")]),t._v("。比如 varchar 查询不写单引号的情况。")]),t._v(" "),a("p",[a("strong",[t._v("InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-中-innodb-引擎的行锁是怎么实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-中-innodb-引擎的行锁是怎么实现的"}},[t._v("#")]),t._v(" 🎯 MySQL 中 InnoDB 引擎的行锁是怎么实现的？")]),t._v(" "),a("blockquote",[a("p",[t._v("锁模式(InnoDB有三种行锁的算法)")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("记录锁(Record Locks)")]),t._v("： 单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM table WHERE id = 1 FOR UPDATE;\n")])])]),a("p",[t._v("它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行")]),t._v(" "),a("p",[t._v("在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-- id 列为主键列或唯一索引列\nUPDATE SET age = 50 WHERE id = 1;\n")])])]),a("p",[t._v("但是如果查询条件没有命中任何记录，那么就不会使用记录锁，而是使用间隙锁。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("间隙锁（Gap Locks）")]),t._v("： 当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。")]),t._v(" "),a("p",[t._v("InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。")]),t._v(" "),a("p",[t._v("对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。")]),t._v(" "),a("p",[t._v("间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的"),a("code",[t._v("Next-Key Locking")]),t._v(" 算法，请务必牢记："),a("strong",[t._v("使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据")]),t._v("。")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM table WHERE id BETWEN 1 AND 10 FOR UPDATE;\n")])])]),a("p",[t._v("即所有在"),a("code",[t._v("（1，10）")]),t._v("区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。")]),t._v(" "),a("blockquote",[a("p",[t._v("假设表中存在以下id值的记录：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("0, 5, 11, 15\n")])])]),a("p",[t._v("对于给定的查询，InnoDB会产生以下间隙锁：")]),t._v(" "),a("ol",[a("li",[t._v("(0, 5)：0和5之间的间隙：防止在1到4范围内插入新记录")]),t._v(" "),a("li",[t._v("(5, 11)：5和11之间的间隙：防止在6到10范围内插入新记录")])]),t._v(" "),a("p",[t._v("此外，还会有以下锁：")]),t._v(" "),a("ul",[a("li",[t._v("在id=5的记录上的记录锁（Record Lock）：防止其他事务修改或删除id=5的记录")]),t._v(" "),a("li",[t._v("(负无穷, 0]和[11, 正无穷)的 Next-Key Lock，可以插入 -1 或 12 。。。")])])]),t._v(" "),a("p",[t._v("GAP 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("临键锁(Next-key Locks)")]),t._v("： "),a("strong",[t._v("临键锁")]),t._v("，是"),a("strong",[t._v("记录锁与间隙锁的组合")]),t._v("，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免"),a("strong",[t._v("幻读")]),t._v("(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。)")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM table WHERE id BETWEEN 50 AND 100 FOR UPDATE\n")])])]),a("p",[t._v("Next-Key 可以理解为一种特殊的"),a("strong",[t._v("间隙锁")]),t._v("，也可以理解为一种特殊的"),a("strong",[t._v("算法")]),t._v("。通过"),a("strong",[t._v("临建锁")]),t._v("可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，"),a("mark",[a("code",[t._v("InnoDB")]),t._v(" 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁")]),t._v("。。当查询的索引含有唯一属性（如唯一索引或主键索引）时，InnoDB 存储引擎会对 next-key lock 进行优化，将其降为 record lock，即仅锁住索引本身，而不是范围。")]),t._v(" "),a("p",[t._v("对于行的查询，都是采用该方法，主要目的是解决幻读的问题。")])])]),t._v(" "),a("p",[t._v("间隙锁和临键锁是在可重复读的隔离级别下才有效果的。")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-隔离级别与锁的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-隔离级别与锁的关系"}},[t._v("#")]),t._v(" 🎯 MySQL 隔离级别与锁的关系？")]),t._v(" "),a("p",[t._v("在 MySQL 中，隔离级别和锁的关系紧密相关，不同的隔离级别通过使用不同的锁机制来控制事务间的并发行为，确保数据的一致性和隔离性。以下是 MySQL 四种隔离级别与锁的关系：")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("读未提交（Read Uncommitted）")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("锁机制：最低级别，不使用锁，允许读取未提交的数据。")])]),t._v(" "),a("li",[a("p",[t._v("并发性：高。")])]),t._v(" "),a("li",[a("p",[t._v("数据一致性：低，可能导致脏读。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("读已提交（Read Committed）")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("锁机制：读取时使用共享锁（S Lock），更新时使用排他锁（X Lock）。")])]),t._v(" "),a("li",[a("p",[t._v("并发性：中等。")])]),t._v(" "),a("li",[a("p",[t._v("数据一致性：避免脏读，但可能发生不可重复读。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("可重复读（Repeatable Read）")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("锁机制：读取时使用共享锁（S Lock），更新时使用排他锁（X Lock），并使用间隙锁（Gap Lock）防止幻读。")])]),t._v(" "),a("li",[a("p",[t._v("并发性：较低。")])]),t._v(" "),a("li",[a("p",[t._v("数据一致性：避免脏读和不可重复读，但在默认设置下防止幻读。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("串行化（Serializable）")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("锁机制：事务间完全隔离，所有读取和写入都使用表级锁或行级锁，确保完全隔离。")])]),t._v(" "),a("li",[a("p",[t._v("并发性：最低。")])]),t._v(" "),a("li",[a("p",[t._v("数据一致性：最高，避免所有并发问题。")])])])])]),t._v(" "),a("p",[t._v("选择适当的隔离级别和锁机制，可以在数据一致性和系统并发性之间找到最佳平衡。")]),t._v(" "),a("h3",{attrs:{id:"🎯-两个事务-update-同一条数据会发生什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-两个事务-update-同一条数据会发生什么"}},[t._v("#")]),t._v(" 🎯 两个事务 update 同一条数据会发生什么？")]),t._v(" "),a("p",[t._v("在数据库中，如果两个事务同时尝试更新同一条数据，会发生以下几种情况之一，具体取决于数据库的隔离级别和锁机制：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("脏读（Dirty Read）")]),t._v("：在读未提交（Read Uncommitted）隔离级别下，一个事务可能会读取到另一个事务未提交的更新数据。如果第二个事务回滚了更改，那么第一个事务就会读到一些最终不会被提交的“脏数据”。")]),t._v(" "),a("li",[a("strong",[t._v("不可重复读（Non-Repeatable Read）")]),t._v("：在读已提交（Read Committed）隔离级别下，一个事务在读取某条数据后，另一个事务可能会修改或更新这条数据。这导致第一个事务无法再次读取到之前的数据状态，即不可重复读。")]),t._v(" "),a("li",[a("strong",[t._v("幻读（Phantom Read）")]),t._v("：在可重复读（Repeatable Read）隔离级别下，一个事务在读取某个范围内的数据后，另一个事务可能会插入新数据，导致第一个事务再次读取该范围时，会发现一些“幻读”的数据行。")]),t._v(" "),a("li",[a("strong",[t._v("更新丢失（Lost Update）")]),t._v("：当两个事务都读取了同一数据项，并且基于读取的值进行更新时，如果它们几乎同时提交，那么第二个提交的事务的更新可能会覆盖第一个事务的更新，导致第一个事务的更新丢失。")]),t._v(" "),a("li",[a("strong",[t._v("第一提交者胜出")]),t._v("：在大多数情况下，数据库会使用悲观锁或乐观锁来管理并发更新。如果使用悲观锁，那么通常只有一个事务能够锁定数据并进行更新，其他事务必须等待。如果使用乐观锁，事务会检查在读取数据后是否有其他事务对其进行了修改，如果没有修改，才会提交更新。")]),t._v(" "),a("li",[a("strong",[t._v("写入冲突")]),t._v("：在某些数据库系统中，如果两个事务尝试同时更新同一数据，可能会引发写入冲突。数据库会根据其冲突解决策略来决定如何处理这种情况，可能会回滚其中一个事务，或者提供一种机制让应用层解决冲突。")])]),t._v(" "),a("p",[t._v("为了避免这些问题，数据库通常提供不同的隔离级别，允许开发者根据业务需求选择合适的隔离级别。此外，通过使用事务锁和一致性检查，可以在应用层提供额外的控制来处理并发更新。")]),t._v(" "),a("p",[t._v("在设计系统时，应该仔细考虑并发控制策略，以确保数据的完整性和一致性。在实现时，可以使用数据库提供的锁机制，如行级锁、表级锁等，或者在应用层实现乐观锁或悲观锁逻辑。")]),t._v(" "),a("h3",{attrs:{id:"🎯-在高并发情况下-如何做到安全的修改同一行数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-在高并发情况下-如何做到安全的修改同一行数据"}},[t._v("#")]),t._v(" 🎯 在高并发情况下，如何做到安全的修改同一行数据？")]),t._v(" "),a("p",[t._v("在高并发情况下安全地修改同一行数据需要确保数据的一致性和完整性，避免并发导致的问题，如脏读、不可重复读和幻读。以下是一些常见的策略：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("乐观锁")]),t._v("：乐观锁通过在数据表中添加一个版本号或时间戳字段来实现。每次更新数据时，检查版本号或时间戳是否一致，如果不一致，说明数据在读取后被其他事务修改过，当前事务应该放弃更新。")]),t._v(" "),a("li",[a("strong",[t._v("悲观锁")]),t._v("：悲观锁在事务开始时就对数据行进行锁定，直到事务结束才释放锁。这可以防止其他事务同时修改同一数据行。")]),t._v(" "),a("li",[a("strong",[t._v("原子操作")]),t._v("：使用数据库提供的原子操作，如 "),a("code",[t._v("UPDATE ... WHERE")]),t._v(" 语句，确保修改操作的原子性。")]),t._v(" "),a("li",[a("strong",[t._v("事务隔离级别")]),t._v("：适当设置事务的隔离级别，如可重复读（REPEATABLE READ）或串行化（SERIALIZABLE），以减少并发事务间的干扰。")]),t._v(" "),a("li",[a("strong",[t._v("数据库的锁机制")]),t._v("：利用数据库的锁机制，如行锁、表锁等，来控制对数据的并发访问。")]),t._v(" "),a("li",[a("strong",[t._v("应用层控制")]),t._v("：在应用层实现重试逻辑，当检测到更新冲突时，可以重试事务。")]),t._v(" "),a("li",[a("strong",[t._v("分布式锁")]),t._v("：使用分布式锁来确保在分布式系统中，同一时间只有一个操作能够修改数据。")]),t._v(" "),a("li",[a("strong",[t._v("消息队列")]),t._v("：将更新操作封装在消息中，通过消息队列顺序处理更新，以避免并发冲突。")]),t._v(" "),a("li",[a("strong",[t._v("唯一索引")]),t._v("：在可能发生冲突的列上设置唯一索引，确保数据库层面上避免重复数据的插入。")]),t._v(" "),a("li",[a("strong",[t._v("条件更新")]),t._v("：使用条件更新，如 "),a("code",[t._v("UPDATE ... IF EXISTS")]),t._v("，来避免在数据已被其他事务修改的情况下进行更新。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-数据库的乐观锁和悲观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-数据库的乐观锁和悲观锁"}},[t._v("#")]),t._v(" 🎯 数据库的乐观锁和悲观锁？")]),t._v(" "),a("p",[a("strong",[t._v("乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题")])]),t._v(" "),a("p",[t._v("乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式")]),t._v(" "),a("p",[t._v("悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，"),a("strong",[t._v("悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-怎么在数据库里面使用乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-怎么在数据库里面使用乐观锁"}},[t._v("#")]),t._v(" 🎯 怎么在数据库里面使用乐观锁？")]),t._v(" "),a("p",[t._v("乐观锁（Optimistic Locking）是一种用于解决并发控制问题的技术，特别适用于读多写少的场景。它假设冲突很少发生，因此不在操作开始时加锁，而是在提交更新时检查是否有冲突。通常通过以下几种方式实现：")]),t._v(" "),a("ul",[a("li",[t._v("版本号：在表中添加一个版本号字段，每次更新记录时，版本号加1。更新操作时，检查版本号是否匹配，匹配则更新，不匹配则说明有冲突，需要重新读取数据再进行操作。")]),t._v(" "),a("li",[t._v("时间戳：用时间戳字段记录最后修改时间，更新操作时检查时间戳是否匹配。")])]),t._v(" "),a("blockquote",[a("p",[t._v("可以用来解决电商中的“超卖”问题。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-select-for-update有什么含义-会锁表还是锁行还是其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-select-for-update有什么含义-会锁表还是锁行还是其他"}},[t._v("#")]),t._v(" 🎯 select for update有什么含义，会锁表还是锁行还是其他？")]),t._v(" "),a("p",[t._v("for update 仅适用于 InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL  会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。")]),t._v(" "),a("p",[t._v("InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！")]),t._v(" "),a("p",[t._v("假设有个表单 products ，里面有 id 跟 name 二个栏位，id 是主键。")]),t._v(" "),a("ul",[a("li",[t._v("明确指定主键，并且有此笔资料，row lock")])]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM products WHERE id='3' FOR UPDATE;\nSELECT * FROM products WHERE id='3' and type=1 FOR UPDATE;\n")])])]),a("ul",[a("li",[t._v("明确指定主键，若查无此笔资料，无lock")])]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM products WHERE id='-1' FOR UPDATE;\n")])])]),a("ul",[a("li",[t._v("无主键，table lock")])]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM products WHERE name='Mouse' FOR UPDATE;\n")])])]),a("ul",[a("li",[t._v("主键不明确，table lock")])]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM products WHERE id <>'3' FOR UPDATE;\n")])])]),a("ul",[a("li",[t._v("主键不明确，table lock")])]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;\n")])])]),a("p",[a("strong",[t._v("注1")]),t._v(": FOR UPDATE 仅适用于 InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。\n"),a("strong",[t._v("注2")]),t._v(": 要测试锁定的状况，可以利用 MySQL 的 Command Mode ，开二个视窗来做测试。")]),t._v(" "),a("h3",{attrs:{id:"🎯-死锁有没有了解-写一段会造成死锁的-sql-语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-死锁有没有了解-写一段会造成死锁的-sql-语句"}},[t._v("#")]),t._v(" 🎯 死锁有没有了解，写一段会造成死锁的 sql 语句?")]),t._v(" "),a("p",[t._v("死锁是指两个或多个事务在等待彼此持有的资源，从而导致所有事务都无法继续执行的情况。在 MySQL 中，死锁通常发生在并发更新相同的资源时。")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("START TRANSACTION;\nUPDATE table_name SET column_a = 1 WHERE id = 1;\n-- 这里事务 1 锁定了 id = 1 的记录\nUPDATE table_name SET column_b = 2 WHERE id = 2;\n-- 等待事务 2 释放 id = 2 的锁\n")])])]),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("START TRANSACTION;\nUPDATE table_name SET column_b = 2 WHERE id = 2;\n-- 这里事务 2 锁定了 id = 2 的记录\nUPDATE table_name SET column_a = 1 WHERE id = 1;\n-- 等待事务 1 释放 id = 1 的锁\n")])])]),a("h3",{attrs:{id:"🎯-死锁发生了如何解决-mysql-有没有提供什么机制去解决死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-死锁发生了如何解决-mysql-有没有提供什么机制去解决死锁"}},[t._v("#")]),t._v(" 🎯 死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁？")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL 遇到过死锁问题吗，你是如何解决的？")])]),t._v(" "),a("p",[a("strong",[t._v("死锁产生")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环")]),t._v(" "),a("li",[t._v("当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁")]),t._v(" "),a("li",[t._v("锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。")])]),t._v(" "),a("blockquote",[a("p",[t._v("死锁产生的四个必要条件")]),t._v(" "),a("ol",[a("li",[t._v("互斥： 多个线程不能同时使用一个资源。比如线程 A 已经持有的资源，不能再同时被线程 B 持有。")]),t._v(" "),a("li",[t._v("持有并等待： 当线程 A 已经持有了资源 1，又提出申请资源 2，但是资源 2 已经被线程 C 占用，所以线程 A 就会处于等待状态，但它在等待资源 2 的同时并不会释放自己已经获取的资源 1。")]),t._v(" "),a("li",[t._v("不可剥夺： 线程 A 获取到资源 1 之后，在自己使用完之前不能被其他线程（比如线程 B）抢占使用。如果线程 B 也想使用资源 1，只能在线程 A 使用完后，主动释放后再获取")]),t._v(" "),a("li",[t._v("循环等待： 发生死锁时，必然会存在一个线程，也就是资源的环形链。比如线程 A 已经获取了资源 1，但同时又请求获取资源 2。线程 B 已经获取了资源 2，但同时又请求获取资源 1，这就会形成一个线程和资源请求等待的环形图。")])])]),t._v(" "),a("p",[a("strong",[t._v("检测死锁")]),t._v("：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB 存储引擎能检测到死锁的循环依赖并立即返回一个错误。")]),t._v(" "),a("p",[a("strong",[t._v("死锁恢复")]),t._v("：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，"),a("strong",[t._v("InnoDB 目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚")]),t._v("。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。")]),t._v(" "),a("p",[a("strong",[t._v("外部锁的死锁检测")]),t._v("：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决")]),t._v(" "),a("p",[a("strong",[t._v("死锁影响性能")]),t._v("：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖"),a("code",[t._v("innodb_lock_wait_timeout")]),t._v("设置进行事务回滚。")]),t._v(" "),a("h3",{attrs:{id:"🎯-如何尽可能避免死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-如何尽可能避免死锁"}},[t._v("#")]),t._v(" 🎯 如何尽可能避免死锁？")]),t._v(" "),a("ol",[a("li",[t._v("合理的设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引"),a("code",[t._v("定位更少的行，减少锁竞争")]),t._v("。")]),t._v(" "),a("li",[t._v("调整业务逻辑 SQL 执行顺序， 避免 update/delete 长时间持有锁的 SQL 在事务前面。")]),t._v(" "),a("li",[t._v("避免"),a("code",[t._v("大事务")]),t._v("，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的几率也更小。")]),t._v(" "),a("li",[t._v("以"),a("code",[t._v("固定的顺序")]),t._v("访问表和行。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为 2，1。这样更可能会造成死锁。")]),t._v(" "),a("li",[t._v("在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里"),a("code",[t._v("（运行了 start transaction 或设置了autocommit 等于0）")]),t._v(",那么就会锁定所查找到的记录。")]),t._v(" "),a("li",[t._v("尽量按"),a("code",[t._v("主键/索引")]),t._v("去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到 “select … where … order by rand();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数据都被锁住。")]),t._v(" "),a("li",[t._v("优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，"),a("code",[t._v("减少连接的表")]),t._v("，将复杂 SQL "),a("code",[t._v("分解")]),t._v("为多个简单的 SQL。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-说个自己遇到的死锁案例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说个自己遇到的死锁案例"}},[t._v("#")]),t._v(" 🎯 说个自己遇到的死锁案例？")]),t._v(" "),a("p",[t._v("早期我优化过一个死锁问题，是"),a("strong",[t._v("临键锁引起")]),t._v("的。业务逻辑很简单，先用 SELECT FOR UPDATE 查询数据。如果查询到了数据，那么就执行一段业务逻辑，然后更新结果；如果没有查询到，那么就执行另外一段业务逻辑，然后插入计算结果。")]),t._v(" "),a("p",[t._v("那么如果 SELECT FOR UPDATE 查找的数据不存在，那么数据库会使用一个临键锁。此时，如果有两个线程加了临键锁，然后又希望插入计算结果，那么就会造成死锁。")]),t._v(" "),a("p",[t._v("我这个优化也很简单，就是上来先不管三七二十一，直接插入数据。如果插入成功，那么就执行没有数据的逻辑，此时不会再持有临键锁，而是持有了行锁。如果插入不成功，那么就执行有数据的业务逻辑。")]),t._v(" "),a("p",[t._v("此外，还有两个思路。一个是修改数据库的隔离级别为 RC，那么自然不存在临键锁了，但是这个修改影响太大，被 DBA 否决了。")]),t._v(" "),a("p",[t._v("另外一个思路就是使用乐观锁，不过代码改起来要更加复杂，所以就没有使用。")]),t._v(" "),a("blockquote",[a("p",[t._v("假设表 t 中最大 id 是 10，那么如果两个业务进来，同时执行这个逻辑。一个准备插入 id=11 的数据，一个准备插入 id = 12 的数据。如果它们的执行时序如下图，那么你就会得到一个死锁错误"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/MySQL-dead-lock-demo-1.png",alt:""}})]),t._v(" "),a("p",[t._v("造成死锁的原因也很简单。在线程 A 执行 SELECT FOR UPDATE 的时候，因为 id=11 的数据不存在，所以实际上数据库会产生一个(11，supremum] 的临键锁。类似地，线程 B 也会产生一个(10，supremum] 临键锁。")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"五、数据类型与查询优化📊"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、数据类型与查询优化📊"}},[t._v("#")]),t._v(" 五、数据类型与查询优化📊")]),t._v(" "),a("p",[a("strong",[t._v("核心理念")]),t._v("：合理的数据类型选择和高效的查询编写是数据库性能的基础，掌握查询优化技巧能显著提升系统响应速度。")]),t._v(" "),a("blockquote",[a("p",[t._v("主要包括以下五大类：")]),t._v(" "),a("ul",[a("li",[t._v("整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT")]),t._v(" "),a("li",[t._v("浮点数类型：FLOAT、DOUBLE、DECIMAL")]),t._v(" "),a("li",[t._v("字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB")]),t._v(" "),a("li",[t._v("日期类型：Date、DateTime、TimeStamp、Time、Year")]),t._v(" "),a("li",[t._v("其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-char-和-varchar-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-char-和-varchar-的区别"}},[t._v("#")]),t._v(" 🎯 CHAR 和 VARCHAR 的区别？")]),t._v(" "),a("p",[a("code",[t._v("CHAR")]),t._v(" 和 "),a("code",[t._v("VARCHAR")]),t._v(" 都是用于存储字符串的字段类型，但它们在存储方式、性能和使用场景上存在一些关键区别")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("存储方式")]),t._v("：char 是固定长度，varchar 长度可变：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。")])]),t._v(" "),a("li",[a("p",[t._v("存储时，char 不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而 varchar 会根据实际存储的数据分配最终的存储空间，加上 1 或 2 个额外字节用于存储字符串的长度信息")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("性能不同")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("CHAR")]),t._v(" 因为其固定长度的特性，在某些情况下可能会提供更好的性能，尤其是当处理大量具有相同长度的数据时。")]),t._v(" "),a("li",[a("code",[t._v("VARCHAR")]),t._v(" 由于需要存储长度信息，并且可能需要额外的空间来存储不同长度的字符串，因此在性能上可能略逊于 "),a("code",[t._v("CHAR")])])])]),t._v(" "),a("li",[a("p",[t._v("使用场景：char 适用于固定长度字符串：如存储状态码、国家代码、MD5 哈希值等。varchar 适用于可变长度字符串：如用户名、电子邮件地址、描述等。")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-里记录货币用什么字段类型比较好"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-里记录货币用什么字段类型比较好"}},[t._v("#")]),t._v(" 🎯 MySQL 里记录货币用什么字段类型比较好？")]),t._v(" "),a("blockquote",[a("p",[t._v("阿里规范：【强制】任何货币金额，均以最小货币单位且整型类型来进行存储。")])]),t._v(" "),a("p",[t._v("在 MySQL 中记录货币数据时，通常推荐使用 "),a("code",[t._v("DECIMAL")]),t._v(" 类型。"),a("code",[t._v("DECIMAL")]),t._v(" 类型提供高精度的存储和计算，非常适合用于存储货币值。以下是使用 "),a("code",[t._v("DECIMAL")]),t._v(" 类型的原因以及其他可能选择的字段类型和其适用场景：")]),t._v(" "),a("p",[a("strong",[t._v("使用 "),a("code",[t._v("DECIMAL")]),t._v(" 类型的原因")])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("高精度")]),t._v("：\n"),a("ul",[a("li",[a("code",[t._v("DECIMAL")]),t._v(" 类型可以精确存储货币值，没有浮点运算误差。例如，定义为 "),a("code",[t._v("DECIMAL(10, 2)")]),t._v(" 表示最多 10 位数字，其中 2 位小数，适合存储最多到亿位的金额，精确到小数点后两位。")])])]),t._v(" "),a("li",[a("strong",[t._v("存储效率")]),t._v("：\n"),a("ul",[a("li",[t._v("由于货币值通常需要精确到小数点后两位，"),a("code",[t._v("DECIMAL")]),t._v(" 能够确保存储的每一个值都是精确的，避免了浮点数可能带来的舍入误差。")])])]),t._v(" "),a("li",[a("strong",[t._v("计算正确性")]),t._v("：\n"),a("ul",[a("li",[t._v("在涉及到财务计算时，使用浮点数类型（如 "),a("code",[t._v("FLOAT")]),t._v(" 或 "),a("code",[t._v("DOUBLE")]),t._v("）可能会因为舍入误差导致计算不准确。"),a("code",[t._v("DECIMAL")]),t._v(" 类型避免了这些问题，确保计算结果的准确性。")])])])]),t._v(" "),a("p",[t._v("当然还"),a("strong",[t._v("有些业务")]),t._v("，用 "),a("code",[t._v("INT")]),t._v(" 或者 "),a("code",[t._v("BIGINT")]),t._v(" 类型存储货币的最小单位也可以（如美分、分），适合对性能有更高要求的场景（整数运算比浮点运算更快），但需要处理转换逻辑。")]),t._v(" "),a("h3",{attrs:{id:"🎯-datetime-与-timestamp-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-datetime-与-timestamp-的区别"}},[t._v("#")]),t._v(" 🎯 datetime 与 timestamp 的区别？")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL 的 DATETIME 和 TIMESTAMP 都用来存储日期时间，但有几个关键区别：")]),t._v(" "),a("ol",[a("li",[t._v("DATETIME 与时区无关，存储的是什么取出来就是什么，范围更大（1000 ~ 9999 年），占 8 字节。")]),t._v(" "),a("li",[t._v("TIMESTAMP 与时区相关，存储时会转为 UTC，取出时按会话时区转换，范围是 1970 ~ 2038 年，占 4~7 字节。")]),t._v(" "),a("li",[t._v("TIMESTAMP 支持 "),a("code",[t._v("CURRENT_TIMESTAMP")]),t._v(" 和自动更新，常用来存记录的创建时间、修改时间；而 DATETIME 更适合业务逻辑相关的时间点。")])])]),t._v(" "),a("p",[a("strong",[t._v("1. 存储方式")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("DATETIME")]),t._v(" "),a("ul",[a("li",[t._v("以字符串形式存储日期和时间，格式为 "),a("code",[t._v("'YYYY-MM-DD HH:MM:SS'")]),t._v("。")]),t._v(" "),a("li",[t._v("与 "),a("strong",[t._v("时区无关")]),t._v("，存进去什么值，取出来就是什么值。")])])]),t._v(" "),a("li",[a("strong",[t._v("TIMESTAMP")]),t._v(" "),a("ul",[a("li",[t._v("以 "),a("strong",[t._v("Unix 时间戳")]),t._v("（从 1970-01-01 00:00:01 UTC 到某一时刻的秒数）存储。")]),t._v(" "),a("li",[t._v("与 "),a("strong",[t._v("时区相关")]),t._v("，存储时会转成 UTC，取出时会根据会话时区转换。")])])])]),t._v(" "),a("p",[a("strong",[t._v("2. 取值范围")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("DATETIME")]),t._v("："),a("code",[t._v("1000-01-01 00:00:00")]),t._v(" ~ "),a("code",[t._v("9999-12-31 23:59:59")])]),t._v(" "),a("li",[a("strong",[t._v("TIMESTAMP")]),t._v("："),a("code",[t._v("1970-01-01 00:00:01 UTC")]),t._v(" ~ "),a("code",[t._v("2038-01-19 03:14:07 UTC")]),t._v("（32 位整型限制，存在 2038 年问题）")])]),t._v(" "),a("p",[a("strong",[t._v("3. 存储大小")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("DATETIME")]),t._v("：8 字节")]),t._v(" "),a("li",[a("strong",[t._v("TIMESTAMP")]),t._v("：4 字节（MySQL 5.6 之后扩展为 4 ~ 7 字节，取决于小数秒精度）")])]),t._v(" "),a("p",[a("strong",[t._v("4. 时区影响")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("DATETIME")]),t._v("：不受时区影响，适合存储固定的“绝对时间”。")]),t._v(" "),a("li",[a("strong",[t._v("TIMESTAMP")]),t._v("：受时区影响，存储时转 UTC，取出时根据当前时区转换，适合存储事件发生的“真实时间点”。")])]),t._v(" "),a("p",[a("strong",[t._v("5. 默认值与自动更新")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("DATETIME")]),t._v("：默认值需要显式指定，一般不会自动更新。")]),t._v(" "),a("li",[a("strong",[t._v("TIMESTAMP")]),t._v("：可以默认 "),a("code",[t._v("CURRENT_TIMESTAMP")]),t._v("，并支持 "),a("code",[t._v("ON UPDATE CURRENT_TIMESTAMP")]),t._v("，自动存储当前时间。")])]),t._v(" "),a("p",[a("strong",[t._v("6. 应用场景")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("DATETIME")]),t._v("：适合存储“业务层面的日期时间”，如生日、会议时间、账单周期等，保证跨时区不变。")]),t._v(" "),a("li",[a("strong",[t._v("TIMESTAMP")]),t._v("：适合存储“记录生成或修改的时间”，如 "),a("code",[t._v("create_time")]),t._v("、"),a("code",[t._v("update_time")]),t._v("，自动随时区变化而调整。")])]),t._v(" "),a("h3",{attrs:{id:"🎯-blob-和-text-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-blob-和-text-有什么区别"}},[t._v("#")]),t._v(" 🎯 BLOB 和 TEXT 有什么区别？")]),t._v(" "),a("blockquote",[a("p",[t._v("这个问题其实很不重要，因为大部分公司不让让使用这两种类型。")]),t._v(" "),a("p",[a("strong",[t._v("禁止使用TEXT、BLOB类型")]),t._v("：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能")])]),t._v(" "),a("p",[a("code",[t._v("BLOB")]),t._v("（Binary Large Object）和 "),a("code",[t._v("TEXT")]),t._v(" 是 MySQL 中用于存储大型二进制数据和大型文本数据的两种不同的数据类型。它们之间的主要区别包括：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("存储内容")]),t._v("："),a("code",[t._v("BLOB")]),t._v(" 用于存储二进制数据，如图片、音频、视频等。"),a("code",[t._v("TEXT")]),t._v(" 用于存储大型文本数据，如文章、评论等。")]),t._v(" "),a("li",[a("strong",[t._v("最大长度")]),t._v("：\n"),a("ul",[a("li",[a("code",[t._v("BLOB")]),t._v(" 和 "),a("code",[t._v("TEXT")]),t._v(" 类型的最大长度可以达到 65,535 字节，即 64KB（在 MySQL 5.0.3 之前的版本中，最大长度为 255 字节）。")]),t._v(" "),a("li",[t._v("从 MySQL 5.0.3 版本开始，"),a("code",[t._v("BLOB")]),t._v(" 和 "),a("code",[t._v("TEXT")]),t._v(" 类型的列可以存储更大的数据，最大可达到 4GB（使用 "),a("code",[t._v("LONGBLOB")]),t._v(" 和 "),a("code",[t._v("LONGTEXT")]),t._v("）。")])])]),t._v(" "),a("li",[a("strong",[t._v("字符编码")]),t._v("："),a("code",[t._v("BLOB")]),t._v(" 存储的是二进制数据，与字符编码无关。"),a("code",[t._v("TEXT")]),t._v(" 存储的是字符数据，受字符编码的影响，如 "),a("code",[t._v("utf8")]),t._v("、"),a("code",[t._v("latin1")]),t._v(" 等。")]),t._v(" "),a("li",[a("strong",[t._v("存储效率")]),t._v("："),a("code",[t._v("BLOB")]),t._v(" 由于存储的是二进制数据，不涉及字符编码转换，通常存储效率更高。"),a("code",[t._v("TEXT")]),t._v(" 类型在存储时会进行字符编码转换，可能会占用更多的存储空间。")]),t._v(" "),a("li",[a("strong",[t._v("排序和比较")]),t._v("："),a("code",[t._v("BLOB")]),t._v(" 类型的列不能进行排序和比较，因为它们是二进制数据。"),a("code",[t._v("TEXT")]),t._v(" 类型的列可以进行排序和比较，因为它们是字符数据。")])]),t._v(" "),a("p",[t._v("在选择 "),a("code",[t._v("BLOB")]),t._v(" 还是 "),a("code",[t._v("TEXT")]),t._v(" 时，需要根据数据的特性和应用场景来决定。如果需要存储非文本的二进制数据，应选择 "),a("code",[t._v("BLOB")]),t._v("；如果需要存储大量的文本数据，则应选择 "),a("code",[t._v("TEXT")]),t._v("。")]),t._v(" "),a("h3",{attrs:{id:"🎯-count-和-count-1-和count-列名-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-count-和-count-1-和count-列名-区别"}},[t._v("#")]),t._v(" 🎯 count(*) 和 count(1)和count(列名)区别")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("COUNT(*)")]),t._v("：统计表中所有行的数量，包括 "),a("code",[t._v("NULL")]),t._v(" 值，性能最佳，适用于需要统计总行数的情况")]),t._v(" "),a("li",[a("strong",[t._v("COUNT(1)")]),t._v("：与 "),a("code",[t._v("COUNT(*)")]),t._v(" 类似，统计表中所有行的数量，包括 "),a("code",[t._v("NULL")]),t._v(" 值，性能与 "),a("code",[t._v("COUNT(*)")]),t._v(" 基本相同")]),t._v(" "),a("li",[a("strong",[t._v("COUNT(列名)")]),t._v("：统计指定列中非 "),a("code",[t._v("NULL")]),t._v(" 值的数量，适用于需要统计特定列中实际值数量的情况")])]),t._v(" "),a("h3",{attrs:{id:"🎯-union和union-all的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-union和union-all的区别"}},[t._v("#")]),t._v(" 🎯 UNION和UNION ALL的区别?")]),t._v(" "),a("p",[t._v("UNION和UNION ALL都是将两个结果集合并为一个，"),a("strong",[t._v("两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("UNION 在进行表连接后会筛选掉重复的数据记录（效率较低），而 UNION ALL 则不会去掉重复的数据记录；")])]),t._v(" "),a("li",[a("p",[t._v("UNION 会按照字段的顺序进行排序，而 UNION ALL 只是简单的将两个结果合并就返回；")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-sql执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-sql执行顺序"}},[t._v("#")]),t._v(" 🎯 SQL执行顺序")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img.starfish.ink/mysql/ferrer_essential_guide_sql_execution_order_6.png",alt:"The Essential Guide to SQL’s Execution Order"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("手写")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("SELECT DISTINCT <select_list>\nFROM  <left_table> <join_type>\nJOIN  <right_table> ON <join_condition>\nWHERE  <where_condition>\nGROUP BY  <group_by_list>\nHAVING <having_condition>\nORDER BY <order_by_condition>\nLIMIT <limit_number>\n")])])])]),t._v(" "),a("li",[a("p",[t._v("机读")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("FROM  <left_table>\nON <join_condition>\n<join_type> JOIN  <right_table> \nWHERE  <where_condition>\nGROUP BY  <group_by_list>\nHAVING <having_condition>\nSELECT\nDISTINCT <select_list>\nORDER BY <order_by_condition>\nLIMIT <limit_number>\n")])])])])]),t._v(" "),a("blockquote",[a("p",[t._v("mysql 的内连接、左连接、右连接有什么区别？")]),t._v(" "),a("p",[t._v("什么是内连接、外连接、交叉连接、笛卡尔积呢？")])]),t._v(" "),a("p",[a("strong",[t._v("Join图")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img.starfish.ink/mysql/sql-joins.jpg",alt:"sql-joins"}})]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"六、日志系统-📝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、日志系统-📝"}},[t._v("#")]),t._v(" 六、日志系统 📝")]),t._v(" "),a("p",[t._v("MySQL 日志其实是各种其他知识模块的基础")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-都有哪些日志-分别介绍下作用-执行顺序是怎么样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-都有哪些日志-分别介绍下作用-执行顺序是怎么样的"}},[t._v("#")]),t._v(" 🎯 MySQL  都有哪些日志，分别介绍下作用，执行顺序是怎么样的？")]),t._v(" "),a("blockquote",[a("ul",[a("li",[a("p",[a("strong",[t._v("错误日志")]),t._v("：记录出错信息，也记录一些警告信息或者正确的信息。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("通用查询日志")]),t._v("：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("慢查询日志")]),t._v("：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("二进制日志")]),t._v("：记录对数据库执行更改的所有操作。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("中继日志")]),t._v("：中继日志也是二进制日志，用来给slave 库恢复")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("事务日志")]),t._v("：重做日志 redo 和回滚日志 undo")])])])]),t._v(" "),a("p",[t._v("时序上先 undo log，redo log 先 prepare， 再写 binlog，最后再把 redo log commit")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img.starfish.ink/mysql/log-seq.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"🎯-说下-一条-mysql-更新语句的执行流程是怎样的吧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说下-一条-mysql-更新语句的执行流程是怎样的吧"}},[t._v("#")]),t._v(" 🎯 说下 一条 MySQL 更新语句的执行流程是怎样的吧？")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("解析和优化")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("语法解析")]),t._v("：MySQL解析器会对"),a("code",[t._v("UPDATE")]),t._v("语句进行语法解析，生成语法树，并检查语句的合法性。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("查询优化器")]),t._v("：优化器会根据表的索引、统计信息等来选择最优的执行计划，以最快的方式查找需要更新的记录。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("定位记录")]),t._v("（这个过程也被称作"),a("strong",[t._v("加锁读")]),t._v("）")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("通过索引定位")]),t._v("：如果更新语句涉及索引，MySQL会利用索引快速定位需要更新的记录。如果没有索引，则会进行全表扫描。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("在Buffer Pool中查找页")]),t._v("：MySQL首先会在Buffer Pool中查找包含目标记录的页（数据页或索引页），如果该页已经存在于Buffer Pool中，则直接使用；否则会将其从磁盘加载到 Buffer Pool 中。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("生成Undo日志")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("生成Undo日志")]),t._v("：为了支持事务的回滚，MySQL 会在更新操作前生成一条 Undo 日志，该日志记录了被更新行的"),a("strong",[t._v("旧值")]),t._v("。Undo日志存储在回滚段（Rollback Segment）中。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("保存Undo日志")]),t._v("：在发生事务回滚时，MySQL会使用Undo日志将数据恢复到更新前的状态。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("更新数据")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("更新Buffer Pool中的数据页")]),t._v("：MySQL在Buffer Pool中对定位到的记录进行更新操作，修改记录的值。这是一个内存中的操作，数据页此时还没有写回到磁盘。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("标记页为脏页")]),t._v("：被修改的页会被标记为“脏页”，表示其内容与磁盘上的数据不同，需要在适当的时候写回磁盘。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("生成Redo日志")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("生成Redo日志")]),t._v("：Redo日志记录了数据页的物理变化，用于在数据库崩溃时恢复数据一致性。Redo日志包括这次更新操作的具体细节，如页号、偏移量和新值。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("写入Redo日志缓存")]),t._v("：生成的Redo日志首先被写入Redo日志缓存（Log Buffer），而不是直接写入磁盘。")]),t._v(" "),a("blockquote",[a("p",[t._v("此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务")])])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("写入Binlog")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("生成Binlog")]),t._v("：MySQL会生成一条对应的Binlog（针对事务性表的DML语句）。Binlog记录的是这次更新的逻辑变化（类似于SQL语句或行级变化），主要用于主从复制和数据恢复。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("刷写Binlog")]),t._v("：Binlog首先被写入到Binlog缓存，当事务提交时会将缓存中的Binlog刷写到磁盘上的Binlog文件。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("事务提交")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("刷写Redo日志")]),t._v("：在事务提交前，MySQL会将Redo日志从日志缓存刷写到磁盘的Redo日志文件（ib_logfile0, ib_logfile1）。此操作通常是顺序写入，因此效率较高。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("刷写Binlog")]),t._v("：在事务提交时，Binlog也会被刷写到磁盘。根据MySQL的设置，可能会先刷写Binlog再刷写Redo日志，或以不同顺序执行。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("两阶段提交")]),t._v("：为了确保Binlog和Redo日志的原子性，MySQL使用两阶段提交的机制。具体步骤是：首先写入Redo日志（处于Prepare状态），然后写入Binlog，最后更新Redo日志为Commit状态。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据页刷盘")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("异步刷盘")]),t._v("：脏页的刷盘（即将修改后的数据页从Buffer Pool写回到磁盘）通常是异步进行的。InnoDB存储引擎会根据脏页数量、系统空闲时间等条件定期执行刷盘操作。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("检查点")]),t._v("：MySQL通过检查点机制来控制Redo日志的循环使用和脏页的刷盘。当达到检查点时，会将所有脏页刷写到磁盘，同时更新Redo日志的检查点信息。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("完成更新操作")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("事务结束")]),t._v("：当Redo日志和Binlog都刷写到磁盘后，事务就完成了。对于非事务性表，操作可能不会涉及Undo日志和Redo日志。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("释放锁")]),t._v("：在事务完成后，MySQL会释放占用的锁资源。")])])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-两阶段提交"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-两阶段提交"}},[t._v("#")]),t._v(" 🎯 两阶段提交？")]),t._v(" "),a("p",[t._v("在 MySQL 中，"),a("code",[t._v("UPDATE")]),t._v(" 操作涉及对数据的修改，为了保证数据的一致性和可靠性，特别是在使用 "),a("strong",[t._v("InnoDB")]),t._v(" 存储引擎时，"),a("code",[t._v("UPDATE")]),t._v(" 操作需要使用"),a("strong",[t._v("两阶段提交（Two-Phase Commit）")]),t._v("。两阶段提交的设计主要是为了确保数据的"),a("strong",[t._v("原子性")]),t._v("和"),a("strong",[t._v("一致性")]),t._v("，特别是在支持事务和涉及到数据库的"),a("strong",[t._v("Binlog")]),t._v("（二进制日志）记录的情况下。")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("两阶段提交的原因")])]),t._v(" "),a("p",[t._v("MySQL 的两阶段提交机制主要用于协调 "),a("strong",[t._v("InnoDB 引擎的事务日志（Redo Log）")]),t._v(" 和 "),a("strong",[t._v("MySQL 的 Binlog")]),t._v("。当数据库发生崩溃时，保证事务的持久性和一致性是非常重要的。事务的执行不能一部分成功，另一部分失败，这会导致数据不一致。")]),t._v(" "),a("p",[a("strong",[t._v("关键问题：")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("Redo Log")]),t._v(" 是 InnoDB 的内部事务日志，确保事务的"),a("strong",[t._v("持久性")]),t._v("（即便崩溃后数据也能恢复）。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("Binlog")]),t._v(" 是 MySQL 的二进制日志，主要用于数据的"),a("strong",[t._v("复制")]),t._v("和"),a("strong",[t._v("备份")]),t._v("。")])])]),t._v(" "),a("p",[t._v("如果没有两阶段提交，在执行 "),a("code",[t._v("UPDATE")]),t._v(" 操作时可能会出现以下问题：")]),t._v(" "),a("ul",[a("li",[t._v("写入 Binlog 成功，但事务日志（Redo Log）失败**：**事务被记录在 Binlog 中，但实际修改的数据没有持久化，导致数据不一致。")]),t._v(" "),a("li",[t._v("写入 Redo Log 成功，但 Binlog 失败：数据修改在本地持久化了，但 Binlog 失败，导致主从复制出现问题，主库和从库数据不一致。")])])])]),t._v(" "),a("p",[t._v("​\t因此，MySQL 使用两阶段提交来确保在事务修改数据的过程中，"),a("strong",[t._v("Binlog 和 Redo Log 同时成功")]),t._v("，从而保证事务的一致性。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("p",[a("strong",[t._v("两阶段提交的流程")])]),t._v(" "),a("p",[t._v("MySQL 在执行 "),a("code",[t._v("UPDATE")]),t._v(" 操作时，InnoDB 和 Binlog 通过两阶段提交进行协调。具体步骤如下：")]),t._v(" "),a("p",[t._v("a. 第一阶段：预提交阶段（Prepare Phase）")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("开始事务")]),t._v("：InnoDB 首先会执行 "),a("code",[t._v("UPDATE")]),t._v(" 操作，并将修改记录到内存中的 Undo Log，以便在事务失败时可以回滚。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("记录 Redo Log（prepare）")]),t._v("：修改数据的操作被记录在"),a("strong",[t._v("Redo Log")]),t._v('中，并标记为 "Prepare" 状态，此时数据尚未真正提交，只是标记为“准备提交”。')])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("等待事务进入准备状态")]),t._v("：InnoDB 引擎等着上层的 MySQL Server 层确认 Binlog 日志写入成功。")])])]),t._v(" "),a("p",[t._v("此时，事务还没有被真正提交，但 Redo Log 已经有了准备提交的记录。")]),t._v(" "),a("p",[t._v("b. 第二阶段：提交阶段（Commit Phase）")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("写入 Binlog")]),t._v("：MySQL Server 层会将这次 "),a("code",[t._v("UPDATE")]),t._v(" 操作记录到 Binlog 中，确保日志记录成功。")]),t._v(" "),a("li",[a("strong",[t._v("提交事务")]),t._v('：当 Binlog 成功写入后，MySQL Server 会通知 InnoDB 提交事务，InnoDB 会将 Redo Log 的状态从 "Prepare" 变为 "Commit"。')]),t._v(" "),a("li",[a("strong",[t._v("持久化 Redo Log")]),t._v("：最后，InnoDB 将 Redo Log 的状态变为已提交，保证数据的修改真正生效，并确保即使系统崩溃，事务也可以在恢复过程中继续完成。")])])])]),t._v(" "),a("p",[t._v("​\t通过这样的两阶段提交，MySQL 确保了 Binlog 和 Redo Log 都正确记录，避免了系统崩溃时数据不一致的问题。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("p",[t._v("为什么需要两阶段提交？")]),t._v(" "),a("p",[t._v("两阶段提交的必要性源自于以下几点：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("数据的一致性")]),t._v("：事务的修改操作必须同时写入 InnoDB 的事务日志和 MySQL 的 Binlog，确保数据和日志保持一致，尤其是在崩溃恢复或主从复制的场景下。")]),t._v(" "),a("li",[a("strong",[t._v("事务的原子性")]),t._v("：保证要么事务的所有操作都成功，要么所有操作都回滚，不会出现事务部分提交的情况。")]),t._v(" "),a("li",[a("strong",[t._v("崩溃恢复")]),t._v("：在崩溃恢复时，InnoDB 可以依靠已提交的 Redo Log 来恢复数据，而 Binlog 用于恢复操作步骤，并保持主从数据库同步。")])])]),t._v(" "),a("li",[a("p",[t._v("解决的问题")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("防止数据不一致")]),t._v("：没有两阶段提交机制，可能会导致数据和日志之间的不一致，尤其在分布式环境下，数据库的主从复制和日志备份可能会出现问题。")]),t._v(" "),a("li",[a("strong",[t._v("确保事务完整性")]),t._v("：确保所有日志（Binlog 和 Redo Log）和数据一致，保证事务在任何情况下都能正确提交或回滚。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-说说-redo-log-、undo-log-和-bin-log"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说说-redo-log-、undo-log-和-bin-log"}},[t._v("#")]),t._v(" 🎯 说说 redo log 、undo log 和 bin log ？")]),t._v(" "),a("p",[t._v("在 MySQL 中，特别是在使用 InnoDB 存储引擎时，"),a("code",[t._v("redo log")]),t._v("（重做日志）、"),a("code",[t._v("undo log")]),t._v("（回滚日志）和 "),a("code",[t._v("binlog")]),t._v("（二进制日志）各自承担着不同的角色：")]),t._v(" "),a("p",[a("strong",[t._v("1. Redo Log（重做日志）：")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("目的")]),t._v("：确保事务的持久性。在系统崩溃后，"),a("code",[t._v("redo log")]),t._v(" 允许恢复未提交的事务更改，保证数据的完整性和一致性。")]),t._v(" "),a("li",[a("strong",[t._v("内容")]),t._v("：记录了事务对数据页所做的物理更改【"),a("strong",[t._v("物理日志")]),t._v("】，以便在崩溃恢复时重新应用这些更改。")]),t._v(" "),a("li",[a("strong",[t._v("写入时机")]),t._v("：在事务提交时，将更改刷新到磁盘上的 "),a("code",[t._v("redo log")]),t._v(" 文件中。")]),t._v(" "),a("li",[a("strong",[t._v("大小和循环")]),t._v("："),a("code",[t._v("redo log")]),t._v(" 通常配置为固定大小的日志文件，并且可以循环使用。")]),t._v(" "),a("li",[a("strong",[t._v("用途")]),t._v("："),a("strong",[t._v("崩溃恢复")]),t._v("，在数据库崩溃后，通过 redo log 恢复到崩溃前的状态，保证数据一致性。")])]),t._v(" "),a("blockquote",[a("p",[t._v("redo log 不需要写磁盘吗？如果 redo log 也要写磁盘，干嘛不直接修改数据呢？redo log 是需要写磁盘的，但是 redo log 是"),a("strong",[t._v("顺序写")]),t._v("的，所以也是 WAL（writeahead-log） 的一种。")]),t._v(" "),a("p",[t._v("redo log 本身也是先写进 redo log buffer，后面再刷新到操作系统的 page cache，或者一步到位刷新到磁盘")]),t._v(" "),a("p",[t._v("InnoDB 引擎本身提供了参数 "),a("code",[t._v("innodb_flush_log_at_trx_commit")]),t._v(" 来控制写到磁盘的时机，里面有三个不同值。")]),t._v(" "),a("ul",[a("li",[t._v("0：每秒刷新到磁盘，是从 redo log buffer 到磁盘。")]),t._v(" "),a("li",[t._v("1：每次提交的时候刷新到磁盘上，也就是最安全的选项，InnoDB 的"),a("strong",[t._v("默认值")]),t._v("。")]),t._v(" "),a("li",[t._v("2：每次提交的时候刷新到 page cache 里，依赖于操作系统后续刷新到磁盘。")])])]),t._v(" "),a("p",[a("strong",[t._v("2. Undo Log（回滚日志）：")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("目的")]),t._v("：提供事务的原子性和一致性。它允许撤销事务的更改，以保持数据的一致状态。")]),t._v(" "),a("li",[a("strong",[t._v("内容")]),t._v("：记录了事务对数据页所做的更改的逆操作【"),a("strong",[t._v("逻辑日志")]),t._v("】，使得在事务失败或需要回滚时可以恢复原始数据。")]),t._v(" "),a("li",[a("strong",[t._v("写入时机")]),t._v("：当事务进行修改操作时，"),a("code",[t._v("undo log")]),t._v(" 会记录这些更改的逆操作，通常在事务提交前就已经写入。")]),t._v(" "),a("li",[a("strong",[t._v("用途")]),t._v("：主要用于 MVCC（多版本并发控制）和事务回滚。")])]),t._v(" "),a("p",[a("strong",[t._v("3. Binlog（二进制日志）：")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("目的")]),t._v("：记录数据库的所有修改操作，用于数据恢复、主从复制和数据审计。")]),t._v(" "),a("li",[a("strong",[t._v("内容")]),t._v("：记录了所有修改数据的 SQL 语句，如 "),a("code",[t._v("INSERT")]),t._v("、"),a("code",[t._v("UPDATE")]),t._v(" 和 "),a("code",[t._v("DELETE")]),t._v("，但不记录 "),a("code",[t._v("SELECT")]),t._v(" 和 "),a("code",[t._v("SHOW")]),t._v(" 这类的语句。")]),t._v(" "),a("li",[a("strong",[t._v("写入时机")]),t._v("：在 SQL 语句执行后，根据配置，"),a("code",[t._v("binlog")]),t._v(" 可以立即或事务提交时写入磁盘。")]),t._v(" "),a("li",[a("strong",[t._v("大小和存储")]),t._v("："),a("code",[t._v("binlog")]),t._v(" 文件通常不循环使用，它们会随着时间持续增长，直到通过配置的策略进行清理。")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("特性")]),t._v(" "),a("th",[t._v("Redo Log")]),t._v(" "),a("th",[t._v("Undo Log")]),t._v(" "),a("th",[t._v("Bin Log")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("主要用途")]),t._v(" "),a("td",[t._v("崩溃恢复")]),t._v(" "),a("td",[t._v("事务回滚、多版本并发控制（MVCC）")]),t._v(" "),a("td",[t._v("主从复制和数据恢复")])]),t._v(" "),a("tr",[a("td",[t._v("日志类型")]),t._v(" "),a("td",[t._v("物理日志")]),t._v(" "),a("td",[t._v("逻辑日志")]),t._v(" "),a("td",[t._v("逻辑日志")])]),t._v(" "),a("tr",[a("td",[t._v("存储内容")]),t._v(" "),a("td",[t._v("页级物理更改")]),t._v(" "),a("td",[t._v("数据快照")]),t._v(" "),a("td",[t._v("SQL 语句或行级数据变化")])]),t._v(" "),a("tr",[a("td",[t._v("写入方式")]),t._v(" "),a("td",[t._v("循环写入")]),t._v(" "),a("td",[t._v("按需写入")]),t._v(" "),a("td",[t._v("追加写入")])]),t._v(" "),a("tr",[a("td",[t._v("写入时机")]),t._v(" "),a("td",[t._v("事务提交时")]),t._v(" "),a("td",[t._v("事务操作时")]),t._v(" "),a("td",[t._v("事务提交时")])]),t._v(" "),a("tr",[a("td",[t._v("大小")]),t._v(" "),a("td",[t._v("固定大小")]),t._v(" "),a("td",[t._v("可变大小")]),t._v(" "),a("td",[t._v("可变大小")])]),t._v(" "),a("tr",[a("td",[t._v("作用")]),t._v(" "),a("td",[t._v("保证数据一致性和持久性")]),t._v(" "),a("td",[t._v("提供事务回滚和一致性读支持")]),t._v(" "),a("td",[t._v("实现数据复制和备份")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-的-binlog-有几种录入格式-分别有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-的-binlog-有几种录入格式-分别有什么区别"}},[t._v("#")]),t._v(" 🎯 MySQL 的 binlog 有几种录入格式？分别有什么区别？")]),t._v(" "),a("p",[a("code",[t._v("binlog")]),t._v("日志有三种格式，分别为"),a("code",[t._v("STATMENT")]),t._v("、"),a("code",[t._v("ROW")]),t._v("和"),a("code",[t._v("MIXED")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[t._v("在 "),a("code",[t._v("MySQL 5.7.7")]),t._v("之前，默认的格式是"),a("code",[t._v("STATEMENT")]),t._v("，"),a("code",[t._v("MySQL 5.7.7")]),t._v("之后，默认值是 "),a("code",[t._v("ROW")]),t._v("。日志格式通过 "),a("code",[t._v("binlog-format")]),t._v(" 指定。")])]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("STATMENT")]),t._v(" ：基于 SQL 语句的复制("),a("code",[t._v("statement-based replication, SBR")]),t._v(")，每一条会修改数据的 sql 语句会记录到 binlog 中**。**")]),t._v(" "),a("ul",[a("li",[t._v("优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，从而提高了性能；")]),t._v(" "),a("li",[t._v("缺点：在某些情况下会导致主从数据不一致，比如执行"),a("code",[t._v("sysdate()")]),t._v("、"),a("code",[t._v("slepp()")]),t._v("等。")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("ROW")]),t._v(" ：基于行的复制("),a("code",[t._v("row-based replication, RBR")]),t._v(")，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了**。 **")]),t._v(" "),a("ul",[a("li",[t._v("优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题**；**")]),t._v(" "),a("li",[t._v("缺点：会产生大量的日志，尤其是 "),a("code",[t._v("alter table")]),t._v(" 的时候会让日志暴涨")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("MIXED")]),t._v(" ：基于 STATMENT 和 ROW 两种模式的混合复制("),a("code",[t._v("mixed-based replication, MBR")]),t._v(")，mixed 格式的意思是，MySQL 自己会判断这条 SQL 语句是否可能引起主备不一致，如果有可能，就用 row 格式，否则就用 statement 格式")])])]),t._v(" "),a("hr"),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"七、性能调优-⚡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、性能调优-⚡"}},[t._v("#")]),t._v(" 七、性能调优 ⚡")]),t._v(" "),a("h3",{attrs:{id:"🎯-影响-mysql-的性能因素有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-影响-mysql-的性能因素有哪些"}},[t._v("#")]),t._v(" 🎯 影响  MySQL 的性能因素有哪些?")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("业务需求对MySQL的影响(合适合度)")])]),t._v(" "),a("li",[a("p",[t._v("存储定位对MySQL的影响")]),t._v(" "),a("ul",[a("li",[t._v("不适合放进MySQL的数据\n"),a("ul",[a("li",[t._v("二进制多媒体数据")]),t._v(" "),a("li",[t._v("流水队列数据")]),t._v(" "),a("li",[t._v("超大文本数据")])])]),t._v(" "),a("li",[t._v("需要放进缓存的数据\n"),a("ul",[a("li",[t._v("系统各种配置及规则数据")]),t._v(" "),a("li",[t._v("活跃用户的基本信息数据")]),t._v(" "),a("li",[t._v("活跃用户的个性化定制信息数据")]),t._v(" "),a("li",[t._v("准实时的统计信息数据")]),t._v(" "),a("li",[t._v("其他一些访问频繁但变更较少的数据")])])])])]),t._v(" "),a("li",[a("p",[t._v("Schema设计对系统的性能影响")]),t._v(" "),a("ul",[a("li",[t._v("尽量减少对数据库访问的请求")]),t._v(" "),a("li",[t._v("尽量减少无用数据的查询请求")])])]),t._v(" "),a("li",[a("p",[t._v("硬件环境对系统性能的影响")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-日常工作中你是怎么优化sql的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-日常工作中你是怎么优化sql的"}},[t._v("#")]),t._v(" 🎯 日常工作中你是怎么优化SQL的？")]),t._v(" "),a("p",[t._v("优化SQL的日常工作可以从以下几个方面进行：")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("索引优化")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("创建索引")]),t._v("：为频繁查询的列创建合适的索引，特别是主键和外键列。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("使用覆盖索引")]),t._v("：通过索引来满足查询需求，避免回表查询。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("删除冗余索引")]),t._v("：清理不常用或重复的索引，以减少维护开销。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("查询优化")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("避免选择所有列")]),t._v("：只选择需要的列，避免使用 "),a("code",[t._v("SELECT *")]),t._v("。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("使用合适的SQL语法")]),t._v("：如使用 "),a("code",[t._v("JOIN")]),t._v(" 替代子查询，避免N+1查询问题。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("优化WHERE子句")]),t._v("：使用索引列进行过滤，避免在过滤条件中进行函数运算或转换。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据库结构优化")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("规范化与反规范化")]),t._v("：根据实际需求选择合适的数据库设计，平衡数据冗余和查询性能。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("分区表")]),t._v("：对于大表，使用分区技术来提升查询和维护性能。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("缓存机制")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("应用层缓存")]),t._v("：如Memcached或Redis，缓存频繁访问的数据，减少数据库负载。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据库缓存")]),t._v("：合理设置数据库缓存参数，优化数据库内存使用。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("SQL分析与监控")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("执行计划分析")]),t._v("：使用 "),a("code",[t._v("EXPLAIN")]),t._v(" 分析SQL的执行计划，了解查询的执行步骤和时间。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("慢查询日志")]),t._v("：启用慢查询日志，找出并优化执行时间较长的SQL语句。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("性能监控工具")]),t._v("：如使用New Relic、APM等工具，持续监控数据库性能。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("事务控制")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("减少事务范围")]),t._v("：尽量缩小事务的范围和持续时间，避免长时间锁定资源。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("合理设置隔离级别")]),t._v("：根据业务需求选择合适的事务隔离级别，平衡并发性和数据一致性。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据库参数调整")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("调整连接池")]),t._v("：合理设置数据库连接池大小，避免过多连接导致资源争用。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("优化数据库配置")]),t._v("：根据硬件资源和业务需求，调整数据库内存、缓存、IO等参数。")])])])])]),t._v(" "),a("p",[t._v("通过以上方法，可以有效地优化SQL性能，提高数据库的响应速度和稳定性。持续关注数据库的运行情况，并根据实际需求进行调整，是保持数据库高效运行的关键。")]),t._v(" "),a("h3",{attrs:{id:"🎯-什么是最左前缀原则-什么是最左匹配原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-什么是最左前缀原则-什么是最左匹配原则"}},[t._v("#")]),t._v(" 🎯 什么是最左前缀原则？什么是最左匹配原则？")]),t._v(" "),a("p",[a("strong",[t._v("最左前缀原则")]),t._v(" 和 "),a("strong",[t._v("最左匹配原则")]),t._v(" 是在使用索引时的两个相关概念，它们通常与复合索引（即在多个列上创建的索引）的使用相关：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("最左前缀原则")]),t._v("：\n"),a("ul",[a("li",[t._v("当使用复合索引时，最左前缀原则指的是查询优化器只会使用复合索引中最左边的列（或前几列）来查找数据。")]),t._v(" "),a("li",[t._v("这意味着，如果要利用复合索引，查询条件中必须包含最左边的列。如果查询条件不包含最左边的列，那么索引将不会被使用，或者不会完全被使用。")])])]),t._v(" "),a("li",[a("strong",[t._v("最左匹配原则")]),t._v("：\n"),a("ul",[a("li",[t._v("最左匹配原则是指在复合索引中，只有当前面的列匹配后，才能继续向后匹配。换句话说，只有当前一个列的值已经确定，才能利用下一个列的索引。")]),t._v(" "),a("li",[t._v("例如，如果你有一个 ("),a("code",[t._v("col1")]),t._v(", "),a("code",[t._v("col2")]),t._v(", "),a("code",[t._v("col3")]),t._v(") 的复合索引，那么只有当 "),a("code",[t._v("col1")]),t._v(" 的值确定后，"),a("code",[t._v("col2")]),t._v(" 的索引才会被使用；同样，只有当 "),a("code",[t._v("col1")]),t._v(" 和 "),a("code",[t._v("col2")]),t._v(" 的值都确定后，"),a("code",[t._v("col3")]),t._v(" 的索引才会被使用。")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("在 MySQL 中，"),a("strong",[t._v("联合索引 (a, b, c)")]),t._v(" 的最左匹配原则使用情况如下：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("strong",[t._v("查询条件")])]),t._v(" "),a("th",[a("strong",[t._v("是否使用索引")])]),t._v(" "),a("th",[a("strong",[t._v("使用索引的字段")])]),t._v(" "),a("th",[a("strong",[t._v("底层原因")])])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("code",[t._v("WHERE a=1 AND b=2 AND c=3")])]),t._v(" "),a("td",[t._v("✅ 完全使用")]),t._v(" "),a("td",[a("code",[t._v("a, b, c")])]),t._v(" "),a("td",[t._v("严格遵循最左顺序，B+ 树逐层定位")])]),t._v(" "),a("tr",[a("td",[a("code",[t._v("WHERE c=3 AND b=2 AND a=1")])]),t._v(" "),a("td",[t._v("✅ 完全使用")]),t._v(" "),a("td",[a("code",[t._v("a, b, c")])]),t._v(" "),a("td",[t._v("优化器调整顺序后等价于 "),a("code",[t._v("a=1 AND b=2 AND c=3")])])]),t._v(" "),a("tr",[a("td",[a("code",[t._v("WHERE a=1 AND c=3")])]),t._v(" "),a("td",[t._v("⚠️ 部分使用（仅 "),a("code",[t._v("a")]),t._v("）")]),t._v(" "),a("td",[a("code",[t._v("a")])]),t._v(" "),a("td",[t._v("跳过 "),a("code",[t._v("b")]),t._v("，"),a("code",[t._v("c")]),t._v(" 无法直接通过索引定位")])]),t._v(" "),a("tr",[a("td",[a("code",[t._v("WHERE b=2 AND c=3")])]),t._v(" "),a("td",[t._v("❌ 索引失效")]),t._v(" "),a("td",[t._v("无")]),t._v(" "),a("td",[t._v("未包含最左列 "),a("code",[t._v("a")]),t._v("，无法触发索引路径")])])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql常见性能分析手段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql常见性能分析手段"}},[t._v("#")]),t._v(" 🎯 MySQL常见性能分析手段？")]),t._v(" "),a("p",[a("strong",[t._v("MySQL Query Optimizer")])]),t._v(" "),a("ol",[a("li",[a("p",[t._v("MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）")])]),t._v(" "),a("li",[a("p",[t._v("当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimizer 时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。")])])]),t._v(" "),a("p",[a("strong",[t._v("MySQL常见瓶颈")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("CPU：CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候")])]),t._v(" "),a("li",[a("p",[t._v("IO：磁盘 I/O 瓶颈发生在装入数据远大于内存容量的时候")])]),t._v(" "),a("li",[a("p",[t._v("服务器硬件的性能瓶颈：top，free，iostat 和 vmstat 来查看系统的性能状态")])])]),t._v(" "),a("p",[a("strong",[t._v("性能下降SQL慢 执行时间长 等待时间长 原因分析")])]),t._v(" "),a("ul",[a("li",[t._v("查询语句写的烂")]),t._v(" "),a("li",[t._v("索引失效（单值、复合）")]),t._v(" "),a("li",[t._v("关联查询太多 join（设计缺陷或不得已的需求）")]),t._v(" "),a("li",[t._v("服务器调优及各个参数设置（缓冲、线程数等）")])]),t._v(" "),a("p",[t._v("在优化 MySQL 时，通常需要对数据库进行分析，常见的分析手段有"),a("strong",[t._v("慢查询日志")]),t._v("，"),a("strong",[t._v("EXPLAIN 分析查询")]),t._v("，"),a("strong",[t._v("profiling分析")]),t._v("以及"),a("strong",[t._v("show命令查询系统状态及系统变量")]),t._v("，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。")]),t._v(" "),a("h3",{attrs:{id:"🎯-性能瓶颈定位"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-性能瓶颈定位"}},[t._v("#")]),t._v(" 🎯 性能瓶颈定位")]),t._v(" "),a("p",[t._v("我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Mysql> show status ——显示状态信息（扩展show status like ‘XXX’）\n\nMysql> show variables ——显示系统变量（扩展show variables like ‘XXX’）\n\nMysql> show innodb status ——显示InnoDB存储引擎的状态\n\nMysql> show processlist ——查看当前SQL执行，包括执行状态、是否锁表等\n\nShell> mysqladmin variables -u username -p password——显示系统变量\n\nShell> mysqladmin extended-status -u username -p password——显示状态信息\n")])])]),a("h3",{attrs:{id:"🎯-怎么看执行计划-explain-如何理解其中各个字段的含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-怎么看执行计划-explain-如何理解其中各个字段的含义"}},[t._v("#")]),t._v(" 🎯 怎么看执行计划（explain），如何理解其中各个字段的含义？")]),t._v(" "),a("p",[t._v("使用 "),a("strong",[t._v("Explain")]),t._v(" 关键字可以模拟优化器执行 SQL 查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈")]),t._v(" "),a("blockquote",[a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("create")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" t1\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    id           "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("auto_increment")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("primary")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("key")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    col1         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    col2         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v("          "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    col3         "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    part1        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    part2        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    part3        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    common_field "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("varchar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("constraint")]),t._v(" idx_key2 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unique")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("col2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("charset")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" utf8mb3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("create")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v(" idx_key1\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("on")]),t._v(" t1 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("col1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("create")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v(" idx_key3\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("on")]),t._v(" t1 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("col3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("create")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),t._v(" idx_key_part\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("on")]),t._v(" t1 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("part1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" part2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" part3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("p",[t._v("各字段解释")]),t._v(" "),a("ul",[a("li",[a("p",[a("mark",[a("strong",[t._v("id")])]),t._v("（select 查询的序列号，包含一组数字，表示查询中执行 select 子句或操作表的顺序）")]),t._v(" "),a("ul",[a("li",[t._v("id 相同，执行顺序从上往下")]),t._v(" "),a("li",[t._v("id 不同，数字越大，越优先执行（子查询会有更大的 id）")]),t._v(" "),a("li",[t._v("id 相同不同，同时存在，相同的属于一组，从上往下执行")])])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("select_type")])]),t._v("（查询的类型，用于区别普通查询、联合查询、子查询等复杂查询）")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("SIMPLE")]),t._v(" ：简单的 select 查询，查询中不包含子查询或 UNION")]),t._v(" "),a("li",[a("strong",[t._v("PRIMARY")]),t._v("：查询中若包含任何复杂的子部分，最外层查询被标记为 PRIMARY")]),t._v(" "),a("li",[a("strong",[t._v("SUBQUERY")]),t._v("：在 select 或 where 列表中包含了子查询")]),t._v(" "),a("li",[a("strong",[t._v("DERIVED")]),t._v("：在 from 列表中包含的子查询被标记为 DERIVED，mysql 会递归执行这些子查询，把结果放在临时表里")]),t._v(" "),a("li",[a("strong",[t._v("UNION")]),t._v("：若第二个 select 出现在 UNION 之后，则被标记为 UNION，若 UNION 包含在 from 子句的子查询中，外层 select 将被标记为 DERIVED")]),t._v(" "),a("li",[a("strong",[t._v("UNION RESULT")]),t._v("：从 UNION 表获取结果的 select")])])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("table")])]),t._v("（显示这一行的数据是关于哪张表的）")])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("partitions")])]),t._v("（匹配的分区信息，高版本才有的）")])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("type")])]),t._v("（显示查询使用了那种类型，从最好到最差依次排列 "),a("strong",[t._v("system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL")]),t._v(" ）")]),t._v(" "),a("ul",[a("li",[t._v("system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现")]),t._v(" "),a("li",[t._v("const：通过主键或唯一索引查找时，表中最多返回一条数据")]),t._v(" "),a("li",[t._v("eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描")]),t._v(" "),a("li",[t._v("ref：使用非唯一性索引查询，返回匹配某个索引值的所有行")]),t._v(" "),a("li",[t._v("ref_or_null：当对普通二级索引进行等值匹配查询，该索引列的值也可以是"),a("code",[t._v("NULL")]),t._v("值时，那么对该表的访问方法就可能是ref_or_null")]),t._v(" "),a("li",[t._v("index_merge: 在某些场景下可以使用"),a("code",[t._v("Intersection")]),t._v("、"),a("code",[t._v("Union")]),t._v("、"),a("code",[t._v("Sort-Union")]),t._v("这三种索引合并的方式来执行查询")]),t._v(" "),a("li",[t._v("range：只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的 where 语句中出现了between、<、>、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引")]),t._v(" "),a("li",[t._v("index：全表扫描,但仅扫描索引树（"),a("strong",[t._v("也就是说虽然 all 和 index 都是读全表，但 index 是从索引中读取的，而 all 是从硬盘中读的")]),t._v("）")]),t._v(" "),a("li",[t._v("all：全表扫描，将遍历全表找到匹配的行")])]),t._v(" "),a("blockquote",[a("p",[t._v("一般来说，得保证查询至少达到 range 级别，最好到达 ref")])])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("possible_keys")])]),t._v("（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）")])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("key")])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("实际使用的索引，如果为NULL，则没有使用索引")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("查询中若指定了使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在 key 列表中")]),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-key.png",alt:""}})])])])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("key_len")])])]),t._v(" "),a("ul",[a("li",[t._v("表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好")]),t._v(" "),a("li",[t._v("key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即 key_len 是根据表定义计算而得，不是通过表内检索出的")])])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("ref")])]),t._v(" （显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-ref.png",alt:""}})])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("rows")])]),t._v(" （根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）")])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("filtered")])]),t._v("（某个表经过搜索条件过滤后剩余记录条数的百分比）")])]),t._v(" "),a("li",[a("p",[a("mark",[a("strong",[t._v("Extra")])]),t._v("（包含不适合在其他列中显示但十分重要的额外信息）")]),t._v(" "),a("p",[t._v("额外信息有好几十个，我们看几个常见的")]),t._v(" "),a("ol",[a("li",[a("p",[a("font",{attrs:{color:"red"}},[a("code",[t._v("using filesort")])]),t._v("：说明 MySQL 会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。MySQL 中无法利用索引完成的排序操作称为“文件排序”"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-extra-using-filesort.png",alt:""}})],1)]),t._v(" "),a("li",[a("p",[a("font",{attrs:{color:"red"}},[a("code",[t._v("Using temporary")])]),t._v("：使用了临时表保存中间结果，比如去重、排序之类的，比如我们在执行许多包含"),a("code",[t._v("DISTINCT")]),t._v("、"),a("code",[t._v("GROUP BY")]),t._v("、"),a("code",[t._v("UNION")]),t._v("等子句的查询过程中，如果不能有效利用索引来完成查询，"),a("code",[t._v("MySQL")]),t._v("很有可能寻求通过建立内部的临时表来执行查询。"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-extra-using-tmp.png",alt:""}})],1)]),t._v(" "),a("li",[a("p",[a("font",{attrs:{color:"red"}},[a("code",[t._v("using index")])]),t._v("：表示相应的 select 操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现 "),a("code",[t._v("using where")]),t._v("，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-extra-using-index.png",alt:""}})],1)]),t._v(" "),a("li",[a("p",[a("code",[t._v("using where")]),t._v("：当某个搜索条件需要在"),a("code",[t._v("server层")]),t._v("进行判断时"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-extra-using-where.png",alt:""}})])]),t._v(" "),a("li",[a("p",[a("code",[t._v("using join buffer")]),t._v("：使用了连接缓存"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-extra-using-join-buffer.png",alt:""}})])]),t._v(" "),a("li",[a("p",[a("code",[t._v("impossible where")]),t._v("：where 子句的值总是 false，不能用来获取任何元祖"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-extra-impossible-where.png",alt:""}})])]),t._v(" "),a("li",[a("p",[a("code",[t._v("Using index condition")]),t._v(" : 查询使用了索引，但是查询条件不能完全由索引本身来满足"),a("img",{attrs:{src:"https://img.starfish.ink/mysql/explain-extra-using-index-condition.png",alt:""}})]),t._v(" "),a("p",[a("code",[t._v("Using index condition")]),t._v("通常出现在以下几种情况：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("索引条件下推（Index Condition Pushdown, ICP）")]),t._v("：这是 MySQL 的一个优化策略，它将查询条件的过滤逻辑“下推”到存储引擎层，而不是在服务器层处理。这样可以减少从存储引擎检索的数据量，从而提高查询效率。")]),t._v(" "),a("li",[a("strong",[t._v("部分索引")]),t._v("：当查询条件只涉及索引的一部分列时，MySQL 可以使用索引来快速定位到满足条件的行，但是可能需要回表（即访问表的实际数据行）来检查剩余的条件。")]),t._v(" "),a("li",[a("strong",[t._v("复合索引")]),t._v("：在使用复合索引（即索引包含多个列）的情况下，如果查询条件只匹配索引的前几列，那么剩余的列可能需要通过 "),a("code",[t._v("Using index condition")]),t._v(" 来进一步过滤。")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("select tables optimized away")]),t._v("：在没有 group by 子句的情况下，基于索引优化操作或对于 MyISAM 存储引擎优化COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("distinct")]),t._v("：优化 distinct 操作，在找到第一匹配的元祖后即停止找同样值的动作")])])])])]),t._v(" "),a("blockquote",[a("p",[t._v("在 MySQL 的 EXPLAIN 输出中，"),a("code",[t._v("possible_keys")]),t._v(" 和 "),a("code",[t._v("key")]),t._v(" 这两个字段看似相似，但实际上提供了不同的信息：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("possible_keys")]),t._v("：显示 MySQL 可能使用哪些索引来查找表中的行。")]),t._v(" "),a("li",[a("code",[t._v("key")]),t._v("：显示 MySQL 实际决定使用的索引。")])]),t._v(" "),a("p",[t._v("为什么两者都需要？")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("优化潜力")]),t._v("： "),a("code",[t._v("possible_keys")]),t._v(" 显示了所有可能的选项，而 "),a("code",[t._v("key")]),t._v(" 显示了优化器最终的选择。这种对比可以帮助数据库管理员（DBA）了解是否有更好的索引选择。")]),t._v(" "),a("li",[a("strong",[t._v("查询分析")]),t._v("： 通过比较 "),a("code",[t._v("possible_keys")]),t._v(" 和 "),a("code",[t._v("key")]),t._v("，我们可以了解优化器的决策过程，这对于复杂查询的优化非常有用。")]),t._v(" "),a("li",[a("strong",[t._v("索引使用情况")]),t._v("： "),a("code",[t._v("possible_keys")]),t._v(" 可能列出多个索引，而 "),a("code",[t._v("key")]),t._v(" 只会显示实际使用的一个。这有助于识别冗余索引或缺失的索引。")]),t._v(" "),a("li",[a("strong",[t._v("优化器行为")]),t._v("： 有时，"),a("code",[t._v("possible_keys")]),t._v(" 可能列出多个索引，但 "),a("code",[t._v("key")]),t._v(" 可能是 NULL，这表明 MySQL 认为不使用索引更有效。")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-一般你们怎么建-mysql-索引-基于什么原则-遇到过索引失效的情况么-怎么优化的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-一般你们怎么建-mysql-索引-基于什么原则-遇到过索引失效的情况么-怎么优化的"}},[t._v("#")]),t._v(" 🎯 一般你们怎么建 MySQL 索引，基于什么原则，遇到过索引失效的情况么，怎么优化的?")]),t._v(" "),a("h4",{attrs:{id:"_1-mysql索引建立的原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql索引建立的原则"}},[t._v("#")]),t._v(" 1. MySQL索引建立的原则")]),t._v(" "),a("blockquote",[a("ol",[a("li",[t._v("最左前缀匹配原则，非常重要的原则，MySQL 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如 "),a("code",[t._v("a = 1 and b = 2 and c > 3 and d = 4")]),t._v(" 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。")]),t._v(" "),a("li",[t._v("=和in可以乱序，比如 "),a("code",[t._v("a = 1 and b = 2 and c = 3")]),t._v("  建立(a,b,c)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。")]),t._v(" "),a("li",[t._v("尽量选择"),a("strong",[t._v("区分度高")]),t._v("的列作为索引，区分度的公式是 "),a("code",[t._v("区分度 = distinct(col)/count(*)")]),t._v("，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。")]),t._v(" "),a("li",[t._v("索引列不能参与计算，保持列“干净”，比如  "),a("code",[t._v("from_unixtime(create_time) = ’2014-05-29’")]),t._v("  就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成 "),a("code",[t._v("create_time = unix_timestamp(’2014-05-29’)")]),t._v("。")]),t._v(" "),a("li",[t._v("尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加 (a,b) 的索引，那么只需要修改原来的索引即可。")])])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("选择合适的列")]),t._v("：优先考虑在查询条件、排序（"),a("code",[t._v("ORDER BY")]),t._v("）、分组（"),a("code",[t._v("GROUP BY")]),t._v("）、连接（"),a("code",[t._v("JOIN")]),t._v("）中频繁使用的列上建立索引。这些列通常对查询性能有显著影响。")]),t._v(" "),a("li",[a("strong",[t._v("唯一性")]),t._v("：在唯一性要求较高的列上建立唯一索引（"),a("code",[t._v("UNIQUE")]),t._v("），如ID号、邮箱等。唯一索引不仅能加快查询速度，还能保证数据的唯一性。")]),t._v(" "),a("li",[a("strong",[t._v("覆盖索引")]),t._v("：尽量选择创建覆盖索引（即索引包含了查询所需的所有列），避免回表操作。这样可以显著提升查询性能，尤其是涉及多列的查询。")]),t._v(" "),a("li",[a("strong",[t._v("前缀索引")]),t._v("：对于文本类型（如"),a("code",[t._v("VARCHAR")]),t._v("、"),a("code",[t._v("TEXT")]),t._v("）的列，如果列值较长且前缀具有较高区分度，可以使用前缀索引来节省空间和提高查询效率。")]),t._v(" "),a("li",[a("strong",[t._v("复合索引")]),t._v("：在多个列上建立复合索引（即组合索引），以优化涉及多列的查询。但要注意列的顺序，通常将选择性更高的列放在最前面。")]),t._v(" "),a("li",[a("strong",[t._v("考虑查询频率")]),t._v("：根据查询的频率和响应时间要求，对高频查询的列进行索引优化。在写操作频繁的表上，要平衡索引的数量，以避免过多索引导致的插入和更新性能下降。")]),t._v(" "),a("li",[a("strong",[t._v("避免过多索引")]),t._v("：虽然索引可以加快查询速度，但过多的索引会增加插入、更新、删除操作的成本。因此，需要在查询性能和写性能之间取得平衡。")])]),t._v(" "),a("h4",{attrs:{id:"_2-常见的索引失效情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-常见的索引失效情况"}},[t._v("#")]),t._v(" 2. 常见的索引失效情况")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("查询条件中使用了函数或表达式")]),t._v("：当在查询条件中对索引列使用了函数或表达式（如"),a("code",[t._v("UPPER(column_name)")]),t._v("），索引可能失效。MySQL需要扫描所有行来计算函数结果，导致全表扫描。")]),t._v(" "),a("li",[a("strong",[t._v("隐式类型转换")]),t._v("：如果查询条件中的列和参数类型不匹配（如将字符串列与数字比较），MySQL会进行隐式类型转换，导致索引失效。")]),t._v(" "),a("li",[a("strong",[t._v("模糊查询以通配符开头")]),t._v("：使用"),a("code",[t._v("LIKE '%value'")]),t._v("形式的模糊查询时，由于通配符位于开头，索引无法使用，MySQL需要进行全表扫描。")]),t._v(" "),a("li",[a("strong",[t._v("索引列不在最左侧")]),t._v("：对于复合索引，如果查询条件中未使用复合索引的最左侧列，索引将无法使用（“最左前缀”原则）。")]),t._v(" "),a("li",[a("strong",[a("code",[t._v("OR")]),t._v("条件未全部使用索引")]),t._v("：如果查询条件中有"),a("code",[t._v("OR")]),t._v("，且每个条件都未使用索引，则MySQL无法利用索引，需要进行全表扫描。")]),t._v(" "),a("li",[a("strong",[t._v("查询条件中有NULL值")]),t._v("：在某些情况下，索引列的查询条件中如果包含"),a("code",[t._v("IS NULL")]),t._v("或"),a("code",[t._v("IS NOT NULL")]),t._v("，可能会导致索引失效。")]),t._v(" "),a("li",[a("strong",[t._v("查询条件中使用不等号")]),t._v("：使用"),a("code",[t._v("<>")]),t._v("或"),a("code",[t._v("!=")]),t._v("查询条件时，MySQL可能会选择不使用索引，因为这种条件通常需要扫描大量行。")])]),t._v(" "),a("h4",{attrs:{id:"_3-索引优化方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-索引优化方法"}},[t._v("#")]),t._v(" 3. 索引优化方法")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("重构查询")]),t._v("：避免在索引列上使用函数、表达式、隐式类型转换等操作。尽可能让查询条件直接作用于索引列，确保索引生效。")]),t._v(" "),a("li",[a("strong",[t._v("使用合适的类型")]),t._v("：确保查询条件中的类型与列的类型匹配，避免隐式类型转换。")]),t._v(" "),a("li",[a("strong",[t._v("合理使用通配符")]),t._v("：对于模糊查询，尽量避免通配符开头。如果业务允许，可以考虑在应用层进行拆分查询或引入全文索引（"),a("code",[t._v("FULLTEXT")]),t._v("）来处理文本搜索。")]),t._v(" "),a("li",[a("strong",[t._v("优化复合索引的顺序")]),t._v("：根据查询条件的使用情况，调整复合索引的列顺序，确保最左前缀列经常在查询条件中使用。")]),t._v(" "),a("li",[a("strong",[t._v("拆分复杂查询")]),t._v("：对于使用"),a("code",[t._v("OR")]),t._v("的复杂查询，可以尝试将查询拆分为多个子查询，并使用"),a("code",[t._v("UNION")]),t._v("合并结果，确保每个子查询都能利用索引。")]),t._v(" "),a("li",[a("strong",[t._v("使用覆盖索引")]),t._v("：如果可能，创建覆盖索引，使查询能够直接从索引中获取所需数据，避免回表，提高查询效率。")]),t._v(" "),a("li",[a("strong",[t._v("分析查询性能")]),t._v("：使用"),a("code",[t._v("EXPLAIN")]),t._v("命令分析查询的执行计划，检查索引是否被使用。根据执行计划的结果，调整索引设计和查询语句。")]),t._v(" "),a("li",[a("strong",[t._v("定期维护索引")]),t._v("：对于频繁更新的表，定期进行索引重建或优化，以保持索引结构的高效性。")])]),t._v(" "),a("p",[t._v("通过合理的索引设计和优化，可以显著提高MySQL的查询性能。但在实际应用中，需要根据具体的业务需求、数据量和查询频率等因素来灵活调整索引策略，避免索引失效带来的性能问题。")]),t._v(" "),a("blockquote",[a("h5",{attrs:{id:"如何写sql能够有效的使用到复合索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何写sql能够有效的使用到复合索引"}},[t._v("#")]),t._v(" 如何写sql能够有效的使用到复合索引？")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("全值匹配我最爱")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("最佳左前缀法则")]),t._v("，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)")])]),t._v(" "),a("li",[a("p",[t._v("不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描")])]),t._v(" "),a("li",[a("p",[t._v("存储引擎不能使用索引中范围条件右边的列")])]),t._v(" "),a("li",[a("p",[t._v("尽量使用"),a("strong",[t._v("覆盖索引")]),t._v("(只访问索引的查询(索引列和查询列一致))，减少select")])]),t._v(" "),a("li",[a("p",[t._v("is null ,is not null 也无法使用索引")])]),t._v(" "),a("li",[a("p",[t._v('like "xxxx%" 是可以用到索引的，like "%xxxx" 则不行(like "%xxx%" 同理)。like以通配符开头(\'%abc...\')索引失效会变成全表扫描的操作，')])]),t._v(" "),a("li",[a("p",[t._v("字符串不加单引号索引失效")])]),t._v(" "),a("li",[a("p",[t._v("少用or，用它来连接时会索引失效")])]),t._v(" "),a("li",[a("p",[t._v("<，<=，=，>，>=，BETWEEN，IN 可用到索引，<>，not in ，!= 则不行，会导致全表扫描")])]),t._v(" "),a("li",[a("p",[t._v("前缀索引：前缀索引就是用某个字段中，字符串的前几个字符建立索引，比如我们可以在订单表上对商品名称字段的前 5 个字符建立索引。使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。")]),t._v(" "),a("p",[t._v("但是，前缀索引有一定的局限性，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-一条sql执行过长的时间-你如何优化-从哪些方面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-一条sql执行过长的时间-你如何优化-从哪些方面"}},[t._v("#")]),t._v(" 🎯 一条sql执行过长的时间，你如何优化，从哪些方面？")]),t._v(" "),a("ol",[a("li",[t._v("查看sql是否涉及多表的联表或者子查询，如果有，看是否能进行业务拆分，相关字段冗余或者合并成临时表（业务和算法的优化）")]),t._v(" "),a("li",[t._v("涉及连表的查询，是否能进行分表查询，单表查询之后的结果进行字段整合")]),t._v(" "),a("li",[t._v("如果以上两种都不能操作，非要连表查询，那么考虑对相对应的查询条件做索引。加快查询速度")]),t._v(" "),a("li",[t._v("针对数量大的表进行历史表分离（如交易流水表）")]),t._v(" "),a("li",[t._v("数据库主从分离，读写分离，降低读写针对同一表同时的压力，至于主从同步，mysql有自带的binlog实现 主从同步")]),t._v(" "),a("li",[t._v("explain分析sql语句，查看执行计划，分析索引是否用上，分析扫描行数等等")]),t._v(" "),a("li",[t._v("查看mysql执行日志，看看是否有其他方面的问题")])]),t._v(" "),a("h3",{attrs:{id:"大表优化思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大表优化思路"}},[t._v("#")]),t._v(" 大表优化思路？")]),t._v(" "),a("p",[t._v("大表优化我一般从几个层面考虑：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("存储层面")]),t._v("：分库分表、冷热数据分离；")]),t._v(" "),a("li",[a("strong",[t._v("索引层面")]),t._v("：建合适的联合索引、覆盖索引，必要时用分区表；")]),t._v(" "),a("li",[a("strong",[t._v("SQL 层面")]),t._v("：避免全表扫描、避免函数导致索引失效、批量处理代替逐行；")]),t._v(" "),a("li",[a("strong",[t._v("维护层面")]),t._v("：归档历史数据、定期优化表结构；")]),t._v(" "),a("li",[a("strong",[t._v("架构层面")]),t._v("：读写分离、引入缓存、甚至用 Elasticsearch/ClickHouse 处理分析类查询。\n通过这些手段，把大表的单次查询和维护压力控制在可接受范围内。")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"八、分库分表与集群-🚀"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、分库分表与集群-🚀"}},[t._v("#")]),t._v(" 八、分库分表与集群 🚀")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql分区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql分区"}},[t._v("#")]),t._v(" 🎯 MySQL分区？")]),t._v(" "),a("p",[t._v("一般情况下我们创建的表对应一组存储文件")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("未分区的表文件结构")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("MyISAM引擎")]),t._v("： "),a("code",[t._v(".frm")]),t._v("（表结构） + "),a("code",[t._v(".MYD")]),t._v("（数据文件） + "),a("code",[t._v(".MYI")]),t._v("（索引文件） "),a("em",[t._v("例如："),a("code",[t._v("user.frm")]),t._v("、"),a("code",[t._v("user.MYD")]),t._v("、"),a("code",[t._v("user.MYI")])])]),t._v(" "),a("li",[a("strong",[t._v("InnoDB引擎")]),t._v("： "),a("code",[t._v(".frm")]),t._v("（表结构） + "),a("code",[t._v(".ibd")]),t._v("（数据+索引文件） "),a("em",[t._v("例如："),a("code",[t._v("user.frm")]),t._v("、"),a("code",[t._v("user.ibd")])])])])])]),t._v(" "),a("p",[t._v("当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("分区后的表文件结构")]),t._v(" 每个分区对应独立的物理文件，文件命名规则为： "),a("code",[t._v("表名#分区名.ibd")]),t._v(" "),a("em",[t._v("例如："),a("code",[t._v("user#p0.ibd")]),t._v("、"),a("code",[t._v("user#p1.ibd")])])])]),t._v(" "),a("p",[t._v("MySQL分区是一种数据库优化技术，通过将表的数据划分为更小、更易管理的部分，来提高查询性能和管理效率。下面是关于MySQL分区的一些关键点，适合在面试中讨论：")]),t._v(" "),a("p",[a("strong",[t._v("能干嘛")])]),t._v(" "),a("ul",[a("li",[t._v("逻辑数据分割")]),t._v(" "),a("li",[t._v("提高单一的写和读应用速度")]),t._v(" "),a("li",[t._v("提高分区范围读查询的速度")]),t._v(" "),a("li",[t._v("分割数据能够有多个不同的物理文件路径")]),t._v(" "),a("li",[t._v("高效的保存历史数据")])]),t._v(" "),a("p",[a("strong",[t._v("分区类型及操作")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("类型")]),t._v(" "),a("th",[t._v("说明")]),t._v(" "),a("th",[t._v("适用场景")]),t._v(" "),a("th",[t._v("性能风险点")]),t._v(" "),a("th",[t._v("示例场景")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[t._v("RANGE")])]),t._v(" "),a("td",[t._v("基于属于一个给定连续区间的列值，把多行分配给分区")]),t._v(" "),a("td",[t._v("时间序列、连续数值")]),t._v(" "),a("td",[t._v("数据倾斜导致热点分区（如最新月）")]),t._v(" "),a("td",[t._v("订单表按创建年份分区")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("LIST")])]),t._v(" "),a("td",[t._v("按列表划分，类似于RANGE分区，但使用的是明确的值列表")]),t._v(" "),a("td",[t._v("离散枚举值（地区、状态）")]),t._v(" "),a("td",[t._v("分区键值变更需重构分区")]),t._v(" "),a("td",[t._v("用户表按国家代码分区")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("HASH")])]),t._v(" "),a("td",[t._v("按哈希算法划分，将数据根据某个列的哈希值均匀分布到不同的分区中")]),t._v(" "),a("td",[t._v("均匀分布请求压力")]),t._v(" "),a("td",[t._v("扩容需重新计算哈希分布")]),t._v(" "),a("td",[t._v("评论表按用户ID哈希分区")])]),t._v(" "),a("tr",[a("td",[a("strong",[t._v("KEY")])]),t._v(" "),a("td",[t._v("类似于HASH分区，但使用MySQL内部的哈希函数")]),t._v(" "),a("td",[t._v("非整型字段的均匀分布")]),t._v(" "),a("td",[t._v("依赖MySQL内置哈希算法")]),t._v(" "),a("td",[t._v("日志表按UUID前缀分区")])])])]),t._v(" "),a("p",[a("strong",[t._v("看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？")])]),t._v(" "),a("ul",[a("li",[t._v("分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁")]),t._v(" "),a("li",[t._v("一旦数据并发量上来，如果在分区表实施关联，就是一个灾难")]),t._v(" "),a("li",[t._v("自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控")])]),t._v(" "),a("h3",{attrs:{id:"🎯-如何确定分库还是分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-如何确定分库还是分表"}},[t._v("#")]),t._v(" 🎯 如何确定分库还是分表？")]),t._v(" "),a("blockquote",[a("p",[t._v("针对“如何确定分库还是分表？”的问题，你要结合具体的场景。")])]),t._v(" "),a("p",[a("strong",[t._v("何时分表")])]),t._v(" "),a("p",[t._v("当数据量过大造成事务执行缓慢时，就要考虑分表，因为减少每次查询数据总量是解决数据查询缓慢的主要原因。你可能会问：“查询可以通过主从分离或缓存来解决，为什么还要分表？”但这里的查询是指事务中的查询和更新操作。")]),t._v(" "),a("p",[a("strong",[t._v("何时分库")])]),t._v(" "),a("p",[t._v("为了应对高并发，一个数据库实例撑不住，即单库的性能无法满足高并发的要求，就把并发请求分散到多个实例中去")]),t._v(" "),a("p",[t._v("总的来说，分库分表使用的场景不一样：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("分表是因为数据量比较大，导致事务执行缓慢；")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("分库是因为单库的性能无法满足要求。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql分库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql分库"}},[t._v("#")]),t._v(" 🎯 MySQL分库?")]),t._v(" "),a("p",[a("strong",[t._v("为什么要分库?")])]),t._v(" "),a("p",[t._v("数据库集群环境后都是多台 slave，基本满足了读取操作;  但是写入或者说大数据、频繁的写入操作对 master 性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。")]),t._v(" "),a("p",[a("strong",[t._v("分库是什么？")])]),t._v(" "),a("p",[t._v("一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。")]),t._v(" "),a("p",[a("strong",[t._v("分库的优点：")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("减少增量数据写入时的锁对查询的影响")])]),t._v(" "),a("li",[a("p",[t._v("由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短")])])]),t._v(" "),a("p",[t._v("但是它无法解决单表数据量太大的问题")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql分表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql分表"}},[t._v("#")]),t._v(" 🎯 MySQL分表?")]),t._v(" "),a("p",[t._v("分表有两种分割方式，一种垂直拆分，另一种水平拆分。")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("垂直拆分")])]),t._v(" "),a("p",[t._v("垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("水平拆分(数据分片)")])]),t._v(" "),a("p",[t._v("单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。")]),t._v(" "),a("p",[t._v("水平分割的几种方法：")]),t._v(" "),a("ul",[a("li",[t._v("使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。")]),t._v(" "),a("li",[t._v("还可根据时间放入不同的表，比如：article_201601，article_201602。")]),t._v(" "),a("li",[t._v("按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。")]),t._v(" "),a("li",[t._v("根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-分布式id生成方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-分布式id生成方案"}},[t._v("#")]),t._v(" 🎯 分布式ID生成方案？")]),t._v(" "),a("blockquote",[a("p",[t._v("分库分表之后，id主键如何处理？")]),t._v(" "),a("p",[t._v("推荐：https://zhuanlan.zhihu.com/p/107939861")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("UUID："),a("code",[t._v("UUID")]),t._v("的生成简单到只有一行代码，输出结果 "),a("code",[t._v("c2b8c2b9e46c47e3b30dca3b0d447718")]),t._v("，但UUID却并不适用于实际的业务需求。像用作订单号"),a("code",[t._v("UUID")]),t._v("这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务"),a("code",[t._v("主键ID")]),t._v("，它不仅是太长还是字符串，而且不是自增的，存储性能差查询也很耗时，所以不推荐用作"),a("code",[t._v("分布式ID")]),t._v("。")]),t._v(" "),a("blockquote",[a("p",[t._v("UUID 最大的缺陷是它产生的 ID 不是递增的。一般来说，我们倾向于在数据库中使用自增主键，因为这样可以迫使数据库的树朝着一个方向增长，而不会造成中间叶节点分裂，这样插入性能最好。而整体上 UUID 生成的 ID 可以看作是随机，那么就会导致数据往页中间插入，引起更加频繁地页分裂，在糟糕的情况下，这种分裂可能引起连锁反应，整棵树的树形结构都会受到影响。所以我们普遍倾向于采用递增的主键。")])])]),t._v(" "),a("li",[a("p",[t._v("数据库自增ID：需要一个单独的MySQL实例用来生成ID（DB单点存在宕机风险，无法扛住高并发场景）")])]),t._v(" "),a("li",[a("p",[t._v("数据库多主模式")])]),t._v(" "),a("li",[a("p",[t._v("号段模式")])]),t._v(" "),a("li",[a("p",[t._v("Redis：利用"),a("code",[t._v("redis")]),t._v("的 "),a("code",[t._v("incr")]),t._v("命令实现ID的原子性自增。")])]),t._v(" "),a("li",[a("p",[t._v("雪花算法（SnowFlake）："),a("code",[t._v("Snowflake")]),t._v("生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特")]),t._v(" "),a("p",[t._v("Snowflake ID 组成结构："),a("code",[t._v("正数位")]),t._v("（占1比特）+ "),a("code",[t._v("时间戳")]),t._v("（占41比特）+ "),a("code",[t._v("机器ID")]),t._v("（占5比特）+ "),a("code",[t._v("数据中心")]),t._v("（占5比特）+ "),a("code",[t._v("自增值")]),t._v("（占12比特），总共64比特组成的一个Long类型。")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("缺点")]),t._v("：时钟回拨需特殊处理")]),t._v(" "),a("li",[t._v("改进：\n"),a("ul",[a("li",[t._v("百度UidGenerator：自定义时间位、引入RingBuffer")]),t._v(" "),a("li",[t._v("美团Leaf：混用号段模式应对时钟问题")])])])])]),t._v(" "),a("li",[a("p",[t._v("滴滴出品（TinyID）：基于ZooKeeper的号段服务化")])]),t._v(" "),a("li",[a("p",[t._v("百度 （Uidgenerator）")])]),t._v(" "),a("li",[a("p",[t._v("美团（Leaf）：号段模式 + 双Buffer预加载")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-分库分表容量是怎么确定的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-分库分表容量是怎么确定的"}},[t._v("#")]),t._v(" 🎯 分库分表容量是怎么确定的？")]),t._v(" "),a("p",[a("strong",[t._v("容量确定的原则")])]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("单表数据量控制：")])]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("建议单表数据量控制在")]),t._v("500万到2000万 条记录以内。")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("单表数据量超过阈值")])]),t._v(" "),a("ul",[a("li",[t._v("行数阈值：单表行数超过500万（一般建议）或2000万（B+树存储结构限制，3层树高对应约2000万行数据，查询效率最优）。")]),t._v(" "),a("li",[a("strong",[t._v("表容量阈值")]),t._v("：单表存储超过2GB，尤其是包含大字段（如BLOB、TEXT）时，读写性能显著下降")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("原因")]),t._v("：单表数据量过大，可能导致查询和索引效率下降，备份和恢复时间也会变长。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("单库数据量控制：")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("建议单库的数据量不超过")]),t._v("100GB。")]),t._v(" "),a("li",[a("strong",[t._v("原因")]),t._v("：单库数据量过大，可能导致磁盘I/O成为瓶颈，影响数据库性能。")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("分片数量规划：")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("预留空间")]),t._v("：根据未来的数据增长预期，预留足够的分片数量，避免频繁扩容。")]),t._v(" "),a("li",[a("strong",[t._v("均衡分布")]),t._v("：确保数据在各个分片之间均匀分布，避免出现热点分片。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-id哈希映射分库的话会产生什么问题-如何解决"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-id哈希映射分库的话会产生什么问题-如何解决"}},[t._v("#")]),t._v(" 🎯 id哈希映射分库的话会产生什么问题？如何解决？")]),t._v(" "),a("p",[t._v("使用 "),a("strong",[t._v("ID 哈希映射")]),t._v("进行分库时，会将数据分散到不同的数据库实例或节点上，基于用户 ID 或其他字段的哈希值来决定数据的存储位置。这种方法看似能解决大规模数据的存储和查询性能问题，但在实际操作中会带来一些挑战和问题。")]),t._v(" "),a("ol",[a("li",[a("p",[a("strong",[t._v("数据倾斜 (Data Skew)")])]),t._v(" "),a("p",[t._v("问题**： 哈希映射的目的是均匀分散数据到多个数据库中，但如果哈希函数或分库策略不合理，可能导致某些数据库或分片存储的数据量远大于其他数据库，产生"),a("strong",[t._v("数据倾斜")]),t._v("，也就是数据分布不均匀。这样，某些数据库会成为性能瓶颈。**")]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("改进哈希函数")]),t._v("：选择更加均匀的哈希算法，避免出现某些特定范围的值过于集中。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("范围分片")]),t._v("：有时可以结合哈希分片与范围分片（例如，按地域、注册时间等划分）来确保更均匀的数据分布。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("分片重新分配")]),t._v("：在检测到数据倾斜后，可以定期或动态地调整数据的分布，通过数据迁移来平衡负载。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("跨库查询复杂度增加 (Cross-shard Querying)")])]),t._v(" "),a("p",[t._v("问题： 使用哈希分库后，查询可能会涉及多个数据库，尤其是当查询需要合并不同分片的数据时。传统的 JOIN 或聚合查询跨越多个分库时会变得非常复杂和低效，尤其是如果分库策略没有设计好，查询性能会显著下降。")]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("避免跨库 JOIN")]),t._v("：尽量避免需要跨多个分片或数据库的复杂 JOIN 操作。通过数据 denormalization 或者将数据聚合到单个数据库中来减少跨库查询的复杂度。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("分库查询优化")]),t._v("：当跨库查询不可避免时，可以使用 "),a("strong",[t._v("分布式查询引擎")]),t._v(" 或中间件（例如 "),a("strong",[t._v("Hadoop")]),t._v(", "),a("strong",[t._v("Presto")]),t._v(", "),a("strong",[t._v("Apache Drill")]),t._v("）来优化跨库查询。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("聚合和计算预处理")]),t._v("：如果查询频繁，考虑将结果预计算并存储（例如，通过缓存或者周期性计算）。减少实时计算的需求，提升查询性能。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据迁移与扩展困难 (Data Migration and Scaling)")])]),t._v(" "),a("p",[t._v("问题： 当数据量增加时，可能需要重新划分分片或迁移数据。在哈希映射的分库策略下，若重新划分分库或添加新的分片，现有的数据必须重新哈希并迁移到新的数据库实例，这个过程会非常复杂，且可能需要停机或者长时间的迁移操作。")]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("分片重新平衡")]),t._v("：设计支持"),a("strong",[t._v("动态扩展")]),t._v("和分片重新平衡的机制。使用可以实时调整的 "),a("strong",[t._v("虚拟节点")]),t._v(" 或 "),a("strong",[t._v("哈希槽")]),t._v(" 来减少数据迁移的复杂性。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("使用分布式数据库系统")]),t._v("：一些分布式数据库系统（如 "),a("strong",[t._v("Cassandra")]),t._v(", "),a("strong",[t._v("CockroachDB")]),t._v("）提供自动扩展和数据迁移的能力，可以在不中断服务的情况下平衡分片和迁移数据。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("预留扩展性")]),t._v("：在设计分库方案时，可以预留扩展的空间，并考虑将来可能需要添加更多分库或分片的情况。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("跨库事务管理 (Distributed Transactions)")])]),t._v(" "),a("p",[t._v("问题： 哈希分库导致数据分布在多个数据库中，而在一些操作中可能需要跨多个数据库的事务操作。例如，用户在多个数据库中有数据需要更新或修改时，如何保证事务的一致性（即 ACID 特性）就变得非常复杂。")]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("使用 Saga 模式")]),t._v("：Saga 是一种长事务模式，将一个大的分布式事务分解成多个小的子事务，并在子事务失败时通过补偿操作进行回滚。适用于大多数分布式事务场景，尤其是对于微服务架构中的分布式数据更新。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("采用最终一致性")]),t._v("：在一些业务场景中，避免使用强一致性，而是采用"),a("strong",[t._v("最终一致性")]),t._v("来允许系统在短时间内不一致，但最终会恢复一致性。可以使用消息队列或事件驱动的方式来保证数据的最终一致性。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("分布式事务管理器")]),t._v("：使用分布式事务管理器（如 "),a("strong",[t._v("Atomikos")]),t._v(" 或 "),a("strong",[t._v("Narayana")]),t._v("）来处理跨多个数据库的事务。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("查找和聚合性能差 (Lookup and Aggregation Performance)")])]),t._v(" "),a("p",[t._v("问题： 哈希映射分库后，对于某些查询（如获取某个用户的所有数据或跨多个分片进行聚合查询），如果不采取合适的优化策略，查找和聚合性能会大大下降。")]),t._v(" "),a("p",[a("strong",[t._v("解决方案")]),t._v("：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("数据冗余")]),t._v("：可以使用 "),a("strong",[t._v("数据冗余")]),t._v(" 或 "),a("strong",[t._v("复制")]),t._v(" 来减少跨库查询。例如，某些字段的冗余存储可以提高查询效率，避免每次都跨多个分片查询。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("聚合操作分片")]),t._v("：对于聚合类操作，采用 "),a("strong",[t._v("分布式计算框架")]),t._v("（如 "),a("strong",[t._v("Apache Spark")]),t._v("、"),a("strong",[t._v("Flink")]),t._v("）来进行分片内聚合，然后再合并结果。")])])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据一致性和延迟问题 (Consistency and Latency)")])]),t._v(" "),a("p",[t._v("问题： 在分库哈希策略中，可能会因为多个数据库或分片的网络延迟而引入一定的延迟问题，尤其是在高并发环境下，多个数据库的访问可能会导致较高的延迟，影响用户体验。")]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("本地缓存与副本")]),t._v("：通过使用本地缓存（如 "),a("strong",[t._v("Redis")]),t._v("）来减少对远程数据库的访问，提升响应速度。同时，可以在多个分片之间保持副本，提高数据访问速度。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("数据同步机制")]),t._v("：采用实时或批量数据同步机制，将热点数据或常用数据同步到访问频繁的分片。")])])])])]),t._v(" "),a("h3",{attrs:{id:"集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群"}},[t._v("#")]),t._v(" 集群")]),t._v(" "),a("blockquote",[a("p",[t._v("配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道")])]),t._v(" "),a("h3",{attrs:{id:"🎯-说下-mysql-主从"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说下-mysql-主从"}},[t._v("#")]),t._v(" 🎯 说下 MySQL 主从？")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("什么是 MySQL 主从复制？")]),t._v(" "),a("ul",[a("li",[t._v("主从复制用于建立一个或多个与主库相同的数据库，称为从库，实现读写分离，提高并发处理能力。")])])]),t._v(" "),a("li",[a("strong",[t._v("主从复制的作用是什么？")]),t._v(" "),a("ul",[a("li",[t._v("主从复制用于数据热备份、架构扩展、提高并发处理能力，实现读写分离。")])])]),t._v(" "),a("li",[a("strong",[t._v("MySQL 主从复制是如何实现的？")]),t._v(" "),a("ul",[a("li",[t._v("主从复制通过 I/O 线程和 SQL 线程实现，I/O 线程负责从主库请求 binlog，SQL 线程负责将 binlog 应用到从库。")])])]),t._v(" "),a("li",[a("strong",[t._v("主从复制可能会遇到哪些问题？")]),t._v(" "),a("ul",[a("li",[t._v("可能遇到的问题包括复制延迟、数据不一致、锁表导致的阻塞、宕机导致的数据丢失。")])])]),t._v(" "),a("li",[a("strong",[t._v("如何解决主从复制的问题？")]),t._v(" "),a("ul",[a("li",[t._v("可以通过半同步复制策略减少数据丢失风险，采用并行复制减少复制延迟。")])])]),t._v(" "),a("li",[a("strong",[t._v("什么是 MySQL 集群？")]),t._v(" "),a("ul",[a("li",[t._v("MySQL 集群是一组 MySQL 服务器的集合，它们协同工作以提供高可用性、负载均衡和读写分离。")])])]),t._v(" "),a("li",[a("strong",[t._v("MySQL 集群有哪些类型？")]),t._v(" "),a("ul",[a("li",[t._v("包括主从集群、互主集群、Galera 集群等，每种集群有其特定的应用场景和特点。")])])]),t._v(" "),a("li",[a("strong",[t._v("如何搭建 MySQL 集群？")]),t._v(" "),a("ul",[a("li",[t._v("搭建 MySQL 集群通常涉及配置多个 MySQL 服务实例，实现主从复制，配置读写分离，以及设置故障转移机制。")])])]),t._v(" "),a("li",[a("strong",[t._v("什么是 GTID 同步集群？")]),t._v(" "),a("ul",[a("li",[t._v("GTID（全局事务 ID）同步集群是一种基于全局唯一 ID 标识事务的复制方式，引入于 MySQL 5.6 版本，用于确保事务在复制集群中的一致性。")])])]),t._v(" "),a("li",[a("strong",[t._v("如何实现 MySQL 的读写分离？")]),t._v(" "),a("ul",[a("li",[t._v("读写分离通常由业务层实现，可以通过智能路由、负载均衡器或中间件如 ShardingSphere、MyCat 来实现。")])])]),t._v(" "),a("li",[a("strong",[t._v("什么是半同步复制？")]),t._v(" "),a("ul",[a("li",[t._v("半同步复制是一种提高数据安全性的机制，主库在事务提交后等待至少一个从库接收并写入 relay log 后才返回客户端响应。")])])]),t._v(" "),a("li",[a("strong",[t._v("MySQL 集群扩容和数据迁移怎么做？")]),t._v(" "),a("ul",[a("li",[t._v("扩容集群可能需要数据迁移，可以通过 mysqldump 工具备份数据，然后在新节点上恢复数据，再配置数据同步。")])])]),t._v(" "),a("li",[a("strong",[t._v("如何解决 MySQL 主从复制的延迟问题？")]),t._v(" "),a("ul",[a("li",[t._v("可以通过优化网络条件、升级硬件、使用并行复制等方法减少延迟。")])])]),t._v(" "),a("li",[a("strong",[t._v("MySQL 集群的高可用性是如何实现的？")]),t._v(" "),a("ul",[a("li",[t._v("高可用性可以通过故障检测、自动故障转移、多副本等机制实现。")])])]),t._v(" "),a("li",[a("strong",[t._v("MySQL 集群中的分库分表是如何考虑的？")]),t._v(" "),a("ul",[a("li",[t._v("分库分表需要考虑数据量、查询模式、业务逻辑等因素，以优化性能和扩展性")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-复制的基本原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-复制的基本原理"}},[t._v("#")]),t._v(" 🎯 复制的基本原理？")]),t._v(" "),a("p",[t._v("主从复制用于建立一个或多个与主库相同的数据库，称为从库，实现读写分离，提高并发处理能力")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("slave 会从 master 读取 binlog 来进行数据同步")])]),t._v(" "),a("li",[a("p",[t._v("三个步骤")]),t._v(" "),a("p",[a("strong",[t._v("1. 主库写入 binlog（Binary Log）")])]),t._v(" "),a("ul",[a("li",[t._v("主库上的所有增删改操作（DDL/DML），都会被记录到 "),a("strong",[t._v("binlog")]),t._v(" 中，形成一条条事件（event）。")]),t._v(" "),a("li",[t._v("binlog 是逻辑日志，记录了 SQL 或行级别的更改。")])]),t._v(" "),a("p",[a("strong",[t._v("2. 从库读取 relay log（中继日志）")])]),t._v(" "),a("ul",[a("li",[t._v("从库会启动一个 "),a("strong",[t._v("I/O 线程")]),t._v("，连接主库，请求新的 binlog。")]),t._v(" "),a("li",[t._v("主库的 "),a("strong",[t._v("binlog dump 线程")]),t._v(" 会把 binlog 内容发送给从库。")]),t._v(" "),a("li",[t._v("从库的 I/O 线程把接收到的内容写入 "),a("strong",[t._v("relay log")]),t._v("（中继日志）。")])]),t._v(" "),a("p",[a("strong",[t._v("3. 从库重放 relay log")])]),t._v(" "),a("ul",[a("li",[t._v("从库启动 "),a("strong",[t._v("SQL 线程")]),t._v("，从 relay log 里取出日志，执行里面的 SQL/行事件，最终更新从库数据。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-一主多从"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-一主多从"}},[t._v("#")]),t._v(" 🎯 MySQL 一主多从？")]),t._v(" "),a("p",[t._v("一旦你提及“一主多从”，面试官很容易设陷阱问你：那大促流量大时，是不是只要多增加几台从库，就可以抗住大促的并发读请求了？")]),t._v(" "),a("p",[t._v("当然不是。")]),t._v(" "),a("p",[t._v("因为从库数量增加，从库连接上来的 I/O 线程也比较多，主库也要创建同样多的 log dump 线程来处理复制的请求，对主库资源消耗比较高，同时还受限于主库的网络带宽。所以在实际使用中，一个主库一般跟 2～3 个从库（1 套数据库，1 主 2 从 1 备主），这就是一主多从的 MySQL 集群结构。")]),t._v(" "),a("p",[t._v("其实，你从 MySQL 主从复制过程也能发现，MySQL 默认是异步模式：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。")]),t._v(" "),a("p",[t._v("而这时，面试官一般会追问你“**MySQL 主从复制还有哪些模型？”**主要有三种。")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("同步复制：事务线程要等待所有从库的复制成功响应。")])]),t._v(" "),a("li",[a("p",[t._v("异步复制：事务线程完全不等待从库的复制成功响应。")])]),t._v(" "),a("li",[a("p",[t._v("半同步复制：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。")])])]),t._v(" "),a("p",[t._v("这种半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。")]),t._v(" "),a("h3",{attrs:{id:"🎯-主从复制的延迟与一致性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-主从复制的延迟与一致性问题"}},[t._v("#")]),t._v(" 🎯 主从复制的延迟与一致性问题")]),t._v(" "),a("blockquote",[a("p",[t._v("MySQL 主从复制是基于 binlog 的异步过程，主库写入 binlog，从库通过 relay log 重放。复制延迟的原因主要有网络问题、主库压力大、从库执行慢、单线程复制瓶颈、大事务等。\n复制延迟会导致读写分离场景下的数据不一致。\n优化方法有：使用 MySQL 5.7+ 的多线程复制，避免大事务，优化从库 SQL 和索引，提升硬件和网络。\n一致性上，可以通过 "),a("strong",[t._v("强制读主库、半同步复制、组复制")]),t._v(" 或 "),a("strong",[t._v("Proxy 层路由策略")]),t._v(" 来解决。")])]),t._v(" "),a("p",[a("strong",[t._v("1. 主从复制原理（简要）")])]),t._v(" "),a("p",[t._v("MySQL 主从复制通常基于 "),a("strong",[t._v("binlog")]),t._v("：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("主库（Master）")]),t._v("：把事务操作写入 "),a("strong",[t._v("binlog")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("从库 I/O 线程")]),t._v("：从主库拉取 binlog，写入 "),a("strong",[t._v("relay log")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("从库 SQL 线程")]),t._v("：读取 relay log，并在从库重放执行。")])]),t._v(" "),a("p",[t._v("因此，从库的数据落后于主库，会存在一定延迟。")]),t._v(" "),a("p",[a("strong",[t._v("2. 延迟的原因")])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("网络延迟")]),t._v("：主从之间的网络传输慢。")]),t._v(" "),a("li",[a("strong",[t._v("主库压力大")]),t._v("：binlog 写入速度快，从库拉取不过来。")]),t._v(" "),a("li",[a("strong",[t._v("从库 SQL 执行性能差")]),t._v("：从库执行 binlog SQL 比主库慢（比如没有合适的索引、单机性能差）。")]),t._v(" "),a("li",[a("strong",[t._v("单线程复制瓶颈（传统复制）")]),t._v("：MySQL 5.6 之前，SQL 线程是单线程，执行大事务时延迟严重。")]),t._v(" "),a("li",[a("strong",[t._v("大事务 / 批量更新")]),t._v("：一次性更新、删除上百万行，导致 binlog 很大，从库应用时间很长。")])]),t._v(" "),a("p",[a("strong",[t._v("3. 一致性问题")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("读写分离下的数据不一致")]),t._v("：如果应用在从库读数据，可能读到的是"),a("strong",[t._v("旧数据")]),t._v("，因为主库刚写入，从库还没同步。")]),t._v(" "),a("li",[a("strong",[t._v("事务一致性问题")]),t._v("：主库写入成功，但从库延迟，导致业务逻辑判断错误（比如库存、余额）。")])]),t._v(" "),a("p",[a("strong",[t._v("4. 解决思路")])]),t._v(" "),a("p",[t._v("（1）减少延迟")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("多线程复制")]),t._v("：MySQL 5.7 开始支持 "),a("strong",[t._v("并行复制")]),t._v("（基于库级并行、基于组提交并行），大幅降低延迟。")]),t._v(" "),a("li",[a("strong",[t._v("优化 SQL")]),t._v(" "),a("ul",[a("li",[t._v("避免大事务，改成小批量操作。")]),t._v(" "),a("li",[t._v("保证主从索引一致，防止从库回放慢。")])])]),t._v(" "),a("li",[a("strong",[t._v("硬件优化")]),t._v("：提升从库磁盘/CPU 性能，减少执行耗时。")]),t._v(" "),a("li",[a("strong",[t._v("网络优化")]),t._v("：使用更低延迟的链路。")])]),t._v(" "),a("p",[t._v("（2）一致性保证")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("强制读主库")]),t._v("：对于关键数据（如支付、库存），读写都走主库。")]),t._v(" "),a("li",[a("strong",[t._v("semi-sync 半同步复制")]),t._v(" "),a("ul",[a("li",[t._v("主库写事务时，至少要等一个从库确认收到 binlog 才返回客户端，保证数据至少写到一个从库。")]),t._v(" "),a("li",[t._v("缺点：降低写性能。")])])]),t._v(" "),a("li",[a("strong",[t._v("组复制 / MGR (MySQL Group Replication)")]),t._v(" "),a("ul",[a("li",[t._v("多主复制，保证强一致性，但性能有损耗。")])])]),t._v(" "),a("li",[a("strong",[t._v("Proxy 层策略")]),t._v(" "),a("ul",[a("li",[t._v("在中间件（如 MyCat、ShardingSphere、ProxySQL）里，对延迟敏感的查询强制走主库，其它查询走从库。")])])]),t._v(" "),a("li",[a("strong",[t._v("延迟监控 + 降级")]),t._v(" "),a("ul",[a("li",[t._v("通过 "),a("code",[t._v("SHOW SLAVE STATUS")]),t._v(" 监控 "),a("code",[t._v("Seconds_Behind_Master")]),t._v("，大于阈值时从库不提供读服务。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-复制的最大问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-复制的最大问题"}},[t._v("#")]),t._v(" 🎯 复制的最大问题")]),t._v(" "),a("ul",[a("li",[t._v("延时")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"九、sql实战编程-💻"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、sql实战编程-💻"}},[t._v("#")]),t._v(" 九、SQL实战编程 💻")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-设计需要注意什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-设计需要注意什么"}},[t._v("#")]),t._v(" 🎯 MySQL 设计需要注意什么?")]),t._v(" "),a("p",[t._v("在设计MySQL数据库时，有许多方面需要注意，以确保数据库的性能、可扩展性、安全性和可维护性")]),t._v(" "),a("ul",[a("li",[t._v("表结构设计："),a("strong",[t._v("规范化")]),t._v("、合适的数据类型")]),t._v(" "),a("li",[t._v("索引：覆盖索引")]),t._v(" "),a("li",[t._v("查询优化：合理使用JOIN")]),t._v(" "),a("li",[t._v("分区与分库分表")])]),t._v(" "),a("h3",{attrs:{id:"🎯-如何在不停机的情况下保证迁移数据的一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-如何在不停机的情况下保证迁移数据的一致性"}},[t._v("#")]),t._v(" 🎯 如何在不停机的情况下保证迁移数据的一致性？")]),t._v(" "),a("p",[t._v("迁移数据时最核心的挑战：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("源库与目标库要保持一致")]),t._v("（全量 + 增量）。")]),t._v(" "),a("li",[a("strong",[t._v("迁移过程不中断业务")]),t._v("（不停机，业务可读写）。")]),t._v(" "),a("li",[a("strong",[t._v("最终一致性")]),t._v("（迁移完成后保证数据不丢、不重、不错）。")])]),t._v(" "),a("p",[a("strong",[t._v("1. 常见方案步骤")])]),t._v(" "),a("p",[t._v("步骤 1：全量迁移")]),t._v(" "),a("ul",[a("li",[t._v("使用工具（如 "),a("strong",[t._v("mysqldump、mydumper、pt-archiver")]),t._v("，或大数据同步工具如 "),a("strong",[t._v("Canal、Debezium、DataX、DTS")]),t._v("）将源库的历史数据 "),a("strong",[t._v("批量导入")]),t._v("到目标库。")]),t._v(" "),a("li",[t._v("这一步通常需要 "),a("strong",[t._v("只读快照")]),t._v(" 或 "),a("strong",[t._v("事务隔离")]),t._v(" 保证导出一致性。")])]),t._v(" "),a("p",[t._v("步骤 2：增量同步")]),t._v(" "),a("ul",[a("li",[t._v("全量迁移的过程中，源库业务仍在写入，这部分数据必须捕捉并同步。")]),t._v(" "),a("li",[t._v("常见做法是基于 "),a("strong",[t._v("binlog")]),t._v("（MySQL）或者 "),a("strong",[t._v("WAL")]),t._v("（Postgres），利用 "),a("strong",[t._v("CDC（Change Data Capture）机制")]),t._v(" 实时同步增量数据到目标库。")]),t._v(" "),a("li",[t._v("代表工具：\n"),a("ul",[a("li",[t._v("MySQL → "),a("strong",[t._v("Canal、Debezium、Maxwell")])]),t._v(" "),a("li",[t._v("Kafka + sink → 目标库")])])])]),t._v(" "),a("p",[t._v("步骤 3：双写验证（可选）")]),t._v(" "),a("ul",[a("li",[t._v("在迁移过程中，业务层可以同时写 "),a("strong",[t._v("源库和目标库")]),t._v("，然后通过 "),a("strong",[t._v("校验服务")]),t._v(" 或 "),a("strong",[t._v("对账机制")]),t._v("（hash 校验、抽样比对）确认一致性。")])]),t._v(" "),a("p",[t._v("步骤 4：流量切换（灰度迁移）")]),t._v(" "),a("ul",[a("li",[t._v("在验证数据无误后，将业务读写请求逐步切换到新库。")]),t._v(" "),a("li",[t._v("可以采用 "),a("strong",[t._v("读流量先切")]),t._v("，再切写流量，避免一次性切换导致大故障。")]),t._v(" "),a("li",[t._v("这里推荐 "),a("strong",[t._v("蓝绿发布")]),t._v(" 或 "),a("strong",[t._v("双活切换")]),t._v("。")])]),t._v(" "),a("p",[t._v("步骤 5：确认一致性并下线旧库")]),t._v(" "),a("ul",[a("li",[t._v("切换后短时间保留双写或增量同步，待验证无误后下线旧库。")])]),t._v(" "),a("hr"),t._v(" "),a("p",[a("strong",[t._v("2. 保证一致性的关键点")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("全量 + 增量结合")]),t._v("：先拷贝静态数据，再捕获实时变化。")]),t._v(" "),a("li",[a("strong",[t._v("校验机制")]),t._v("：对关键表做 "),a("strong",[t._v("row count + checksum/hash 校验")]),t._v("，确保无丢失。")]),t._v(" "),a("li",[a("strong",[t._v("幂等性")]),t._v("：迁移程序必须保证重复消费 binlog 时不会产生脏数据。")]),t._v(" "),a("li",[a("strong",[t._v("最终一致性")]),t._v("：接受迁移过程中存在短暂延迟，但最终必须对齐。")]),t._v(" "),a("li",[a("strong",[t._v("流量切换要平滑")]),t._v("：避免一次性大规模切换引发不可控风险。")])]),t._v(" "),a("hr"),t._v(" "),a("p",[a("strong",[t._v("3. 常见工具链")])]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("MySQL")]),t._v("：pt-online-schema-change、gh-ost（用于表结构变更不停机）")]),t._v(" "),a("li",[a("strong",[t._v("数据迁移/同步")]),t._v("：Canal、Debezium、Maxwell、DataX、DTS（阿里云）")]),t._v(" "),a("li",[a("strong",[t._v("消息队列中转")]),t._v("：Kafka（承接 binlog 流，再同步到目标库）")])]),t._v(" "),a("h3",{attrs:{id:"🎯-说一说三个范式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-说一说三个范式"}},[t._v("#")]),t._v(" 🎯 说一说三个范式？")]),t._v(" "),a("p",[t._v("数据库设计中的三个范式（3NF）是用于规范数据库的结构，以减少数据冗余和提高数据的一致性。")]),t._v(" "),a("ul",[a("li",[t._v("第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。")]),t._v(" "),a("li",[t._v("第二范式（2NF）：第二范式在第一范式的基础上进一步规范化，要求表中的每一列都与主键直接相关，而不是间接相关")]),t._v(" "),a("li",[t._v('第三范式（3NF）：第三范式要求列之间没有传递依赖，即非主键列之间不能相互依赖。所谓传递函数依赖，指的是如果存在"A → B → C"的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y')])]),t._v(" "),a("h3",{attrs:{id:"🎯-limit-100000-加载很慢的话-你是怎么解决的呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-limit-100000-加载很慢的话-你是怎么解决的呢"}},[t._v("#")]),t._v(" 🎯 limit 100000 加载很慢的话，你是怎么解决的呢？")]),t._v(" "),a("p",[t._v("在 mysql 中 limit 可以实现快速分页，但是如果数据到了几百万时我们的 limit 必须优化才能有效的合理的实现分页了，否则可能卡死你的服务器")]),t._v(" "),a("p",[a("strong",[t._v("当一个表数据有几百万的数据的时候成了问题！")])]),t._v(" "),a("p",[t._v("日常分页SQL语句")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("select id,name,content from users order by id asc limit 100000,20\n")])])]),a("p",[t._v("扫描100020行")]),t._v(" "),a("p",[t._v("如果记录了上次的最大ID")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" select id,name,content from users where id>100073 order by id asc limit 20\n")])])]),a("p",[t._v("扫描 20 行。")]),t._v(" "),a("p",[t._v("总数据有500万左右，以下例子")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("select * from wl_tagindex where byname='f' order by id limit 300000,10 \n")])])]),a("p",[t._v("执行时间是 3.21s")]),t._v(" "),a("p",[t._v("优化后：")]),t._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("select * from (\n  select id from wl_tagindex\nwhere byname='f' order by id limit 300000,10\n) a\nleft join wl_tagindex b on a.id=b.id\n")])])]),a("p",[t._v("执行时间为 0.11s 速度明显提升")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("原查询需要扫描并丢弃前 300,000 行数据。优化后的子查询只选择 id 列，大大减少了需要处理的数据量")]),t._v(" "),a("p",[t._v("这里需要说明的是 我这里用到的字段是 byname ,id 需要把这两个字段做复合索引，否则的话效果提升不明显")])])]),t._v(" "),a("h3",{attrs:{id:"🎯-在高并发情况下-如何做到安全的修改同一行数据-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-在高并发情况下-如何做到安全的修改同一行数据-2"}},[t._v("#")]),t._v(" 🎯 在高并发情况下，如何做到安全的修改同一行数据？")]),t._v(" "),a("p",[a("strong",[t._v("1、使用悲观锁")])]),t._v(" "),a("p",[t._v("悲观锁本质是当前只有一个线程执行操作，排斥外部请求的修改。遇到加锁的状态，就必须等待。结束了唤醒其他线程进行处理。虽然此方案的确解决了数据安全的问题，但是，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。")]),t._v(" "),a("p",[a("strong",[t._v("2、FIFO（First Input First Output，先进先出）缓存队列思路")])]),t._v(" "),a("p",[t._v("直接将请求放入队列中，就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20190508231654761.",alt:""}})]),t._v(" "),a("p",[t._v("然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时间还是会大幅下降，系统还是陷入异常。")]),t._v(" "),a("p",[a("strong",[t._v("3、使用乐观锁")])]),t._v(" "),a("p",[t._v("这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。")]),t._v(" "),a("h3",{attrs:{id:"🎯-表中有大字段-x-例如-text-类型-且字段-x-不会经常更新-以读为-为主-将该字段拆成子表好处是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-表中有大字段-x-例如-text-类型-且字段-x-不会经常更新-以读为-为主-将该字段拆成子表好处是什么"}},[t._v("#")]),t._v(" 🎯 表中有大字段 "),a("strong",[t._v("X")]),t._v("(例如:"),a("strong",[t._v("text")]),t._v(" 类型)，且字段 "),a("strong",[t._v("X")]),t._v(" 不会经常更新，以读为 为主，将该字段拆成子表好处是什么?")]),t._v(" "),a("p",[t._v("如果字段里面有大字段(text,blob)类型的，而且这些字段的访问并不多，这 时候放在一起就变成缺点了。 MYSQL 数据库的记录存储是按行存储的，数据 块大小又是固定的(16K)，每条记录越小，相同的块存储的记录就越多。此 时应该把大字段拆走，这样应付大部分小字段的查询时，就能提高效率。当需 要查询大字段时，此时的关联查询是不可避免的，但也是值得的。拆分开后， 对字段的 UPDAE 就要 UPDATE 多个表了")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql-数据达到多少会产生瓶颈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql-数据达到多少会产生瓶颈"}},[t._v("#")]),t._v(" 🎯 MySQL 数据达到多少会产生瓶颈？")]),t._v(" "),a("p",[t._v("MySQL在处理大型数据集时，性能瓶颈的出现并非仅取决于数据量的大小，还与硬件配置、表结构设计、索引情况、查询复杂度和并发访问量等多种因素密切相关。因此，很难给出一个精确的数据量阈值来确定何时会出现瓶颈。")]),t._v(" "),a("p",[a("strong",[t._v("一般情况下，以下情况可能会导致MySQL产生性能瓶颈：")])]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("单表数据量过大：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("数据量级别")]),t._v("：当单表记录数达到"),a("strong",[t._v("数百万到数千万")]),t._v("时，查询性能可能会明显下降。")]),t._v(" "),a("li",[a("strong",[t._v("影响因素")]),t._v("：如果缺乏合理的索引和优化，查询速度会受到显著影响。")])])]),t._v(" "),a("li",[a("strong",[t._v("索引设计不合理：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("缺少必要索引")]),t._v("：没有为常用查询添加索引，导致全表扫描。")]),t._v(" "),a("li",[a("strong",[t._v("过多索引")]),t._v("：索引过多会增加写入和更新的开销。")]),t._v(" "),a("li",[a("strong",[t._v("索引碎片")]),t._v("：频繁的插入和删除操作会导致索引碎片化。")])])]),t._v(" "),a("li",[a("strong",[t._v("硬件资源限制：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("内存不足")]),t._v("：无法将常用数据缓存到内存中，导致频繁的磁盘I/O。")]),t._v(" "),a("li",[a("strong",[t._v("磁盘性能")]),t._v("：传统HDD的读写速度较慢，可能成为瓶颈。")]),t._v(" "),a("li",[a("strong",[t._v("CPU性能")]),t._v("：复杂查询和高并发需要更高的CPU处理能力。")])])]),t._v(" "),a("li",[a("strong",[t._v("高并发访问：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("连接数过多")]),t._v("：大量的并发连接会消耗系统资源，导致性能下降。")]),t._v(" "),a("li",[a("strong",[t._v("锁竞争")]),t._v("：高并发写操作会导致锁竞争，影响事务的执行效率。")])])]),t._v(" "),a("li",[a("strong",[t._v("查询复杂度高：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("复杂的JOIN操作")]),t._v("：多表关联查询会增加数据库的计算负担。")]),t._v(" "),a("li",[a("strong",[t._v("未优化的SQL语句")]),t._v("：如使用"),a("code",[t._v("SELECT *")]),t._v("或缺少条件过滤。")])])]),t._v(" "),a("li",[a("strong",[t._v("配置参数不当：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("默认配置不适合大数据量")]),t._v("：需要根据业务场景调整MySQL的配置参数，如"),a("code",[t._v("innodb_buffer_pool_size")]),t._v("。")]),t._v(" "),a("li",[a("strong",[t._v("连接池设置不合理")]),t._v("：可能导致资源浪费或不足。")])])]),t._v(" "),a("li",[a("strong",[t._v("事务和锁机制的影响：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("长事务")]),t._v("：长时间占用锁资源，阻塞其他事务。")]),t._v(" "),a("li",[a("strong",[t._v("死锁问题")]),t._v("：不合理的事务管理可能导致死锁。")])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-sql-注入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-sql-注入"}},[t._v("#")]),t._v(" 🎯 SQL 注入？")]),t._v(" "),a("p",[t._v("SQL注入是一种常见且危险的安全漏洞，但有几种有效的方法可以防止它。以下是解决SQL注入问题的主要方法：")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("使用参数化查询（预处理语句）：")]),t._v(" "),a("p",[t._v("这是防止SQL注入最有效和推荐的方法。参数化查询将SQL语句和数据分开处理，从而防止恶意输入被解释为SQL命令。")]),t._v(" "),a("p",[a("strong",[t._v("不安全的 SQL 查询：")])]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[t._v("String query "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SELECT * FROM users WHERE username = \'"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" username "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"' AND password = '\"")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" password "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\'"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("攻击者可以通过输入 "),a("code",[t._v('" OR "1" = "1')]),t._v(" 这样类似的内容绕过验证，导致 SQL 注入。")]),t._v(" "),a("p",[a("strong",[t._v("使用预编译语句的安全查询：")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" query "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SELECT * FROM users WHERE username = ? AND password = ?"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PreparedStatement")]),t._v(" stmt "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" connection"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("prepareStatement")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("query"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstmt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" username"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstmt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" password"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ResultSet")]),t._v(" rs "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" stmt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("executeQuery")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("使用ORM（对象关系映射）：ORM工具通常会自动使用参数化查询，提供额外的安全层。")])]),t._v(" "),a("li",[a("p",[t._v("输入验证和清洗：")]),t._v(" "),a("ul",[a("li",[t._v("使用白名单策略（允许合法字符），拒绝非预期的输入")]),t._v(" "),a("li",[t._v("限制输入的长度，避免输入过多字符")]),t._v(" "),a("li",[t._v("对输入的数据类型进行严格验证，如预期是数字类型的字段必须验证输入为数字")]),t._v(" "),a("li",[t._v("对特殊字符进行转义或过滤（如 "),a("code",[t._v("'")]),t._v(", "),a("code",[t._v('"')]),t._v(", "),a("code",[t._v(";")]),t._v(" 等）")])])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("最小权限原则")]),t._v("：确保应用程序连接数据库的账号仅具备完成任务所需的最小权限，避免攻击者一旦突破防线就能全面操控数据库。")])]),t._v(" "),a("li",[a("p",[t._v("当然，还有些 统一编码、定期安全审计、保持软件更新 等措施")])])]),t._v(" "),a("h2",{attrs:{id:"十、-手撕-sql-🖊️"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、-手撕-sql-🖊️"}},[t._v("#")]),t._v(" 十、 手撕 SQL 🖊️")]),t._v(" "),a("h3",{attrs:{id:"🎯-十岁为一组-统计每个年龄段的用户数量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-十岁为一组-统计每个年龄段的用户数量"}},[t._v("#")]),t._v(" 🎯 十岁为一组，统计每个年龄段的用户数量")]),t._v(" "),a("p",[t._v("要以每 10 岁为一组统计用户数量，可以使用 "),a("code",[t._v("FLOOR")]),t._v(" 函数（向下取整）对用户的年龄进行分组，然后使用 "),a("code",[t._v("GROUP BY")]),t._v(" 和 "),a("code",[t._v("COUNT(*)")]),t._v(" 来统计每个年龄段的用户数量")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" \n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'0-9'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("19")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'10-19'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("29")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'20-29'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("39")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'30-39'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("40")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("49")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'40-49'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("59")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'50-59'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("69")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'60-69'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("70")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("79")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'70-79'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("BETWEEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("80")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("89")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'80-89'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("90")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'90+'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Unknown'")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" age_group"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" user_count\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" users\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" age_group\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" age_group"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("---------")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("\n  CONCAT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("FLOOR"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'-'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" FLOOR"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" age_range"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" user_count\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" users\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" FLOOR"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" FLOOR"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("age "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h3",{attrs:{id:"🎯-给学生表、课程成绩表-求不存在01课程但存在02课程的学生的成绩"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-给学生表、课程成绩表-求不存在01课程但存在02课程的学生的成绩"}},[t._v("#")]),t._v(" 🎯 给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩")]),t._v(" "),a("p",[t._v("这种方法比较多，我用最简单的， 使用 "),a("code",[t._v("LEFT JOIN")]),t._v(" 和 "),a("code",[t._v("IS NULL")])]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v("\n    cg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("student_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    cg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("course_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    cg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("grade\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v("\n    course_grades cg\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" students s "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" cg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("student_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("student_id\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LEFT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" course_grades cg2 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" cg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("student_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" cg2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("student_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" cg2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("course_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'01'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v("\n    cg"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("course_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'02'")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" cg2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("student_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("还可以使用 "),a("code",[t._v("NOT IN")]),t._v(" 子查询")]),t._v(" "),a("h3",{attrs:{id:"🎯-查询第二大的数值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-查询第二大的数值"}},[t._v("#")]),t._v(" 🎯 查询第二大的数值")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("使用 ORDER BY 和 LIMIT")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DISTINCT")]),t._v(" column_name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" table_name\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" column_name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OFFSET")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])]),a("p",[t._v("这个查询先按降序排列,然后跳过第一个结果(OFFSET 1),取下一个结果(LIMIT 1)")])]),t._v(" "),a("li",[a("p",[t._v("使用子查询")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MAX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("column_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" table_name\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" column_name "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MAX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("column_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" table_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])]),t._v(" "),a("li",[a("p",[t._v("使用 "),a("code",[t._v("DENSE_RANK()")]),t._v(" 窗口函数【MySQL 8.0+  支持】")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" column_name\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" column_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" DENSE_RANK"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" column_name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" rank\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" table_name\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" ranked\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" rank "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])])]),t._v(" "),a("h3",{attrs:{id:"🎯-经典排名问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-经典排名问题"}},[t._v("#")]),t._v(" 🎯 经典排名问题")]),t._v(" "),a("p",[t._v("排名问题是SQL面试的经典题型，考察对窗口函数和聚合查询的掌握：")]),t._v(" "),a("p",[a("strong",[t._v("💻 排名问题SQL实现")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 基础排名问题 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 题目1：查询各科目成绩前3名的学生")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" student_scores "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    student_id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    student_name "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    subject "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    score "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    exam_date "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DATE")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 插入测试数据")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INSERT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INTO")]),t._v(" student_scores "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VALUES")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'张三'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'数学'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("95")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2024-01-15'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'李四'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'数学'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("88")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2024-01-15'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'王五'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'数学'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("92")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2024-01-15'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'赵六'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'数学'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("85")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2024-01-15'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'张三'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'英语'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("90")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2024-01-15'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'李四'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'英语'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("95")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2024-01-15'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'王五'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'英语'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("88")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2024-01-15'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 解法1：使用窗口函数")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WITH")]),t._v(" ranked_scores "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        student_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        student_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        subject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        ROW_NUMBER"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" subject "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" score "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" rn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        RANK"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" subject "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" score "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" rnk"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        DENSE_RANK"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" subject "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" score "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" dense_rnk\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" student_scores\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    student_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    student_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    subject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    score"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    rn "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" row_number_rank"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    rnk "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" rank_with_gaps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    dense_rnk "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" dense_rank\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" ranked_scores\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" rn "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" subject"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" score "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 题目2：查询每个部门薪资前20%的员工")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WITH")]),t._v(" salary_percentiles "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        employee_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        employee_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        department"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        salary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        PERCENT_RANK"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" department "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" salary "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" percentile_rank\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" employees\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    employee_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    employee_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    department"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    salary"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("percentile_rank "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" top_percentage\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" salary_percentiles\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" percentile_rank "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.2")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 前20%")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" department"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" salary "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h3",{attrs:{id:"🎯-连续问题求解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-连续问题求解"}},[t._v("#")]),t._v(" 🎯 连续问题求解")]),t._v(" "),a("p",[t._v("连续问题是考察逻辑思维的重要题型：")]),t._v(" "),a("p",[a("strong",[t._v("💻 连续问题SQL实现")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 连续登录问题 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 题目：找出连续登录3天以上的用户")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLE")]),t._v(" user_login_log "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    user_id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    login_date "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DATE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    login_time "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TIMESTAMP")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 解法：使用ROW_NUMBER()找连续区间")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WITH")]),t._v(" date_with_row "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DISTINCT")]),t._v("\n        user_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        login_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        ROW_NUMBER"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" user_id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" login_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" rn\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" user_login_log\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\nconsecutive_groups "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        user_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        login_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        DATE_SUB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("login_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INTERVAL")]),t._v(" rn "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DAY")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" group_date\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" date_with_row\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\nconsecutive_counts "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        user_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        group_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" consecutive_days"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MIN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("login_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" start_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MAX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("login_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" end_date\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" consecutive_groups\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" user_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" group_date\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    user_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    consecutive_days"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    start_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    end_date\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" consecutive_counts\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" consecutive_days "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" user_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" start_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 题目：股票连续上涨问题")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WITH")]),t._v(" price_changes "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        stock_code"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        trade_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        closing_price"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        LAG"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("closing_price"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" stock_code "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" trade_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" prev_price"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" \n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" closing_price "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" LAG"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("closing_price"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" stock_code "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" trade_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" is_up\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" stock_prices\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\nconsecutive_ups "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        stock_code"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" up_days"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MIN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("trade_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" start_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MAX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("trade_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" end_date\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n            stock_code"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            trade_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" is_up "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n                "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("OVER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PARTITION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" stock_code "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" trade_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" group_id\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" price_changes\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" is_up "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" grouped\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" stock_code"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" group_id\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" consecutive_ups\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" up_days "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" stock_code"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" start_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h3",{attrs:{id:"🎯-复杂业务场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-复杂业务场景"}},[t._v("#")]),t._v(" 🎯 复杂业务场景")]),t._v(" "),a("p",[t._v("实际业务中的复杂查询场景：")]),t._v(" "),a("p",[a("strong",[t._v("💻 业务场景SQL实现")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 电商用户行为分析 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('-- 题目：找出"流失预警"用户（最后购买>30天，但历史活跃）')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WITH")]),t._v(" user_purchase_stats "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        user_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" total_orders"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("order_amount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" total_spent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("AVG")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("order_amount"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" avg_order_value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MAX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("order_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" last_purchase_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        DATEDIFF"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("NOW")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("MAX")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("order_date"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" days_since_last_purchase\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" orders\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" order_status "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'completed'")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" user_id\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\nuser_segments "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" \n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" total_orders "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" avg_order_value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("200")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'VIP客户'")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" total_orders "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" total_spent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'优质客户'")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" total_orders "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'普通客户'")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'新客户'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" customer_segment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" \n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" days_since_last_purchase "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'高风险流失'")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" days_since_last_purchase "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" total_orders "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'流失预警'")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" days_since_last_purchase "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'活跃用户'")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'一般用户'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" churn_risk_level\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" user_purchase_stats\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    customer_segment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    churn_risk_level"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" user_count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("AVG")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("total_orders"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" avg_orders"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("AVG")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("total_spent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" avg_total_spent\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" user_segments\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" customer_segment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" churn_risk_level\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" \n    FIELD"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("customer_segment"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'VIP客户'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'优质客户'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'普通客户'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'新客户'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    FIELD"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("churn_risk_level"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'高风险流失'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'流失预警'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'一般用户'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'活跃用户'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 树形递归查询 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 题目：查询员工的所有下属")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WITH")]),t._v(" RECURSIVE subordinates "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 锚点：直接下属")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        emp_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        emp_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        manager_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" employees\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" manager_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1001")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 查询员工1001的下属")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UNION")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ALL")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 递归：下属的下属")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("emp_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("emp_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("manager_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" employees e\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INNER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" subordinates s "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" e"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("manager_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("emp_id\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" s"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 限制层级")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    emp_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    emp_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    CONCAT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("REPEAT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'  '")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" emp_name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" hierarchy_display\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" subordinates\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("level")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" emp_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),a("h2",{attrs:{id:"十一、运维与监控-🔧"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十一、运维与监控-🔧"}},[t._v("#")]),t._v(" 十一、运维与监控 🔧")]),t._v(" "),a("p",[a("strong",[t._v("核心理念")]),t._v("：数据库运维与监控是保障系统稳定运行的关键，及时发现和解决问题能够避免业务中断和数据丢失。")]),t._v(" "),a("h3",{attrs:{id:"🎯-mysql备份和恢复策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql备份和恢复策略"}},[t._v("#")]),t._v(" 🎯 MySQL备份和恢复策略？")]),t._v(" "),a("p",[t._v("MySQL备份恢复是数据安全的最后一道防线，需要制定完善的备份策略：")]),t._v(" "),a("p",[a("strong",[t._v("💻 备份恢复实战")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 逻辑备份（mysqldump）=====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n# 完整数据库备份\nmysqldump -u root -p --single-transaction --routines --triggers \\\n         --all-databases > full_backup_$(date +%Y%m%d_%H%M%S).sql\n\n# 单个数据库备份\nmysqldump -u root -p --single-transaction --routines --triggers \\\n         ecommerce > ecommerce_backup_$(date +%Y%m%d_%H%M%S).sql\n\n# 只备份结构不备份数据\nmysqldump -u root -p --no-data ecommerce > ecommerce_schema.sql\n\n# 只备份数据不备份结构\nmysqldump -u root -p --no-create-info ecommerce > ecommerce_data.sql\n\n# 备份特定表\nmysqldump -u root -p ecommerce users orders > tables_backup.sql\n\n# 压缩备份\nmysqldump -u root -p --single-transaction ecommerce | gzip > backup.sql.gz\n*/")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 物理备份（MySQL Enterprise Backup / Percona XtraBackup）=====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*\n# 使用Percona XtraBackup进行热备份\n# 完整备份\ninnobackupex --user=backup_user --password=backup_pass /backup/full/\n\n# 增量备份（基于完整备份）\ninnobackupex --user=backup_user --password=backup_pass \\\n            --incremental /backup/inc1/ \\\n            --incremental-basedir=/backup/full/\n\n# 准备备份（应用redo log）\ninnobackupex --apply-log /backup/full/\n\n# 恢复数据\ninnobackupex --copy-back /backup/full/\n*/")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 基于binlog的时点恢复 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 查看binlog位置信息")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHOW")]),t._v(" MASTER "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("STATUS")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHOW")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BINARY")]),t._v(" LOGS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 查看特定时间点的binlog位置")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHOW")]),t._v(" BINLOG EVENTS "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'mysql-bin.000001'")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" Start_time "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2024-01-01 10:00:00'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/*\n# 时点恢复步骤\n# 1. 恢复最新全备份\nmysql -u root -p ecommerce < ecommerce_backup_20240101_020000.sql\n\n# 2. 应用binlog到指定时间点\nmysqlbinlog --start-datetime="2024-01-01 02:00:00" \\\n           --stop-datetime="2024-01-01 09:30:00" \\\n           mysql-bin.000001 mysql-bin.000002 | mysql -u root -p ecommerce\n\n# 3. 跳过错误事务，继续恢复\nmysqlbinlog --start-position=1000 --stop-position=2000 \\\n           mysql-bin.000001 | mysql -u root -p ecommerce\n*/')]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 自动化备份脚本示例 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('/*\n#!/bin/bash\n# MySQL自动备份脚本\n\nDATE=$(date +%Y%m%d_%H%M%S)\nBACKUP_DIR="/backup/mysql"\nLOG_FILE="$BACKUP_DIR/backup.log"\nRETENTION_DAYS=7\n\n# 创建备份目录\nmkdir -p $BACKUP_DIR\n\n# 执行备份\necho "$(date): Starting backup..." >> $LOG_FILE\nmysqldump -u backup_user -p$BACKUP_PASSWORD \\\n         --single-transaction --routines --triggers \\\n         --all-databases | gzip > $BACKUP_DIR/full_backup_$DATE.sql.gz\n\nif [ $? -eq 0 ]; then\n    echo "$(date): Backup completed successfully" >> $LOG_FILE\n    \n    # 清理过期备份\n    find $BACKUP_DIR -name "full_backup_*.sql.gz" -mtime +$RETENTION_DAYS -delete\n    echo "$(date): Old backups cleaned" >> $LOG_FILE\nelse\n    echo "$(date): Backup failed!" >> $LOG_FILE\n    # 发送告警邮件\n    echo "MySQL backup failed at $(date)" | mail -s "Backup Alert" admin@company.com\nfi\n*/')]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 备份验证 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 验证备份完整性的存储过程")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DELIMITER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CREATE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PROCEDURE")]),t._v(" ValidateBackup"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" backup_file "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("VARCHAR")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("255")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BEGIN")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DECLARE")]),t._v(" backup_size "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BIGINT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DECLARE")]),t._v(" table_count "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DECLARE")]),t._v(" record_count "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BIGINT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 这里应该包含备份文件大小检查")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 恢复到临时数据库进行验证")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 检查表数量和记录数量")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("COUNT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("tables")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("SUM")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("TABLE_ROWS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" total_rows\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("INTO")]),t._v(" table_count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" record_count\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" information_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLES")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" TABLE_SCHEMA "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'backup_validation_db'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n        backup_file"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        table_count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        record_count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" \n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" table_count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" record_count "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'VALID'")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'INVALID'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" validation_result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DELIMITER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h3",{attrs:{id:"🎯-mysql监控指标和故障排查"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-mysql监控指标和故障排查"}},[t._v("#")]),t._v(" 🎯 MySQL监控指标和故障排查？")]),t._v(" "),a("p",[t._v("MySQL监控需要关注多个维度的指标，及时发现性能瓶颈和潜在问题：")]),t._v(" "),a("p",[a("strong",[t._v("💻 监控和故障排查")]),t._v("：")]),t._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 关键性能指标监控 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 连接状态监控")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    VARIABLE_NAME"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    VARIABLE_VALUE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" VARIABLE_NAME\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Max_used_connections'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" \n            CONCAT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" @"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@max_connections")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'%'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" usage_percentage\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" performance_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("global_status\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" VARIABLE_NAME "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Connections'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Max_used_connections'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Threads_connected'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Threads_running'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 查询性能指标")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    VARIABLE_NAME"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    VARIABLE_VALUE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" VARIABLE_NAME\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Questions'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" CONCAT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" @"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@uptime")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("' QPS'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Slow_queries'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" \n            CONCAT"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" \n                   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" performance_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("global_status "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" VARIABLE_NAME "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Questions'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'%'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("''")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" rate_info\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" performance_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("global_status\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" VARIABLE_NAME "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Questions'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Queries'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Slow_queries'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Select_scan'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Sort_merge_passes'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- InnoDB缓冲池监控")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Buffer Pool Hit Rate'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" metric"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("reads")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" requests"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VARIABLE_VALUE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" hit_rate_percent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" \n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("reads")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" requests"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VARIABLE_VALUE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("99")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'优秀'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("reads")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" requests"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VARIABLE_VALUE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("95")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'良好'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'需要优化'")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("status")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" performance_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("global_status "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" VARIABLE_NAME "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Innodb_buffer_pool_reads'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("reads")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" VARIABLE_VALUE "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" performance_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("global_status "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" VARIABLE_NAME "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Innodb_buffer_pool_read_requests'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" requests"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 实时性能分析 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 当前运行的查询")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    ID"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("USER")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    HOST"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    DB"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    COMMAND"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TIME")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    STATE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LEFT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("INFO"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" QUERY_SAMPLE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("CASE")]),t._v(" \n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TIME")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("60")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'长时间运行'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TIME")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("THEN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'需要关注'")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ELSE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'正常'")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("END")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("status")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" information_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("PROCESSLIST \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" COMMAND "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Sleep'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TIME")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 锁等待分析")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" waiting_trx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_mysql_thread_id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" waiting_thread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_query "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" waiting_query"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" blocking_trx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_mysql_thread_id "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" blocking_thread"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_query "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" blocking_query"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    TIMESTAMPDIFF"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SECOND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_started"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("NOW")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" wait_time_seconds\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" information_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("INNODB_LOCK_WAITS w\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" information_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("INNODB_TRX b "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" w"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("blocking_trx_id\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("JOIN")]),t._v(" information_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("INNODB_TRX r "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ON")]),t._v(" r"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("trx_id "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" w"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("requesting_trx_id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- ===== 故障排查查询 =====")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 查找占用空间最大的表")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    TABLE_SCHEMA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    TABLE_NAME"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DATA_LENGTH "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" INDEX_LENGTH"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" size_mb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    TABLE_ROWS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("INDEX_LENGTH "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" index_size_mb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DATA_LENGTH "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("AS")]),t._v(" data_size_mb\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" information_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLES")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" TABLE_SCHEMA "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'information_schema'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'mysql'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'performance_schema'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'sys'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DATA_LENGTH "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" INDEX_LENGTH"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LIMIT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- 分析表碎片化情况")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" \n    TABLE_SCHEMA"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    TABLE_NAME"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    TABLE_ROWS"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    AVG_ROW_LENGTH"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DATA_LENGTH "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" data_mb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DATA_FREE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" free_mb"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("ROUND")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DATA_FREE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("DATA_LENGTH "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" DATA_FREE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" fragmentation_percent\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" information_schema"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TABLES")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" TABLE_SCHEMA "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("NOT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'information_schema'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'mysql'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'performance_schema'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'sys'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" DATA_FREE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ORDER")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" fragmentation_percent "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DESC")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("hr"),t._v(" "),a("h2",{attrs:{id:"🎯-面试重点总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🎯-面试重点总结"}},[t._v("#")]),t._v(" 🎯 面试重点总结")]),t._v(" "),a("h3",{attrs:{id:"高频考点速览"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高频考点速览"}},[t._v("#")]),t._v(" 高频考点速览")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("🏗️ 基础与架构")]),t._v("：MySQL架构组件、DDL/DML/DCL区别、SQL语法和最佳实践")]),t._v(" "),a("li",[a("strong",[t._v("🗄️ 存储引擎")]),t._v("：InnoDB vs MyISAM特性、内存结构、磁盘结构、缓冲池机制")]),t._v(" "),a("li",[a("strong",[t._v("🔍 索引机制")]),t._v("：B+树原理、索引类型、联合索引最左前缀、覆盖索引、索引失效场景")]),t._v(" "),a("li",[a("strong",[t._v("🔒 事务与锁")]),t._v("：ACID特性实现、隔离级别对比、锁机制、MVCC原理、死锁处理")]),t._v(" "),a("li",[a("strong",[t._v("📊 查询优化")]),t._v("：JOIN类型优化、窗口函数、执行计划分析、数据类型选择")]),t._v(" "),a("li",[a("strong",[t._v("📝 日志系统")]),t._v("：redo log、undo log、binlog机制、WAL原理、恢复策略")]),t._v(" "),a("li",[a("strong",[t._v("⚡ 性能调优")]),t._v("：慢查询分析、参数调优、缓存策略、硬件优化")]),t._v(" "),a("li",[a("strong",[t._v("🚀 分库分表")]),t._v("：主从复制、读写分离、分片策略、数据迁移、集群部署")]),t._v(" "),a("li",[a("strong",[t._v("💻 SQL实战")]),t._v("：复杂查询编写、存储过程、函数、CTE递归查询")]),t._v(" "),a("li",[a("strong",[t._v("🔧 运维监控")]),t._v("：备份恢复、监控指标、故障排查、容量规划、日常维护")])]),t._v(" "),a("h3",{attrs:{id:"面试答题策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面试答题策略"}},[t._v("#")]),t._v(" 面试答题策略")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("基础概念题")]),t._v("：先说定义和原理，再举具体应用例子，最后分析优缺点和适用场景")]),t._v(" "),a("li",[a("strong",[t._v("性能优化题")]),t._v("：分析性能瓶颈，提出具体优化方案，说明效果评估方法")]),t._v(" "),a("li",[a("strong",[t._v("架构设计题")]),t._v("：从业务需求出发，考虑数据量和并发量，选择合适的架构方案")]),t._v(" "),a("li",[a("strong",[t._v("故障排查题")]),t._v("：描述排查思路和工具，定位根本原因，提供解决方案和预防措施")])]),t._v(" "),a("h3",{attrs:{id:"核心设计原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心设计原则"}},[t._v("#")]),t._v(" 核心设计原则")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("性能优先")]),t._v("：合理设计索引，优化查询语句，配置合适的参数，选择适合的存储引擎")]),t._v(" "),a("li",[a("strong",[t._v("数据安全")]),t._v("：事务保证一致性，完善的备份恢复策略，严格的权限控制机制")]),t._v(" "),a("li",[a("strong",[t._v("高可用设计")]),t._v("：消除单点故障，实现故障自动切换，多层次的监控告警体系")]),t._v(" "),a("li",[a("strong",[t._v("可扩展性")]),t._v("：分库分表应对数据增长，读写分离提升并发能力，集群化部署")]),t._v(" "),a("li",[a("strong",[t._v("运维规范")]),t._v("：标准化的部署流程，完善的监控体系，及时的故障响应机制")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"📚-扩展学习"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#📚-扩展学习"}},[t._v("#")]),t._v(" 📚 扩展学习")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("MySQL官方文档")]),t._v("：深入学习存储引擎原理、性能调优最佳实践")]),t._v(" "),a("li",[a("strong",[t._v("经典书籍")]),t._v("：《高性能MySQL》、《MySQL技术内幕》、《数据库系统概念》")]),t._v(" "),a("li",[a("strong",[t._v("开源工具")]),t._v("：Percona Toolkit、pt-query-digest、MySQL Workbench使用")]),t._v(" "),a("li",[a("strong",[t._v("监控方案")]),t._v("：Prometheus+Grafana、Zabbix、云监控平台实践")]),t._v(" "),a("li",[a("strong",[t._v("新版本特性")]),t._v("：MySQL 8.0新特性、JSON支持、窗口函数、CTE等")])]),t._v(" "),a("p",[a("strong",[t._v("记住：数据库是应用系统的核心，扎实的MySQL基础和丰富的优化经验是后端工程师的核心竞争力！")]),t._v(" 🚀")])])}),[],!1,null,null,null);s.default=n.exports}}]);